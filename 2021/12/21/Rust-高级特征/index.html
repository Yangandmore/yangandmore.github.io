<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Rust-高级特征 | 杨小杨的博客</title>
  <meta name="keywords" content=" rust ">
  <meta name="description" content="Rust-高级特征 | 杨小杨的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="行为型模式的讨论">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式-行为型模式的讨论">
<meta property="og:url" content="http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/index.html">
<meta property="og:site_name" content="杨小杨的博客">
<meta property="og:description" content="行为型模式的讨论">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/DesignPatterns/26.png">
<meta property="og:image" content="http://example.com/img/DesignPatterns/26_1.png">
<meta property="og:image" content="http://example.com/img/DesignPatterns/26_2.png">
<meta property="og:image" content="http://example.com/img/DesignPatterns/26_3.png">
<meta property="article:published_time" content="2023-03-13T22:14:00.000Z">
<meta property="article:modified_time" content="2023-03-13T14:49:43.920Z">
<meta property="article:author" content="Yang">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/DesignPatterns/26.png">


<link rel="icon" href="/img/header.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="杨小杨的博客" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/header.png"/>
</a>
<div class="author">
    <span>Yang</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/Yangandmore"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:635408602@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=635408602&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(178)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="数据库">
                        
                        数据库
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="包管理">
                        
                        包管理
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="编译的库">
                        
                        编译的库
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分布式事务">
                        
                        分布式事务
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分布式搜索">
                        
                        分布式搜索
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后台">
                        
                        后台
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="机器学习">
                        
                        机器学习
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="快捷键">
                        
                        快捷键
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="流程引擎">
                        
                        流程引擎
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="设计模式">
                        
                        设计模式
                        <small>(27)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构">
                        <i class="fold iconfont icon-right"></i>
                        
                        数据结构
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="数据结构<--->算法分析">
                                        
                                        算法分析
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="异常问题">
                        
                        异常问题
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="音视频">
                        
                        音视频
                        <small>(13)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="整洁代码">
                        
                        整洁代码
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="正则表达式">
                        
                        正则表达式
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Android">
                        <i class="fold iconfont icon-right"></i>
                        
                        Android
                        <small>(17)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Android<--->热更新">
                                        
                                        热更新
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="C/C++">
                        
                        C/C++
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="git">
                        
                        git
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Gradle">
                        
                        Gradle
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="java">
                        
                        java
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="JavaScript">
                        <i class="fold iconfont icon-right"></i>
                        
                        JavaScript
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="JavaScript<--->npm">
                                        
                                        npm
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="ReactNative">
                        
                        ReactNative
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Redis">
                        
                        Redis
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="rust">
                        <i class="fold iconfont icon-right"></i>
                        
                        rust
                        <small>(46)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="rust<--->p2p">
                                        
                                        p2p
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="spring">
                        <i class="fold iconfont icon-right"></i>
                        
                        spring
                        <small>(9)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="spring<--->java">
                                        
                                        java
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="ssr">
                        
                        ssr
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="178">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>包管理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>贝塞尔曲线</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式事务</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式搜索</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>构建工具</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>后台</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>汇编</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>机器学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>跨域</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>快捷键</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>流程引擎</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>热更新</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>视频格式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据结构与算法分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图片格式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>异步</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>异常问题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>音频</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>音视频</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>整洁代码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>正则表达式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>直播</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>camera</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Cpp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>es</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ffmpeg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Gradle</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>javaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libfaac</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libjpeg-turbo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libx264</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libyuv</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NDK</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>react</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>React</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ReactNative</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RTMP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>rust</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>seate</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springboot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>srs</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ssr</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All 设计模式 "
           href="/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-行为型模式的讨论">设计模式-行为型模式的讨论</span>
            <span class="post-date" title="2023-03-13 22:14:00">2023/03/13</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-结构型模式的讨论">设计模式-结构型模式的讨论</span>
            <span class="post-date" title="2023-02-27 07:43:01">2023/02/27</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-创建型模式的讨论">设计模式-创建型模式的讨论</span>
            <span class="post-date" title="2023-02-25 17:01:24">2023/02/25</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-目录">设计模式-目录</span>
            <span class="post-date" title="2023-02-18 15:04:05">2023/02/18</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-策略模式">设计模式-策略模式</span>
            <span class="post-date" title="2023-02-17 15:13:59">2023/02/17</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-模版模式">设计模式-模版模式</span>
            <span class="post-date" title="2023-02-17 15:13:59">2023/02/17</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-访问者模式">设计模式-访问者模式</span>
            <span class="post-date" title="2023-02-17 15:13:59">2023/02/17</span>
        </a>
        
        <a  class="All java "
           href="/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="使用Spire包处理文档">使用Spire包处理文档</span>
            <span class="post-date" title="2023-02-15 16:54:16">2023/02/15</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-状态模式">设计模式-状态模式</span>
            <span class="post-date" title="2023-02-15 16:54:16">2023/02/15</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-中介者">设计模式-中介者</span>
            <span class="post-date" title="2023-02-14 10:50:00">2023/02/14</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-备忘录">设计模式-备忘录</span>
            <span class="post-date" title="2023-02-14 10:50:00">2023/02/14</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-观察者">设计模式-观察者</span>
            <span class="post-date" title="2023-02-14 10:50:00">2023/02/14</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-迭代器">设计模式-迭代器</span>
            <span class="post-date" title="2023-02-12 20:34:01">2023/02/12</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-解释器">设计模式-解释器</span>
            <span class="post-date" title="2023-02-12 20:34:01">2023/02/12</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-命令">设计模式-命令</span>
            <span class="post-date" title="2023-02-11 13:12:56">2023/02/11</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-代理">设计模式-代理</span>
            <span class="post-date" title="2023-02-11 07:43:01">2023/02/11</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-职责链">设计模式-职责链</span>
            <span class="post-date" title="2023-02-11 07:43:01">2023/02/11</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-享元">设计模式-享元</span>
            <span class="post-date" title="2023-02-10 23:12:38">2023/02/10</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-外观">设计模式-外观</span>
            <span class="post-date" title="2023-02-08 19:59:30">2023/02/08</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-装饰">设计模式-装饰</span>
            <span class="post-date" title="2023-02-07 18:47:30">2023/02/07</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式- 桥接">设计模式- 桥接</span>
            <span class="post-date" title="2023-02-06 19:46:00">2023/02/06</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式- 组合">设计模式- 组合</span>
            <span class="post-date" title="2023-02-06 19:46:00">2023/02/06</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-原型">设计模式-原型</span>
            <span class="post-date" title="2023-02-02 18:00:35">2023/02/02</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-单例">设计模式-单例</span>
            <span class="post-date" title="2023-02-02 18:00:35">2023/02/02</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-构建者模式">设计模式-构建者模式</span>
            <span class="post-date" title="2023-02-02 15:10:25">2023/02/02</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-抽象工厂">设计模式-抽象工厂</span>
            <span class="post-date" title="2023-01-31 15:55:25">2023/01/31</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-适配器">设计模式-适配器</span>
            <span class="post-date" title="2023-01-28 23:30:00">2023/01/28</span>
        </a>
        
        <a  class="All 快捷键 "
           href="/2023/01/28/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag="快捷键"
           data-author="" >
            <span class="post-title" title="idea快捷键(mac)-持续更新">idea快捷键(mac)-持续更新</span>
            <span class="post-date" title="2023-01-28 08:02:25">2023/01/28</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-工厂方法">设计模式-工厂方法</span>
            <span class="post-date" title="2023-01-28 08:02:25">2023/01/28</span>
        </a>
        
        <a  class="All 整洁代码 "
           href="/2023/01/28/%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%811/"
           data-tag="整洁代码"
           data-author="" >
            <span class="post-title" title="观看Clean Code(整洁代码)记录-1">观看Clean Code(整洁代码)记录-1</span>
            <span class="post-date" title="2023-01-28 08:02:25">2023/01/28</span>
        </a>
        
        <a  class="All 异常问题 "
           href="/2022/09/27/eclipse-mac-err/"
           data-tag="异常问题"
           data-author="" >
            <span class="post-title" title="eclipse-mac-err">eclipse-mac-err</span>
            <span class="post-date" title="2022-09-27 22:24:54">2022/09/27</span>
        </a>
        
        <a  class="All 流程引擎 "
           href="/2022/09/16/activiti7/"
           data-tag="流程引擎"
           data-author="" >
            <span class="post-title" title="流程引擎-activiti7">流程引擎-activiti7</span>
            <span class="post-date" title="2022-09-16 10:01:11">2022/09/16</span>
        </a>
        
        <a  class="All 分布式事务 "
           href="/2022/09/04/seate/"
           data-tag="seate,分布式事务"
           data-author="" >
            <span class="post-title" title="配置seate">配置seate</span>
            <span class="post-date" title="2022-09-04 19:11:24">2022/09/04</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/09/01/es-java/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="es在java环境中使用">es在java环境中使用</span>
            <span class="post-date" title="2022-09-01 22:11:48">2022/09/01</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/09/01/es-ik/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="es配置ik分词器及热更新">es配置ik分词器及热更新</span>
            <span class="post-date" title="2022-09-01 16:38:27">2022/09/01</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/08/06/es-7-change-password/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="es修改密码">es修改密码</span>
            <span class="post-date" title="2022-08-06 23:37:16">2022/08/06</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/08/06/es-linux/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="elk在linux上简单安装">elk在linux上简单安装</span>
            <span class="post-date" title="2022-08-06 21:02:25">2022/08/06</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/08/02/ELK/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="ELK学习">ELK学习</span>
            <span class="post-date" title="2022-08-02 15:13:44">2022/08/02</span>
        </a>
        
        <a  class="All 包管理 "
           href="/2022/07/29/chocolatey/"
           data-tag="包管理"
           data-author="" >
            <span class="post-title" title="chocolatey">chocolatey</span>
            <span class="post-date" title="2022-07-29 16:56:39">2022/07/29</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/28/Spring-%E5%9F%BA%E7%A1%805/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础5">Spring-基础5</span>
            <span class="post-date" title="2022-07-28 21:11:57">2022/07/28</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/28/Spring-%E5%9F%BA%E7%A1%804/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(四)">Spring-基础(四)</span>
            <span class="post-date" title="2022-07-28 15:50:59">2022/07/28</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/25/Spring-%E5%9F%BA%E7%A1%803/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(三)">Spring-基础(三)</span>
            <span class="post-date" title="2022-07-25 21:51:47">2022/07/25</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/25/Spring-%E5%9F%BA%E7%A1%802/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(二)">Spring-基础(二)</span>
            <span class="post-date" title="2022-07-25 10:26:06">2022/07/25</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/25/Spring-%E5%9F%BA%E7%A1%801/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(一)">Spring-基础(一)</span>
            <span class="post-date" title="2022-07-25 09:58:25">2022/07/25</span>
        </a>
        
        <a  class="All rust "
           href="/2022/07/17/P2P/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="P2P">P2P</span>
            <span class="post-date" title="2022-07-17 10:46:24">2022/07/17</span>
        </a>
        
        <a  class="All rust p2p "
           href="/2022/07/16/Rust-libp2p/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-libp2p">Rust-libp2p</span>
            <span class="post-date" title="2022-07-16 14:04:11">2022/07/16</span>
        </a>
        
        <a  class="All "
           href="/2022/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AE%B0%E8%B4%A6%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区块链-记账模式">区块链-记账模式</span>
            <span class="post-date" title="2022-07-06 21:48:04">2022/07/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/06/26/Summer-boot%E4%B8%80%E6%9C%9F%E5%AE%8F%E9%83%A8%E5%88%86%E6%9E%84%E6%80%9D%E5%8F%8A%E5%AE%9E%E7%8E%B0/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Summer-boot一期宏部分构思及实现">Summer-boot一期宏部分构思及实现</span>
            <span class="post-date" title="2022-06-26 10:12:27">2022/06/26</span>
        </a>
        
        <a  class="All git "
           href="/2022/06/16/Git-fork%E9%A1%B9%E7%9B%AE%E6%9B%B4%E6%96%B0/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git-fork项目更新">Git-fork项目更新</span>
            <span class="post-date" title="2022-06-16 15:11:56">2022/06/16</span>
        </a>
        
        <a  class="All rust "
           href="/2022/06/12/Rust-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-编码规范">Rust-编码规范</span>
            <span class="post-date" title="2022-06-12 09:05:33">2022/06/12</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2022/05/29/MySql-Some%E7%AD%89%E6%8C%87%E4%BB%A4/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="MySql_Some、Any、All的用法">MySql_Some、Any、All的用法</span>
            <span class="post-date" title="2022-05-29 10:07:14">2022/05/29</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/12/Redis-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-聚合操作">Redis-聚合操作</span>
            <span class="post-date" title="2022-05-12 14:34:47">2022/05/12</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/11/Redis-%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-切片集群配置">Redis-切片集群配置</span>
            <span class="post-date" title="2022-05-11 15:45:38">2022/05/11</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/10/Redis-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E9%85%8D%E7%BD%AE/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-哨兵机制配置">Redis-哨兵机制配置</span>
            <span class="post-date" title="2022-05-10 17:02:25">2022/05/10</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/10/Redis-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%85%B3/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-开启远程访问">Redis-开启远程访问</span>
            <span class="post-date" title="2022-05-10 14:24:32">2022/05/10</span>
        </a>
        
        <a  class="All rust "
           href="/2022/05/06/Rust-%E5%B1%9E%E6%80%A7/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-属性">Rust-属性</span>
            <span class="post-date" title="2022-05-06 10:08:24">2022/05/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/20/Rust-build/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust编译过程图">Rust编译过程图</span>
            <span class="post-date" title="2022-04-20 14:54:46">2022/04/20</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/08/Rust-Atomic/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-Atomic">Rust-Atomic</span>
            <span class="post-date" title="2022-04-08 09:55:50">2022/04/08</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/06/Rust-%E6%AD%BB%E7%81%B5%E6%9C%AF3/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-死灵术3">Rust-死灵术3</span>
            <span class="post-date" title="2022-04-06 20:48:19">2022/04/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/06/Rust-%E6%AD%BB%E7%81%B5%E6%9C%AF2/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-死灵术2">Rust-死灵术2</span>
            <span class="post-date" title="2022-04-06 14:54:22">2022/04/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/02/Rust-AnyTrait/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-AnyTrait">Rust-AnyTrait</span>
            <span class="post-date" title="2022-04-02 14:25:05">2022/04/02</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/02/Rust-Cow%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-Cow智能指针">Rust-Cow智能指针</span>
            <span class="post-date" title="2022-04-02 10:16:00">2022/04/02</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/01/Rust-%E6%AD%BB%E7%81%B5%E6%9C%AF/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-死灵书（一）">Rust-死灵书（一）</span>
            <span class="post-date" title="2022-04-01 16:42:36">2022/04/01</span>
        </a>
        
        <a  class="All rust "
           href="/2022/03/09/Rust-%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-参考手册">Rust-参考手册</span>
            <span class="post-date" title="2022-03-09 10:15:21">2022/03/09</span>
        </a>
        
        <a  class="All rust "
           href="/2022/03/08/Rust-%E5%AE%8F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-小宏书(声明宏)">Rust-高级-小宏书(声明宏)</span>
            <span class="post-date" title="2022-03-08 20:22:51">2022/03/08</span>
        </a>
        
        <a  class="All Android "
           href="/2022/03/03/Android%E9%9B%86%E6%88%90Rust/"
           data-tag="Android,rust"
           data-author="" >
            <span class="post-title" title="Android集成Rust">Android集成Rust</span>
            <span class="post-date" title="2022-03-03 10:56:49">2022/03/03</span>
        </a>
        
        <a  class="All rust "
           href="/2022/02/08/Rust-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-类型转换-From &amp; Into">Rust-类型转换-From &amp; Into</span>
            <span class="post-date" title="2022-02-08 16:53:33">2022/02/08</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/16/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bbitflags/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之bitflags">Rust-高级-Crate之bitflags</span>
            <span class="post-date" title="2022-01-16 22:36:28">2022/01/16</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Brayon/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之rayon">Rust-高级-Crate之rayon</span>
            <span class="post-date" title="2022-01-12 21:55:30">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Blazy-static/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之lazy_static">Rust-高级-Crate之lazy_static</span>
            <span class="post-date" title="2022-01-12 21:50:32">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8BWalkdir/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之Walkdir">Rust-高级-Crate之Walkdir</span>
            <span class="post-date" title="2022-01-12 21:50:15">2022/01/12</span>
        </a>
        
        <a  class="All "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bthreadpool/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之threadpool">Rust-高级-Crate之threadpool</span>
            <span class="post-date" title="2022-01-12 21:49:50">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Berror-chain/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之error_chain">Rust-高级-Crate之error_chain</span>
            <span class="post-date" title="2022-01-12 21:49:39">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bcrossbeam/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之crossbeam">Rust-高级-Crate之crossbeam</span>
            <span class="post-date" title="2022-01-12 21:16:24">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Btar/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之tar">Rust-高级-Crate之tar</span>
            <span class="post-date" title="2022-01-12 10:29:50">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/11/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Brand/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之rand">Rust-高级-Crate之rand</span>
            <span class="post-date" title="2022-01-11 14:52:45">2022/01/11</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/09/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bserde/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之serde">Rust-高级-Crate之serde</span>
            <span class="post-date" title="2022-01-09 21:10:52">2022/01/09</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/09/Rust%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust中的引用与借用">Rust中的引用与借用</span>
            <span class="post-date" title="2022-01-09 19:03:47">2022/01/09</span>
        </a>
        
        <a  class="All "
           href="/2022/01/09/graphQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="graphQL">graphQL</span>
            <span class="post-date" title="2022-01-09 17:02:35">2022/01/09</span>
        </a>
        
        <a  class="All "
           href="/2022/01/05/Rust-%E9%AB%98%E7%BA%A7-%E6%9C%8D%E5%8A%A1%E4%B9%8BActix/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust-高级-服务之Actix">Rust-高级-服务之Actix</span>
            <span class="post-date" title="2022-01-05 21:13:56">2022/01/05</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/05/Rust-%E9%AB%98%E7%BA%A7-%E5%BC%82%E6%AD%A5%E4%B9%8Bfutures/"
           data-tag="rust,异步"
           data-author="" >
            <span class="post-title" title="Rust-高级-异步之futures">Rust-高级-异步之futures</span>
            <span class="post-date" title="2022-01-05 21:13:38">2022/01/05</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/30/Rust-%E6%9C%80%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-最后的项目">Rust-最后的项目</span>
            <span class="post-date" title="2021-12-30 14:46:33">2021/12/30</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/21/Rust-%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级特征">Rust-高级特征</span>
            <span class="post-date" title="2021-12-21 22:22:15">2021/12/21</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/20/Rust-%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%9D%A5%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E7%BB%93%E6%9E%84/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-模式与模式匹配">Rust-模式与模式匹配</span>
            <span class="post-date" title="2021-12-20 20:53:44">2021/12/20</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/20/Rust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-面向对象">Rust-面向对象</span>
            <span class="post-date" title="2021-12-20 15:15:04">2021/12/20</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/20/Rust-%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-无畏并发">Rust-无畏并发</span>
            <span class="post-date" title="2021-12-20 09:44:35">2021/12/20</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/19/Rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-智能指针">Rust-智能指针</span>
            <span class="post-date" title="2021-12-19 10:23:23">2021/12/19</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/16/Rust-CargoAndCratesIO/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-CargoAndCratesIO">Rust-CargoAndCratesIO</span>
            <span class="post-date" title="2021-12-16 22:52:05">2021/12/16</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/16/Rust-%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-函数式语言功能:迭代器与闭包">Rust-函数式语言功能:迭代器与闭包</span>
            <span class="post-date" title="2021-12-16 16:08:22">2021/12/16</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/15/Rust-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-IO">Rust-IO</span>
            <span class="post-date" title="2021-12-15 17:07:26">2021/12/15</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/15/Rust-%E6%B5%8B%E8%AF%95/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-测试">Rust-测试</span>
            <span class="post-date" title="2021-12-15 14:08:29">2021/12/15</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/14/Rust-%E6%B3%9B%E5%9E%8B%E3%80%81trait%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-泛型、trait和生命周期">Rust-泛型、trait和生命周期</span>
            <span class="post-date" title="2021-12-14 20:57:17">2021/12/14</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/14/Rust-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-错误处理">Rust-错误处理</span>
            <span class="post-date" title="2021-12-14 10:48:51">2021/12/14</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/13/Rust-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-常见集合">Rust-常见集合</span>
            <span class="post-date" title="2021-12-13 20:55:23">2021/12/13</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/13/Rust-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87%E5%92%8C%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-使用模块组织和复用代码">Rust-使用模块组织和复用代码</span>
            <span class="post-date" title="2021-12-13 16:26:05">2021/12/13</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/13/Rust-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-枚举和模式匹配">Rust-枚举和模式匹配</span>
            <span class="post-date" title="2021-12-13 10:44:04">2021/12/13</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/12/Rust-%E7%BB%93%E6%9E%84%E4%BD%93/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-结构体">Rust-结构体</span>
            <span class="post-date" title="2021-12-12 22:42:42">2021/12/12</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/12/Rust-%E6%89%80%E6%9C%89%E6%9D%83/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-所有权">Rust-所有权</span>
            <span class="post-date" title="2021-12-12 11:32:16">2021/12/12</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/11/Rust-%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-基础技术">Rust-基础技术</span>
            <span class="post-date" title="2021-12-11 20:25:09">2021/12/11</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/11/Rust-%E7%BC%96%E7%A8%8B%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-编程猜谜游戏">Rust-编程猜谜游戏</span>
            <span class="post-date" title="2021-12-11 18:58:04">2021/12/11</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/10/Rust-%E5%85%A5%E9%97%A8/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-入门">Rust-入门</span>
            <span class="post-date" title="2021-12-10 11:18:25">2021/12/10</span>
        </a>
        
        <a  class="All java "
           href="/2021/12/10/Java-%E5%86%85%E9%83%A8%E7%B1%BB/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java-内部类">Java-内部类</span>
            <span class="post-date" title="2021-12-10 08:50:32">2021/12/10</span>
        </a>
        
        <a  class="All java "
           href="/2021/12/09/Java-%E6%8E%A5%E5%8F%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java-接口">Java-接口</span>
            <span class="post-date" title="2021-12-09 14:54:05">2021/12/09</span>
        </a>
        
        <a  class="All java "
           href="/2021/12/09/Java-%E5%A4%9A%E6%80%81/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java-多态">Java-多态</span>
            <span class="post-date" title="2021-12-09 08:42:47">2021/12/09</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/23/JavaNIO/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JavaNIO">JavaNIO</span>
            <span class="post-date" title="2021-11-23 10:47:14">2021/11/23</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/23/JavaIO/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JavaIO">JavaIO</span>
            <span class="post-date" title="2021-11-23 10:47:07">2021/11/23</span>
        </a>
        
        <a  class="All spring java "
           href="/2021/11/22/Spring%E5%B7%A5%E4%BD%9C%E5%AF%B9%E8%B1%A1/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring工作对象">Spring工作对象</span>
            <span class="post-date" title="2021-11-22 09:44:06">2021/11/22</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/18/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java函数式接口">Java函数式接口</span>
            <span class="post-date" title="2021-11-18 10:50:22">2021/11/18</span>
        </a>
        
        <a  class="All "
           href="/2021/11/17/SpringBoot%E5%90%AF%E5%8A%A8-%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot启动-基础">SpringBoot启动-基础</span>
            <span class="post-date" title="2021-11-17 17:01:58">2021/11/17</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/16/JRebel/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JRebel">JRebel</span>
            <span class="post-date" title="2021-11-16 08:58:18">2021/11/16</span>
        </a>
        
        <a  class="All spring "
           href="/2021/11/11/Spring%E5%90%AF%E5%8A%A8-%E5%9F%BA%E7%A1%80/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring启动-基础">Spring启动-基础</span>
            <span class="post-date" title="2021-11-11 15:25:33">2021/11/11</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/10/%E5%8F%8D%E5%B0%84/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="反射">反射</span>
            <span class="post-date" title="2021-11-10 20:57:08">2021/11/10</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/10/%E6%B3%A8%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="注解">注解</span>
            <span class="post-date" title="2021-11-10 20:50:55">2021/11/10</span>
        </a>
        
        <a  class="All spring "
           href="/2021/11/09/SpringAOP-%E5%9F%BA%E7%A1%80/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="SpringAOP-基础">SpringAOP-基础</span>
            <span class="post-date" title="2021-11-09 10:31:31">2021/11/09</span>
        </a>
        
        <a  class="All spring "
           href="/2021/11/08/SpringIOC-%E5%9F%BA%E7%A1%80/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="SpringIOC-基础">SpringIOC-基础</span>
            <span class="post-date" title="2021-11-08 10:27:28">2021/11/08</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2021/11/02/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"
           data-tag="音视频"
           data-author="" >
            <span class="post-title" title="音视频编解码技术基础">音视频编解码技术基础</span>
            <span class="post-date" title="2021-11-02 12:06:49">2021/11/02</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2021/11/02/MysqlErrHosts/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="mysql安装时，Unable to connect to any of the specified MySQL hosts">mysql安装时，Unable to connect to any of the specified MySQL hosts</span>
            <span class="post-date" title="2021-11-02 10:58:50">2021/11/02</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2021/10/08/H264%E7%BC%96%E7%A0%81-SPSPPS/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="H264编码 SPS &amp; PPS">H264编码 SPS &amp; PPS</span>
            <span class="post-date" title="2021-10-08 21:20:12">2021/10/08</span>
        </a>
        
        <a  class="All ssr "
           href="/2021/01/18/centos%E7%BB%88%E7%AB%AFssr%E9%85%8D%E7%BD%AE/"
           data-tag="ssr"
           data-author="" >
            <span class="post-title" title="centos终端ssr配置">centos终端ssr配置</span>
            <span class="post-date" title="2021-01-18 08:21:35">2021/01/18</span>
        </a>
        
        <a  class="All 数据结构 算法分析 "
           href="/2020/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E5%85%B6%E4%BA%8C/"
           data-tag="数据结构与算法分析"
           data-author="" >
            <span class="post-title" title="数据结构与算法分析阅读笔记其二">数据结构与算法分析阅读笔记其二</span>
            <span class="post-date" title="2020-12-14 22:34:39">2020/12/14</span>
        </a>
        
        <a  class="All 数据结构 算法分析 "
           href="/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
           data-tag="数据结构与算法分析"
           data-author="" >
            <span class="post-title" title="数据结构与算法分析阅读笔记">数据结构与算法分析阅读笔记</span>
            <span class="post-date" title="2020-12-09 21:52:40">2020/12/09</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/10/27/FLV%E6%A0%BC%E5%BC%8F/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="FLV格式">FLV格式</span>
            <span class="post-date" title="2020-10-27 15:33:56">2020/10/27</span>
        </a>
        
        <a  class="All 机器学习 "
           href="/2020/09/20/Mac%E4%B8%ADPython3-x%E7%BC%96%E8%AF%91Caffe/"
           data-tag="机器学习"
           data-author="" >
            <span class="post-title" title="Mac中Python3.x编译Caffe">Mac中Python3.x编译Caffe</span>
            <span class="post-date" title="2020-09-20 01:08:09">2020/09/20</span>
        </a>
        
        <a  class="All JavaScript npm "
           href="/2020/07/17/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"
           data-tag="直播"
           data-author="" >
            <span class="post-title" title="npm常用命令操作">npm常用命令操作</span>
            <span class="post-date" title="2020-07-17 10:14:01">2020/07/17</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/16/MediaExtractorANDMediaMuxer/"
           data-tag="android,音频"
           data-author="" >
            <span class="post-title" title="android端的音频处理工具MediaExtractor和MediaMuxer">android端的音频处理工具MediaExtractor和MediaMuxer</span>
            <span class="post-date" title="2020-07-16 11:55:28">2020/07/16</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/15/AAC%E9%9F%B3%E9%A2%91%E7%A0%81%E6%B5%81/"
           data-tag="android,音频"
           data-author="" >
            <span class="post-title" title="AAC音频码流">AAC音频码流</span>
            <span class="post-date" title="2020-07-15 17:45:10">2020/07/15</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/15/Android-PCM%E5%A4%84%E7%90%86/"
           data-tag="android,音频"
           data-author="" >
            <span class="post-title" title="Android-PCM">Android-PCM</span>
            <span class="post-date" title="2020-07-15 13:29:49">2020/07/15</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/13/yuv-tool%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag="android,libyuv"
           data-author="" >
            <span class="post-title" title="yuv-tool工具类">yuv-tool工具类</span>
            <span class="post-date" title="2020-07-13 22:58:21">2020/07/13</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2020/06/18/ffmpegforandroid%E7%BC%96%E8%AF%91/"
           data-tag="ffmpeg"
           data-author="" >
            <span class="post-title" title="ffmpegforandroid编译">ffmpegforandroid编译</span>
            <span class="post-date" title="2020-06-18 13:38:35">2020/06/18</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2020/06/11/libfaac%E7%BC%96%E8%AF%91/"
           data-tag="libfaac"
           data-author="" >
            <span class="post-title" title="libfaac编译">libfaac编译</span>
            <span class="post-date" title="2020-06-11 14:00:57">2020/06/11</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2020/06/11/libx264%E7%BC%96%E8%AF%91/"
           data-tag="libx264"
           data-author="" >
            <span class="post-title" title="libx264编译">libx264编译</span>
            <span class="post-date" title="2020-06-11 13:51:36">2020/06/11</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/06/10/RTMP%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"
           data-tag="RTMP,直播"
           data-author="" >
            <span class="post-title" title="RTMP规范学习">RTMP规范学习</span>
            <span class="post-date" title="2020-06-10 11:35:52">2020/06/10</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/06/01/React-Native%E7%83%AD%E6%9B%B4%E6%96%B0/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native热更新">React-Native热更新</span>
            <span class="post-date" title="2020-06-01 16:03:28">2020/06/01</span>
        </a>
        
        <a  class="All 后台 "
           href="/2020/06/01/JavaWeb/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JavaWeb">JavaWeb</span>
            <span class="post-date" title="2020-06-01 11:09:17">2020/06/01</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2020/05/26/JDBC/"
           data-tag="数据库,java"
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2020-05-26 16:23:01">2020/05/26</span>
        </a>
        
        <a  class="All 后台 "
           href="/2020/03/29/%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F/"
           data-tag="后台,跨域"
           data-author="" >
            <span class="post-title" title="了解跨域">了解跨域</span>
            <span class="post-date" title="2020-03-29 21:31:15">2020/03/29</span>
        </a>
        
        <a  class="All JavaScript "
           href="/2020/03/08/JavaScript%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="javaScript"
           data-author="" >
            <span class="post-title" title="JavaScript语法（一）">JavaScript语法（一）</span>
            <span class="post-date" title="2020-03-08 10:29:30">2020/03/08</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/03/06/React-native-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-native 高德地图">React-native 高德地图</span>
            <span class="post-date" title="2020-03-06 10:07:45">2020/03/06</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/03/03/React-16-8-Hooks/"
           data-tag="React"
           data-author="" >
            <span class="post-title" title="React 16.8 Hooks">React 16.8 Hooks</span>
            <span class="post-date" title="2020-03-03 10:07:02">2020/03/03</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/01/06/React-Native%E5%8E%9F%E7%94%9F%E9%80%9A%E4%BF%A1/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native原生通信">React-Native原生通信</span>
            <span class="post-date" title="2020-01-06 16:34:00">2020/01/06</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/27/React-Native%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native原理浅析">React-Native原理浅析</span>
            <span class="post-date" title="2019-12-27 15:32:08">2019/12/27</span>
        </a>
        
        <a  class="All 正则表达式 "
           href="/2019/12/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag="正则表达式"
           data-author="" >
            <span class="post-title" title="正则表达式">正则表达式</span>
            <span class="post-date" title="2019-12-18 21:45:36">2019/12/18</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/05/React-Native-%E5%8A%A8%E7%94%BB/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native-动画">React-Native-动画</span>
            <span class="post-date" title="2019-12-05 16:20:25">2019/12/05</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/03/React-%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="React-自学之路（二）">React-自学之路（二）</span>
            <span class="post-date" title="2019-12-03 13:06:53">2019/12/03</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/03/React-%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="React"
           data-author="" >
            <span class="post-title" title="React-自学之路（一）">React-自学之路（一）</span>
            <span class="post-date" title="2019-12-03 09:40:28">2019/12/03</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/10/12/React%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
           data-tag="react"
           data-author="" >
            <span class="post-title" title="React新的生命周期">React新的生命周期</span>
            <span class="post-date" title="2019-10-12 15:41:02">2019/10/12</span>
        </a>
        
        <a  class="All 后台 "
           href="/2019/09/18/%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%97%B6%EF%BC%8C%E5%87%BA%E7%8E%B0Could-not-calculate-build-plan%E9%94%99%E8%AF%AF/"
           data-tag="springboot"
           data-author="" >
            <span class="post-title" title="创建maven项目时，出现Could not calculate build plan错误">创建maven项目时，出现Could not calculate build plan错误</span>
            <span class="post-date" title="2019-09-18 09:25:06">2019/09/18</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2019/09/07/MySQL%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="MySQL常用指令">MySQL常用指令</span>
            <span class="post-date" title="2019-09-07 21:10:03">2019/09/07</span>
        </a>
        
        <a  class="All Android "
           href="/2019/07/05/RecycleView%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="RecycleView（一）">RecycleView（一）</span>
            <span class="post-date" title="2019-07-05 14:03:06">2019/07/05</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/25/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%89%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android动画（三）">Android动画（三）</span>
            <span class="post-date" title="2019-06-25 14:15:26">2019/06/25</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/20/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android动画（二）">Android动画（二）</span>
            <span class="post-date" title="2019-06-20 15:10:00">2019/06/20</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/19/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android动画（一）">Android动画（一）</span>
            <span class="post-date" title="2019-06-19 15:15:56">2019/06/19</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/18/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android自定义控件（二）">Android自定义控件（二）</span>
            <span class="post-date" title="2019-06-18 13:43:11">2019/06/18</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/13/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"
           data-tag="Android,贝塞尔曲线"
           data-author="" >
            <span class="post-title" title="贝塞尔曲线">贝塞尔曲线</span>
            <span class="post-date" title="2019-06-13 10:14:25">2019/06/13</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/04/Java-Binder%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%90%86%E8%A7%A3/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Java Binder进程通信理解">Java Binder进程通信理解</span>
            <span class="post-date" title="2019-06-04 14:01:43">2019/06/04</span>
        </a>
        
        <a  class="All Android "
           href="/2019/05/30/arm-neon-h%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD/"
           data-tag="汇编"
           data-author="" >
            <span class="post-title" title="arm-neon.h文件功能">arm-neon.h文件功能</span>
            <span class="post-date" title="2019-05-30 08:45:08">2019/05/30</span>
        </a>
        
        <a  class="All Android "
           href="/2019/05/06/Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"
           data-tag="android"
           data-author="" >
            <span class="post-title" title="Handler消息机制">Handler消息机制</span>
            <span class="post-date" title="2019-05-06 14:09:45">2019/05/06</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/05/06/H264%E7%BC%96%E7%A0%81-%E7%86%B5%E7%BC%96%E7%A0%81/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="H264编码-熵编码">H264编码-熵编码</span>
            <span class="post-date" title="2019-05-06 13:42:57">2019/05/06</span>
        </a>
        
        <a  class="All Android "
           href="/2019/04/08/NDK%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"
           data-tag="NDK"
           data-author="" >
            <span class="post-title" title="NDK开发问题合集">NDK开发问题合集</span>
            <span class="post-date" title="2019-04-08 10:53:30">2019/04/08</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/04/01/H264%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="H264编码基础">H264编码基础</span>
            <span class="post-date" title="2019-04-01 09:26:11">2019/04/01</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/03/31/srs%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"
           data-tag="直播,srs"
           data-author="" >
            <span class="post-title" title="srs直播平台搭建">srs直播平台搭建</span>
            <span class="post-date" title="2019-03-31 10:37:42">2019/03/31</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/03/27/%E5%9B%BE%E7%89%87RGB%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"
           data-tag="图片格式"
           data-author="" >
            <span class="post-title" title="图片RGB数据格式">图片RGB数据格式</span>
            <span class="post-date" title="2019-03-27 22:24:49">2019/03/27</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/03/14/%E5%9B%BE%E7%89%87YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"
           data-tag="图片格式"
           data-author="" >
            <span class="post-title" title="图片YUV数据格式">图片YUV数据格式</span>
            <span class="post-date" title="2019-03-14 11:10:16">2019/03/14</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2019/03/08/libjpeg-turbo%E7%BC%96%E8%AF%91/"
           data-tag="libjpeg-turbo"
           data-author="" >
            <span class="post-title" title="libjpeg-turbo编译">libjpeg-turbo编译</span>
            <span class="post-date" title="2019-03-08 13:41:20">2019/03/08</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2019/03/07/libYUV%E7%BC%96%E8%AF%91/"
           data-tag="libyuv"
           data-author="" >
            <span class="post-title" title="libYUV编译">libYUV编译</span>
            <span class="post-date" title="2019-03-07 15:05:11">2019/03/07</span>
        </a>
        
        <a  class="All Android "
           href="/2019/02/18/Android-camera%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="camera"
           data-author="" >
            <span class="post-title" title="Android camera（一）">Android camera（一）</span>
            <span class="post-date" title="2019-02-18 15:03:27">2019/02/18</span>
        </a>
        
        <a  class="All C/C++ "
           href="/2019/01/23/Cpp%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Cpp"
           data-author="" >
            <span class="post-title" title="Cpp基础（一）">Cpp基础（一）</span>
            <span class="post-date" title="2019-01-23 10:52:13">2019/01/23</span>
        </a>
        
        <a  class="All C/C++ "
           href="/2019/01/18/C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="C"
           data-author="" >
            <span class="post-title" title="C基础（一）">C基础（一）</span>
            <span class="post-date" title="2019-01-18 14:08:23">2019/01/18</span>
        </a>
        
        <a  class="All Android "
           href="/2018/12/18/EasyPermission/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="EasyPermission">EasyPermission</span>
            <span class="post-date" title="2018-12-18 13:20:30">2018/12/18</span>
        </a>
        
        <a  class="All Android "
           href="/2018/12/15/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android自定义控件（一）">Android自定义控件（一）</span>
            <span class="post-date" title="2018-12-15 21:44:34">2018/12/15</span>
        </a>
        
        <a  class="All ssr "
           href="/2018/12/10/Linux%E9%85%8D%E7%BD%AEShadowSocks-R/"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux配置ShadowSocks-R">Linux配置ShadowSocks-R</span>
            <span class="post-date" title="2018-12-10 15:58:52">2018/12/10</span>
        </a>
        
        <a  class="All Android 热更新 "
           href="/2018/10/29/Sophix%E7%83%AD%E6%9B%B4%E6%96%B0/"
           data-tag="android,热更新"
           data-author="" >
            <span class="post-title" title="Sophix热更新">Sophix热更新</span>
            <span class="post-date" title="2018-10-29 16:50:36">2018/10/29</span>
        </a>
        
        <a  class="All Android 热更新 "
           href="/2018/10/18/TinkerPatch%E7%83%AD%E6%9B%B4%E6%96%B0/"
           data-tag="android,热更新"
           data-author="" >
            <span class="post-title" title="TinkerPatch热更新">TinkerPatch热更新</span>
            <span class="post-date" title="2018-10-18 20:11:30">2018/10/18</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2018/06/21/React-native-flex%E5%B8%83%E5%B1%80/"
           data-tag="react"
           data-author="" >
            <span class="post-title" title="React-native flex布局">React-native flex布局</span>
            <span class="post-date" title="2018-06-21 16:22:47">2018/06/21</span>
        </a>
        
        <a  class="All Android "
           href="/2018/01/25/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android事件分发">Android事件分发</span>
            <span class="post-date" title="2018-01-25 16:36:52">2018/01/25</span>
        </a>
        
        <a  class="All Gradle "
           href="/2018/01/25/Gradle%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="构建工具,Gradle"
           data-author="" >
            <span class="post-title" title="Gradle（一）">Gradle（一）</span>
            <span class="post-date" title="2018-01-25 16:36:52">2018/01/25</span>
        </a>
        
        <a  class="All git "
           href="/2017/11/24/firstBlod2/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git详细讲解(远程)">Git详细讲解(远程)</span>
            <span class="post-date" title="2017-11-24 10:18:05">2017/11/24</span>
        </a>
        
        <a  class="All git "
           href="/2017/10/19/firstBlod/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git详细讲解(本地)">Git详细讲解(本地)</span>
            <span class="post-date" title="2017-10-19 21:49:28">2017/10/19</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Rust-高级特征" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Rust-高级特征</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="rust">rust</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">rust</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-03-08 03:57:19'>2021-12-21 22:22</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%8D%E5%AE%89%E5%85%A8-Rust"><span class="toc-text">一、不安全 Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B"><span class="toc-text">不安全的超能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-text">解引用裸指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="toc-text">调用不安全函数或方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%8A%BD%E8%B1%A1"><span class="toc-text">创建不安全代码的安全抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-extern-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">使用 extern 函数调用外部代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9%E5%8F%AF%E5%8F%98%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">访问或修改可变静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%89%E5%85%A8-trait"><span class="toc-text">实现不安全 trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E4%BD%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">访问联合体中的字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">何时使用不安全代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7-trait"><span class="toc-text">二、高级 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E5%9C%A8-trait-%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-text">关联类型在 trait 定义中指定占位符类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B-vs-%E6%B3%9B%E5%9E%8B"><span class="toc-text">关联类型 vs 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">默认泛型类型参数和运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%B6%88%E6%AD%A7%E4%B9%89-%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">完全限定语法与消歧义:调用相同名称的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6-trait-%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA-trait-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9F%90-trait-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">父 trait 用于在另一个 trait 中使用某 trait 的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newtype-%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BB%A5%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait"><span class="toc-text">newtype 模式用以在外部类型上实现外部 trait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-text">三、高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%8A%BD%E8%B1%A1%E8%80%8C%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F"><span class="toc-text">为了类型安全和抽象而使用 newtype 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%90%8C%E4%B9%89%E8%AF%8D"><span class="toc-text">类型别名用来创建类型同义词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84-%EF%BC%8Cnever-type"><span class="toc-text">从不返回的 ! ，never type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%92%8C-Sized-trait"><span class="toc-text">动态大小类型和 Sized trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sized-trait"><span class="toc-text">Sized trait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="toc-text">四、高级函数与闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E9%97%AD%E5%8C%85"><span class="toc-text">返回闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%8F"><span class="toc-text">五、宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">宏和函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#macro-rules-%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E6%80%A7%E5%AE%8F"><span class="toc-text">macro_rules!用于通用元编程的声明性宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E4%BB%8E%E5%B1%9E%E6%80%A7%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%E5%AE%8F"><span class="toc-text">用于从属性生成代码的过程宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89derive%E5%AE%8F"><span class="toc-text">如何编写自定义derive宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%AE%8F"><span class="toc-text">类属性宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%87%BD%E6%95%B0%E5%AE%8F"><span class="toc-text">类函数宏</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、不安全-Rust"><a href="#一、不安全-Rust" class="headerlink" title="一、不安全 Rust"></a>一、不安全 Rust</h2><p>目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust还隐藏有第二种语言，它不会强制执行这类内存安全保证:<code>不安全 Rust</code>。它与常规 Rust 代码无异，但是会提供额外的超级力量。</p>
<p>不安全 Rust 之所以存在，是因为静态分析本质上是保守的。当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些。这必然意味着有时代码可能是合法的，但是 Rust 不这么认为!在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”这么做的缺点就是你只能靠自己了:如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用。</p>
<p>另一个 Rust 存在不安全一面的原因是:底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。Rust 需要能够进行像直接与操作系统交互，甚至于编写你自己的操作系统这样的底层系统编程!这也是 Rust 语言的目标之一。让我们看看不安全 Rust 能做什么，和怎么做。</p>
<h3 id="不安全的超能力"><a href="#不安全的超能力" class="headerlink" title="不安全的超能力"></a>不安全的超能力</h3><p>可以通过 <code>unsafe</code> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码块。您可以在不安全的 Rust 中执行五种操作，称为不安全的超能力，而在安全的 Rust 中则不能。这些超能力包括：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现一个不安全的trait</li>
<li>unions 的访问字段</li>
</ul>
<p>有一点很重要， <code>unsafe 并不会关闭借用检查器或禁用任何其他 Rust 安全检查:如果在不安全代码中使用引用，其仍会被检查。 unsafe 关键字只是提供了那五个不会被编译器检查内存安全的功能。</code>你仍然能在不安全块中获得某种程度的安全!</p>
<p>再者， unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题:其意图在于作为程序员你将会确保 unsafe 块中的代码以有效的方式访问内存。</p>
<p>人是会犯错误的，错误总会发生，不过通过要求这五类操作必须位于标记为 <strong>unsafe</strong> 的块中，就能够知道任何与内存安全相关的错误必定位于 <strong>unsafe</strong> 块内。保持 <strong>unsafe</strong> 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了。</p>
<p>为了尽可能隔离不安全代码，将不安全代码封装进一个安全的抽象并提供安全 API 是一个好主意，当我们学习不安全函数和方法时会讨论到。标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象。这个计数防止了 unsafe 泄露到所有你或者用户希望使用由 unsafe 代码实现的功能的地方，因为使用其安全抽象是安全的。</p>
<p>让我们按顺序依次介绍上述五个超能力，同时我们会看到一些提供不安全代码的安全接口的抽象。</p>
<h3 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h3><p>回到 <code>“悬垂引用”</code> 部分，那里提到了编译器会确保引用总是有效的。不安全 Rust 有两个被称为 <code>裸指针(raw pointers)</code> 的类似于引用的新类型。<code>和引用一样，裸指针是可变或不可变的</code>，分别写作 <code>*const T</code> 和 <code>*mut T</code> 。<strong>这里的星号不是解引用运算符</strong>；它是类型名称的一部分。在裸指针的上下文中，<code>不可变</code> 意味着指针解引用之后不能直接赋值。</p>
<p>与引用和智能指针的区别在于：</p>
<ul>
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>
<p>通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用。<br>下面展示了如何从引用同时创建不可变和可变裸指针。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> num = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">let</span> r1 = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span>;<br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>;<br></code></pre></td></tr></table></figure><br>注意这里没有引入 <code>unsafe</code> 关键字 ———— <code>可以在安全代码中创建裸指针，只是不能在不安全块之外解引用裸指针</code>，稍后便会看到。</p>
<p>这里使用 <code>as</code> <strong>将不可变和可变引用强转为对应的裸指针类型。</strong>因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设。</p>
<p>接下来会创建一个不能确定其有效性的裸指针，下面代码展示了如何创建一个指向任意内存地址的裸指针。尝试使用任意内存是未定义行为:此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误(segfault)。通常没有好的理由编写这样的代码，不过却是可行的:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> address = <span class="hljs-number">0x012345usize</span>;<br><span class="hljs-keyword">let</span> r = address <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span>;<br></code></pre></td></tr></table></figure><br>记得我们说过可以在安全代码中创建裸指针，不过不能解引用裸指针和读取其指向的数据。 现在我们要做的就是对裸指针使用解引用运算符 <code>*</code> ，只要求一个 <code>unsafe</code> 块，如下所示:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> num = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">let</span> r1 = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span>;<br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>;<br><br><span class="hljs-keyword">unsafe</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);<br>&#125;<br></code></pre></td></tr></table></figure><br><code>创建一个指针不会造成任何危险;只有当访问其指向的值时才有可能遇到无效的值。</code></p>
<p>之前创建了同时指向相同内存位置 num 的裸指针 <code>*const i32</code> 和 <code>*mut i32</code> 。相反如果尝试创建 num 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用。通过裸指针，就能够同时创建同一地址的可变指针和不可变指针，若通过可变指针修改数据，则可能潜在造成数据竞争。请多加小心!</p>
<p>既然存在这么多的危险，为何还要使用裸指针呢?一个主要的应用场景便是调用 C 代码接口，这在下一部分不安全函数中会讲到。另一个场景是构建借用检查器无法理解的安全抽象。让我们先介绍不安全函数，接着看一看使用不安全代码的安全抽象的例子。</p>
<h3 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" class="headerlink" title="调用不安全函数或方法"></a>调用不安全函数或方法</h3><p>第二类要求使用不安全块的操作是调用不安全函数。不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <strong>unsafe</strong> 。 <strong>unsafe</strong> 表明我们作为程序需要满足其要求，因为 Rust 不会保证满足这些要求。通过在 unsafe 块中调用不安全函数，我们表明已经阅读过此函数的文档并对其是否满足函数自身的契约负责。</p>
<p>如下是一个没有做任何操作的不安全函数 dangerous 的例子:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">unsafe</span> fn <span class="hljs-title">dangerous</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br><span class="hljs-keyword">unsafe</span> &#123;<br>    dangerous();<br>&#125;<br></code></pre></td></tr></table></figure><br>必须在一个单独的 unsafe 块中调用 dangerous 函数。如果尝试不使用 unsafe 块调用 dangerous ，则会得到一个错误:<br><figure class="highlight vhdl"><table><tr><td class="code"><pre><code class="hljs vhdl">$ cargo run<br>   Compiling unsafe-example v0.<span class="hljs-number">1.0</span> (<span class="hljs-keyword">file</span>:///projects/unsafe-example)<br><span class="hljs-literal">error</span>[E0133]: call <span class="hljs-keyword">to</span> unsafe <span class="hljs-keyword">function</span> <span class="hljs-keyword">is</span> unsafe <span class="hljs-keyword">and</span> requires unsafe <span class="hljs-keyword">function</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">block</span><br> <span class="hljs-comment">--&gt; src/main.rs:4:5</span><br>  |<br><span class="hljs-number">4</span> |     dangerous();<br>  |     ^^^^^^^^^^^ call <span class="hljs-keyword">to</span> unsafe <span class="hljs-keyword">function</span><br>  |<br>  = <span class="hljs-literal">note</span>: consult the <span class="hljs-keyword">function</span><span class="hljs-symbol">&#x27;s</span> documentation <span class="hljs-keyword">for</span> information <span class="hljs-keyword">on</span> how <span class="hljs-keyword">to</span> avoid undefined behavior<br><br><span class="hljs-keyword">For</span> more information about this <span class="hljs-literal">error</span>, try `rustc <span class="hljs-comment">--explain E0133`.</span><br><span class="hljs-literal">error</span>: could <span class="hljs-keyword">not</span> compile `unsafe-example` due <span class="hljs-keyword">to</span> previous <span class="hljs-literal">error</span><br></code></pre></td></tr></table></figure></p>
<h3 id="创建不安全代码的安全抽象"><a href="#创建不安全代码的安全抽象" class="headerlink" title="创建不安全代码的安全抽象"></a>创建不安全代码的安全抽象</h3><p>仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。</p>
<p>作为一个例子，标准库中的函数， split_at_mut ，它需要一些不安全代码，让我们探索如何可以实现它。这个安全函数定义于<strong>可变切片</strong>之上:<code>它获取一个切片并从给定的索引参数开始将其分为两个切片。</code><br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">let</span> r = &amp;<span class="hljs-keyword">mut</span> v[..];<br><br><span class="hljs-keyword">let</span> (a, b) = r.split_at_mut(<span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">assert_eq!</span>(a, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-built_in">assert_eq!</span>(b, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br></code></pre></td></tr></table></figure><br>这个函数无法只通过安全 Rust 实现。可以看看下面的例子，它不能编译。处于简 单考虑，我们将 split_at_mut 实现为函数而不是方法，并只处理 i32 值而非泛型 T 的切片。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">split_at_mut</span></span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], mid: <span class="hljs-built_in">usize</span>) -&gt; (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> len = slice.len();<br><br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br><br>    (&amp;<span class="hljs-keyword">mut</span> slice[..mid], &amp;<span class="hljs-keyword">mut</span> slice[mid..])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vector = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">let</span> (left, right) = split_at_mut(&amp;<span class="hljs-keyword">mut</span> vector, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>此函数首先获取 slice 的长度，然后通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中。该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic。</p>
<p>之后我们在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 mid 索引，另一个从 mid 直到原 slice 的结尾。</p>
<p>但是，会得到一个错误：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">$ cargo run<br>   Compiling <span class="hljs-keyword">unsafe</span>-example v0.<span class="hljs-number">1.0</span> (file:<span class="hljs-comment">///projects/unsafe-example)</span><br>error[E0499]: cannot borrow `*slice` <span class="hljs-keyword">as</span> mutable more than once at a time<br> --&gt; src/main.rs:<span class="hljs-number">6</span>:<span class="hljs-number">30</span><br>  |<br><span class="hljs-number">1</span> | <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">split_at_mut</span></span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], mid: <span class="hljs-built_in">usize</span>) -&gt; (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>]) &#123;<br>  |                        - <span class="hljs-keyword">let</span><span class="hljs-symbol">&#x27;s</span> call the lifetime of this reference `&#x27;<span class="hljs-number">1</span>`<br>...<br><span class="hljs-number">6</span> |     (&amp;<span class="hljs-keyword">mut</span> slice[..mid], &amp;<span class="hljs-keyword">mut</span> slice[mid..])<br>  |     -------------------------^^^^^--------<br>  |     |     |                  |<br>  |     |     |                  second mutable borrow occurs here<br>  |     |     first mutable borrow occurs here<br>  |     returning this value requires that `*slice` is borrowed <span class="hljs-keyword">for</span> `&#x27;<span class="hljs-number">1</span>`<br><br>For more information about this error, <span class="hljs-keyword">try</span> `rustc --explain E0499`.<br>error: could not compile `<span class="hljs-keyword">unsafe</span>-example` due to previous error<br></code></pre></td></tr></table></figure><br>Rust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些。当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了</p>
<p>下面展示了如何使用 unsafe 块，裸指针和一些不安全函数调用来实现 split_at_mut：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">use std::slice;<br><br>fn split<span class="hljs-constructor">_at_mut(<span class="hljs-params">slice</span>: &amp;<span class="hljs-params">mut</span> [<span class="hljs-params">i32</span>], <span class="hljs-params">mid</span>: <span class="hljs-params">usize</span>)</span> -&gt; (&amp;mut <span class="hljs-literal">[<span class="hljs-identifier">i32</span>]</span>, &amp;mut <span class="hljs-literal">[<span class="hljs-identifier">i32</span>]</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = slice.len<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">let</span> ptr = slice.<span class="hljs-keyword">as</span><span class="hljs-constructor">_mut_ptr()</span>;<br><br>    <span class="hljs-keyword">assert</span>!(mid &lt;= len);<br><br>    unsafe &#123;<br>        (<br>            slice::from<span class="hljs-constructor">_raw_parts_mut(<span class="hljs-params">ptr</span>, <span class="hljs-params">mid</span>)</span>,<br>            slice::from<span class="hljs-constructor">_raw_parts_mut(<span class="hljs-params">ptr</span>.<span class="hljs-params">add</span>(<span class="hljs-params">mid</span>)</span>, len - mid),<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 len 方法获取 slice 的长度，使用 <code>as_mut_ptr</code> 方法访问 slice 的裸指针。在这个例子中，因为有一个 i32 值的可变 slice，<code>as_mut_ptr</code> 返回一个 <code>*mut i32 类型的裸指针</code>，储存在 ptr 变量中。</p>
<p>我们保持索引 mid 位于 slice 中的断言。<code>接着是不安全代码：slice::from_raw_parts_mut 函数获取一个裸指针和一个长度来创建一个 slice。</code>这里使用此函数从 ptr 中创建了一个有 mid 个项的 slice。之后在 ptr 上调用 add 方法并使用 mid 作为参数来获取一个从 mid 开始的裸指针，使用这个裸指针并以 mid 之后项的数量为长度创建一个 slice。</p>
<p><code>slice::from_raw_parts_mut 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。裸指针上的 add 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。</code>因此必须将 slice::from_raw_parts_mut 和 add 放入 unsafe 块中以便能调用它们。通过观察代码，和增加 mid 必然小于等于 len 的断言，我们可以说 unsafe 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 unsafe 的恰当用法。</p>
<p>注意无需将 split_at_mut 函数的结果标记为 unsafe，并可以在安全 Rust 中调用此函数。我们创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 unsafe 代码，因为其只从这个函数访问的数据中创建了有效的指针。</p>
<p>slice::from_raw_parts_mut 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::slice;<br><br><span class="hljs-keyword">let</span> address = <span class="hljs-number">0x01234usize</span>;<br><span class="hljs-keyword">let</span> r = address <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>;<br><br><span class="hljs-keyword">let</span> slice: &amp;[<span class="hljs-built_in">i32</span>] = <span class="hljs-keyword">unsafe</span> &#123; slice::from_raw_parts_mut(r, <span class="hljs-number">10000</span>) &#125;;<br></code></pre></td></tr></table></figure><br>我们并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 i32 值。试图使用臆测为有效的 slice 会导致未定义的行为。</p>
<h3 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 extern 函数调用外部代码</h3><p>有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字， <code>extern</code> ，有助于创建和使用 <code>外部函数接口(Foreign Function Interface， FFI)</code>。外部函数接口是一个编程语言用以定义函数的方式，其允许不同(外部)编程语言调用这些函数。</p>
<p>下面展示了如何集成 C 标准库中的 abs 函数。 extern 块中声明的函数在 Rust 代码中总是不安全的，因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">abs</span></span>(input: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, abs(-<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>在 <code>extern &quot;C&quot;</code> 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。 “C” 部分定义了外部函数所使用的 <code>应用二进制接口(application binary interface，ABI)</code> —— ABI 定义了如何在汇编语言层面调用此函数。 “C” ABI 是最常见的，并遵循 C 编程语言的 ABI。</p>
<blockquote>
<p>通过其它语言调用 Rust 函数<br>也可以使用 extern 来创建一个允许其他语言调用 Rust 函数的接口。不同于 extern 块，就在 fn 关键字之前增加 extern 关键字并指定所用到的ABI。还需增加 #[no_mangle] 注解来告诉 Rust 编译器不要 mangle 此函数的名称。mangling 发生于当编译器将我们指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读。每一个编程语言的编译器都会以稍微不同的方式 mangling 函数名，所以为了使 Rust 函数在其他语言中指定，必须禁用 Rust 编译器的 name mangling。</p>
</blockquote>
<p>在如下的例子中，一旦其编译为动态库并从 C 语言中链接， call_from_c 函数就能够在 C 代码中访问:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call_from_c</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Just called a Rust function from C!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>extern 的使用无需 unsafe 。</p>
<h3 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h3><p>目前为止全书都尽量避免讨论 <code>全局变量(global variables)</code>，Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的。<code>如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争。</code></p>
<p>全局变量在 Rust 中被称为 <code>静态(static)变量</code>。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> HELLO_WORLD: &amp;<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);<br>&#125;<br></code></pre></td></tr></table></figure><br>static 变量类似于常量。通常静态变量的名称采用<code>SCREAMING_SNAKE_CASE</code> 写法，并必须标注变量的类型，在这个例子中是 <code>&amp;&#39;static str</code> 。静态变量只能储存拥有 <code>&#39;static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。</p>
<p><strong>常量</strong>与<strong>不可变静态变量</strong>可能看起来很类似，不过一个微妙的区别是<strong>静态变量中的值有一个固定的内存地址</strong>。使用这个值总是会访问相同的地址。另一方面，<strong>常量则允许在任何被用到的时候复制其数据</strong>。</p>
<p>常量与静态变量的另一个区别在于<strong>静态变量可以是可变的</strong>。<code>访问和修改可变静态变量都是不安全的</code>。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_to_count</span></span>(inc: <span class="hljs-built_in">u32</span>) &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        COUNTER += inc;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    add_to_count(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>就像常规变量一样，我们使用 mut 关键来指定可变性。任何读写 COUNTER 的代码都必须位于 <strong>unsafe</strong> 块中。这段代码可以编译并如期打印出 <code>COUNTER: 3</code> ，因为这是单线程的。拥有多个线程访问 COUNTER 则可能导致数据竞争。</p>
<p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，请优先使用并发技术和线程安全智能指 针，这样编译器就能检测不同线程间的数据访问是安全的。</p>
<h3 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h3><p>unsafe 的另一个操作用例是<strong>实现不安全 trait</strong>。当 trait 中<strong>至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的</strong>。<code>可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe</code>。<br><figure class="highlight puppet"><table><tr><td class="code"><pre><code class="hljs puppet">unsafe trait <span class="hljs-keyword">Foo</span> &#123;<br>    // methods go here<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-keyword">Foo</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">i32</span> &#123;<br>    // method implementations go here<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-keyword">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><br>通过 <code>unsafe impl</code> ，我们承诺将保证编译器所不能验证的不变量。</p>
<p>编译器会自动为完全由 <code>Send</code> 和 <code>Sync</code> 类型组成的类型自动实现他们。如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync ，则必须使用 unsafe 。<code>Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 unsafe 表明</code>。</p>
<h3 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h3><p>仅适用于 unsafe 的最后一个操作是访问 <code>联合体</code> 中的字段，<strong>union 和 struct 类似，但是在一个实例中同时只能使用一个声明的字段。</strong>联合体主要用于和 C 代码中的联合体交互。<strong>访问联合体的字段是不安全的</strong>，因为 Rust 无法保证当前存储在联合体实例中数据的类型。</p>
<h3 id="何时使用不安全代码"><a href="#何时使用不安全代码" class="headerlink" title="何时使用不安全代码"></a>何时使用不安全代码</h3><p>使用 unsafe 来进行这五个操作之一是没有问题的，甚至是不需要深思熟虑的，不过使得 unsafe 代码正确也实属不易因为编译器不能帮助保证内存安全。当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注使得在出现错误时易于追踪问题的源头。</p>
<h2 id="二、高级-trait"><a href="#二、高级-trait" class="headerlink" title="二、高级 trait"></a>二、高级 trait</h2><h3 id="关联类型在-trait-定义中指定占位符类型"><a href="#关联类型在-trait-定义中指定占位符类型" class="headerlink" title="关联类型在 trait 定义中指定占位符类型"></a>关联类型在 trait 定义中指定占位符类型</h3><p><code>关联类型(associated types)</code>是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么。</p>
<p>一个带有关联类型的 trait 的例子是标准库提供的 <code>Iterator trait</code>。它有一个叫做 Item 的关联类型来替代遍历的值的类型。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Iterator</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><br>Iterator trait 有一个关联类型 Item 。 <strong>Item 是一个占位类型</strong>，同时 <strong>next</strong> 方法会返回<code>Option&lt;Self::Item&gt;</code> 类型的值。这个 trait 的实现者会指定 Item 的具体类型，然而不管实现者指定何种类型, <strong>next</strong> 方法都会返回一个包含了此具体类型值的 Option 。</p>
<h3 id="关联类型-vs-泛型"><a href="#关联类型-vs-泛型" class="headerlink" title="关联类型 vs 泛型"></a>关联类型 vs 泛型</h3><p>这可能看起来像一个类似泛型的概念，因为它允许定义一个函数而不指定其可以处理的类型。那么为什么要使用关联类型呢?<br>看下面的例子<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Counter</span></span> &#123;<br>    count: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Counter &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; Counter &#123;<br>        Counter &#123; count: <span class="hljs-number">0</span> &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> Counter &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = <span class="hljs-built_in">u32</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-comment">// --snip--</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.count &lt; <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-keyword">self</span>.count += <span class="hljs-number">1</span>;<br>            <span class="hljs-literal">Some</span>(<span class="hljs-keyword">self</span>.count)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这类似于泛型。那么为什么 Iterator trait 不像下面这样呢？<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Iterator</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><br>区别在于使用泛型时，<code>则不得不在每一个实现中标注类型</code>。这是因为我们也可以实现为 <code>Iterator&lt;String&gt; for Counter</code> ，或任何其他类型，这样就可以有多个Counter 的 Iterator 的实现。换句话说，当 trait 有泛型参数时，可以多次实现这个 trait， 每次需改变泛型参数的具体类型。接着当使用 Counter 的 next 方法时，必须提供类型注解来表明希望使用 Iterator 的哪一个实现。</p>
<p><code>通过关联类型，则无需标注类型因为不能多次实现这个 trait</code>。<strong>我们只能选择一次 Item 会是什么类型，因为只能有一个 impl Iterator for Counter 。</strong>当调用 Counter的 next 时不必每次指定我们需要 u32 值的迭代器。</p>
<h3 id="默认泛型类型参数和运算符重载"><a href="#默认泛型类型参数和运算符重载" class="headerlink" title="默认泛型类型参数和运算符重载"></a>默认泛型类型参数和运算符重载</h3><p>当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时 使用 <code>&lt;PlaceholderType=ConcreteType&gt;</code> 。</p>
<p>这种情况的一个非常好的例子是用于运算符重载。<strong>运算符重载</strong>是指在特定情况下自定义运算符(比如 + )行为的操作。</p>
<p>Rust 并不允许创建自定义运算符或重载任意运算符，不过 <code>std::ops</code> 中所列出的运算符和相应的 trait 可以通过实现运算符相关 trait 来重载。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-meta">#[derive(Debug, Copy, Clone, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Add <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Point;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, other: Point) -&gt; Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span> &#125; + Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span> &#125;,<br>        Point &#123; x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span> &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><br>add 方法将两个 Point 实例的 x 值和 y 值分别相加来创建一个新的 Point 。 <code>Add trait</code>有一个叫做 <strong>Output</strong> 的关联类型，它用来决定 add 方法的返回值类型。</p>
<p>这里默认泛型类型位于 <code>Add trait</code> 中。这里是其定义:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Add</span></span>&lt;Rhs=<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Rhs) -&gt; Self::Output;<br>&#125;<br></code></pre></td></tr></table></figure><br>这看来应该很熟悉，这是一个带有一个方法和一个关联类型的 trait。比较陌生的部分是尖括号中的 <code>RHS=Self</code> :<strong>这个语法叫做默认类型参数(default type parameters)</strong>。 RHS 是一个泛型类型参数 —— “right hand side” 的缩写 —— 它用于 add 方法中的 rhs 参数。<code>如果实现 Add trait 时不指定 RHS 的具体类型， RHS 的类型将是默认的 Self 类型，也就是在其上实现 Add 的类型。</code></p>
<p>当为 Point 实现 Add 时，使用了默认的 RHS ，因为我们希望将两个 Point 实例相加。让我们看看一个实现 Add trait 时希望自定义 RHS 类型而不是使用默认类型的例子。</p>
<p>这里有两个存放不同单元值的结构体， Millimeters 和 Meters 。我们希望能够将毫米值与米值相加，并让 Add 的实现正确处理转换。可以为 Millimeters 实现 Add 并以 Meters 作为右手边。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Millimeters</span></span>(<span class="hljs-built_in">u32</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Meters</span></span>(<span class="hljs-built_in">u32</span>);<br><br><span class="hljs-keyword">impl</span> Add&lt;Meters&gt; <span class="hljs-keyword">for</span> Millimeters &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Millimeters;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, other: Meters) -&gt; Millimeters &#123;<br>        Millimeters(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>为了使 Millimeters 和 Meters 能够相加，我们指定 <code>impl Add&lt;Meters&gt;</code> 来设定 RHS 类型参数的值而不是使用默认的 Self 。<br>默认参数类型主要用于如下两个方面:</p>
<ul>
<li><ol>
<li>扩展类型而不破坏现有代码。</li>
</ol>
</li>
<li><ol>
<li>在大部分用户都不需要的特定情况进行自定义。</li>
</ol>
</li>
</ul>
<p>标准库的 Add trait 就是一个第二个目的例子:大部分时候你会将两个相似的类型相加，不过它提供了自定义额外行为的能力。在 Add trait 定义中使用默认类型参数意味着大部分时候无需指定额外的参数。换句话说，一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了。</p>
<p>第一个目的是相似的，但过程是反过来的:如果需要为现有 trait 增加类型参数，为其提供一 个默认类型将允许我们在不破坏现有实现代码的基础上扩展 trait 的功能。</p>
<h3 id="完全限定语法与消歧义-调用相同名称的方法"><a href="#完全限定语法与消歧义-调用相同名称的方法" class="headerlink" title="完全限定语法与消歧义:调用相同名称的方法"></a>完全限定语法与消歧义:调用相同名称的方法</h3><p>Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait。甚至直接在类型上实现开始已经有的同名方法也是可能的!</p>
<p>不过，当调用这些同名方法时，需要告诉 Rust 我们希望使用哪一个。<br>下面定义了 trait Pilot 和 Wizard 都拥有方法 fly 。接着在一个本身已经实现了 名为 fly 方法的类型 Human 上实现这两个trait。每一个 fly 方法都进行了不同的操作:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Pilot</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fly</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Wizard</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fly</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Human</span></span>;<br><br><span class="hljs-keyword">impl</span> Pilot <span class="hljs-keyword">for</span> Human &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fly</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is your captain speaking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Wizard <span class="hljs-keyword">for</span> Human &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fly</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Up!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Human &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fly</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*waving arms furiously*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>两个 trait 定义为拥有 fly 方法，并在直接定义有 fly 方法的 Human 类型上实 现这两个 trait。<br>当调用 Human 实例的 fly 时，编译器默认调用直接是现在类型上的方法，如下所示：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">fn <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> person = Human;<br>    person.fly();<br>&#125;<br></code></pre></td></tr></table></figure><br>运行这段代码会打印出<code>*waving arms furiously</code> ，这表明 Rust 调用了直接实现在 Human 上的 fly 方法。<br>为了能够调用 Pilot trait 或 Wizard trait 的 fly 方法，我们需要使用更明显的语法以便能指定我们指的是哪个 fly 方法。<br><figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> person = Human;<br>    Pilot::fly(&amp;person);<br>    Wizard::fly(&amp;person);<br>    person.fly();<br>&#125;<br></code></pre></td></tr></table></figure><br>在方法名前指定 trait 名向 Rust 澄清了我们希望调用哪个 fly 实现。也可以选择写成 <code>Human::fly(&amp;person)</code> ，不过如果无需消歧义的话这么写就有点长了。<br>运行这段代码会打印出:<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ cargo run<br>   Compiling traits-example v0.<span class="hljs-number">1.0</span> (file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/projects/</span>traits-example)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.46</span>s<br>     Running `target<span class="hljs-regexp">/debug/</span>traits-example`<br>This is your captain speaking.<br>Up!<br>*waving arms furiously*<br></code></pre></td></tr></table></figure><br>因为 fly 方法获取一个 self 参数，如果有两个类型都实现了同一 trait，Rust 可以根据 self 的类型计算出应该使用哪一个 trait 实现。<br>然而，关联函数是 trait 的一部分，但没有 self 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出我们期望的是哪一个类型，除非使用 <code>完全限定语法(fully qualified syntax)</code>。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Animal</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">baby_name</span></span>() -&gt; <span class="hljs-built_in">String</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span></span>;<br><br><span class="hljs-keyword">impl</span> Dog &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">baby_name</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Spot&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Animal <span class="hljs-keyword">for</span> Dog &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">baby_name</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;puppy&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::baby_name());<br>&#125;<br></code></pre></td></tr></table></figure><br>这段代码用于一个动物收容所，他们将所有的小狗起名为 Spot，这实现为定义于 Dog 之上的关联函数 baby_name 。 Dog 类型还实现了 Animal trait，它描述了所有动物的共有的特征。小狗被称为 puppy，这表现为 Dog 的 Animal trait 实现中与 Animal trait 相关联的函数 baby_name 。<br>在 main 调用了 Dog::baby_name 函数，它直接调用了定义于 Dog 之上的关联函数。这段代码会打印出:<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ cargo run<br>   Compiling traits-example v0.<span class="hljs-number">1.0</span> (file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/projects/</span>traits-example)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.54</span>s<br>     Running `target<span class="hljs-regexp">/debug/</span>traits-example`<br>A baby dog is called a Spot<br></code></pre></td></tr></table></figure><br>这并不是我们需要的。我们希望调用的是 Dog 上 Animal trait实现那部分的 baby_name 函数，这样能够打印出 <code>A baby dog is called a puppy</code> 。如下代码中，则会得到一个编译错误:<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">fn <span class="hljs-selector-tag">main</span>() &#123;<br>    println!(&quot;<span class="hljs-selector-tag">A</span> baby dog is called <span class="hljs-selector-tag">a</span> &#123;&#125;&quot;, Animal::<span class="hljs-built_in">baby_name</span>());<br>&#125;<br></code></pre></td></tr></table></figure><br>因为 Animal::baby_name 是关联函数而不是方法，因此它没有 self 参数，Rust 无法计算出所需的是哪一个 Animal::baby_name 实现。我们会得到这个编译错误:<br><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">$ cargo <span class="hljs-keyword">run</span><br>   Compiling traits-example v0.1.0 (<span class="hljs-keyword">file</span>:<span class="hljs-comment">///projects/traits-example)</span><br><span class="hljs-keyword">error</span>[E0283]: <span class="hljs-keyword">type</span> annotations needed<br>  --&gt; src/main.rs:20:43<br>   |<br>20 |     println!(<span class="hljs-string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Animal::baby_name());<br>   |                                           ^^^^^^^^^^^^^^^^^ cannot infer <span class="hljs-keyword">type</span><br>   |<br>   = <span class="hljs-keyword">note</span>: cannot satisfy `_: Animal`<br><span class="hljs-keyword">note</span>: required <span class="hljs-keyword">by</span> `Animal::baby_name`<br>  --&gt; src/main.rs:2:5<br>   |<br>2  |     fn baby_name() -&gt; String;<br>   |     ^^^^^^^^^^^^^^^^^^^^^^^^^<br><br><span class="hljs-keyword">For</span> <span class="hljs-keyword">more</span> information <span class="hljs-keyword">about</span> this <span class="hljs-keyword">error</span>, try `rustc --explain E0283`.<br><span class="hljs-keyword">error</span>: could not compile `traits-example` due to previous <span class="hljs-keyword">error</span><br></code></pre></td></tr></table></figure><br>为了消歧义并告诉 Rust 我们希望使用的是 Dog 的 Animal 实现，需要使用完全限定语法， 这是调用函数时最为明确的方式。<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">fn <span class="hljs-selector-tag">main</span>() &#123;<br>    println!(&quot;<span class="hljs-selector-tag">A</span> baby dog is called <span class="hljs-selector-tag">a</span> &#123;&#125;&quot;, &lt;Dog as Animal&gt;::<span class="hljs-built_in">baby_name</span>());<br>&#125;<br></code></pre></td></tr></table></figure><br>我们在尖括号中向 Rust 提供了类型注解，并通过在此函数调用中将 Dog 类型当作 Animal 对待，来指定希望调用的是 Dog 上 Animal trait实现中的 baby_name 函数。现在这段代码会打印出我们期望的数据:<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ cargo run<br>   Compiling traits-example v0.<span class="hljs-number">1.0</span> (file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/projects/</span>traits-example)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.48</span>s<br>     Running `target<span class="hljs-regexp">/debug/</span>traits-example`<br>A baby dog is called a puppy<br></code></pre></td></tr></table></figure><br>通常，完全限定语法定义为:<br><figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi">&lt;<span class="hljs-keyword">Type</span> <span class="hljs-keyword">as</span> Trait&gt;::<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(receiver_if_method, next_arg, ...)</span>;</span><br></code></pre></td></tr></table></figure><br>对于关联函数，其没有一个 receiver ，故只会有其他参数的列表。可以选择在任何函数或方法调用处使用完全限定语法。然而，允许省略任何 Rust 能够从程序中的其他信息中计算出的部分。只有当存在多个同名实现而 Rust 需要帮助以便知道我们希望调用哪个实现时，才需要使用这个较为冗长的语法。</p>
<h3 id="父-trait-用于在另一个-trait-中使用某-trait-的功能"><a href="#父-trait-用于在另一个-trait-中使用某-trait-的功能" class="headerlink" title="父 trait 用于在另一个 trait 中使用某 trait 的功能"></a>父 trait 用于在另一个 trait 中使用某 trait 的功能</h3><p>有时我们可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的trait 也被实现。这个所需的 trait 是我们实现的 trait 的 <code>父(超) trait(supertrait)</code>。<br>例如我们希望创建一个带有 outline_print 方法的 trait OutlinePrint ，它会打印出带有星号框的值。也就是说，如果 Point 实现了 Display 并返回 (x, y) ，调用以 1 作为 x 和 3 作为 y 的 Point 实例的 outline_print 会显示如下:<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><br><span class="hljs-bullet">*        </span>*<br><span class="hljs-bullet">* </span>(1, 3) *<br><span class="hljs-bullet">*        </span>*<br><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><br></code></pre></td></tr></table></figure><br>在 outline_print 的实现中，因为希望能够使用 Display trait 的功能，则需要说明 OutlinePrint 只能用于同时也实现了 Display 并提供了 OutlinePrint 需要的功能的类型。可以通过在 trait 定义中指定 <code>OutlinePrint: Display</code> 来做到这一点。这类似于为 trait 增加 trait bound。<br><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">use std::fmt;<br><br>trait OutlinePrint: fmt::Display &#123;<br>    fn outline_print(&amp;<span class="hljs-built_in">self</span>) &#123;<br>        let <span class="hljs-built_in">output</span> = <span class="hljs-built_in">self</span>.to_string();<br>        let <span class="hljs-built_in">len</span> = <span class="hljs-built_in">output</span>.<span class="hljs-built_in">len</span>();<br>        println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-built_in">len</span> + <span class="hljs-number">4</span>));<br>        println!(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-built_in">len</span> + <span class="hljs-number">2</span>));<br>        println!(<span class="hljs-string">&quot;* &#123;&#125; *&quot;</span>, <span class="hljs-built_in">output</span>);<br>        println!(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-built_in">len</span> + <span class="hljs-number">2</span>));<br>        println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-built_in">len</span> + <span class="hljs-number">4</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>因为指定了 OutlinePrint 需要 Display trait，则可以在 outline_print 中使用 to_string ， 其会为任何实现 Display 的类型自动实现。如果不在 trait 名后增加 <code>:Display</code> 并尝试在 outline_print 中使用 to_string ，则会得到一个错误说在当前作用域中没有找到用于 <code>&amp;Self</code> 类型的方法 to_string 。</p>
<p>让我们看看如果尝试在一个没有实现 Display 的类型上实现 OutlinePrint 会发生什么，比如 Point 结构体:<br><figure class="highlight puppet"><table><tr><td class="code"><pre><code class="hljs puppet">struct <span class="hljs-keyword">Point</span> &#123;<br>    x: i32,<br>    y: i32,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-keyword">OutlinePrint</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">Point</span> &#123;&#125;<br></code></pre></td></tr></table></figure><br>这样会得到一个错误说 Display 是必须的而未被实现:<br><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">$ cargo <span class="hljs-keyword">run</span><br>   Compiling traits-example v0.1.0 (<span class="hljs-keyword">file</span>:<span class="hljs-comment">///projects/traits-example)</span><br><span class="hljs-keyword">error</span>[E0277]: `Point` doesn&#x27;t implement `std::fmt::<span class="hljs-keyword">Display</span>`<br>  --&gt; src/main.rs:20:6<br>   |<br>3  | trait OutlinePrint: fmt::<span class="hljs-keyword">Display</span> &#123;<br>   |                     ------------ required <span class="hljs-keyword">by</span> this bound <span class="hljs-keyword">in</span> `OutlinePrint`<br>...<br>20 | impl OutlinePrint <span class="hljs-keyword">for</span> Point &#123;&#125;<br>   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter<br>   |<br>   = <span class="hljs-keyword">help</span>: the trait `std::fmt::<span class="hljs-keyword">Display</span>` is not implemented <span class="hljs-keyword">for</span> `Point`<br>   = <span class="hljs-keyword">note</span>: <span class="hljs-keyword">in</span> <span class="hljs-keyword">format</span> strings you may be able to <span class="hljs-keyword">use</span> `&#123;:?&#125;` (or &#123;:#?&#125; <span class="hljs-keyword">for</span> pretty-<span class="hljs-keyword">print</span>) instead<br><br><span class="hljs-keyword">For</span> <span class="hljs-keyword">more</span> information <span class="hljs-keyword">about</span> this <span class="hljs-keyword">error</span>, try `rustc --explain E0277`.<br><span class="hljs-keyword">error</span>: could not compile `traits-example` due to previous <span class="hljs-keyword">error</span><br></code></pre></td></tr></table></figure><br>一旦在 Point 上实现 Display 并满足 OutlinePrint 要求的限制，比如这样:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>那么在 Point 上实现 OutlinePrint trait将能成功编译并可以在 Point 实例上调用 outline_print 来显示位于星号框中的点的值。</p>
<h3 id="newtype-模式用以在外部类型上实现外部-trait"><a href="#newtype-模式用以在外部类型上实现外部-trait" class="headerlink" title="newtype 模式用以在外部类型上实现外部 trait"></a>newtype 模式用以在外部类型上实现外部 trait</h3><p>之前 “为类型实现 trait” 部分，提到了<code>孤儿规则(orphan rule)</code>，<strong>它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。</strong>一个绕开这个限制的方法是使用<code>newtype 模式(newtype pattern)</code>，它涉及到在一个元组结构体中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是 本地的，这样就可以在这个封装上实现 trait。“Newtype” 是一个源自(U.C.0079，逃) Haskell 编程语言的概念。使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。</p>
<p>例如，如果想要在 Vec 上实现 Display ，而孤儿规则组织我们直接这么做，因为 Display trait 和 Vec 都定义于我们的 crate 之外。可以创建一个包含 Vec 实例的 Wrapper 结构体， 接着可以如列表 19-31 那样在 Wrapper 上实现 Display 并使用 Vec 的值:可以创建一个包含 Vec 实例的 Wrapper 结构体。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">use std::fmt;<br><br>struct <span class="hljs-keyword">Wrapper</span>(Vec&lt;String&gt;);<br><br>impl fmt::Display <span class="hljs-keyword">for</span> <span class="hljs-keyword">Wrapper</span> &#123;<br>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;<br>        <span class="hljs-keyword">write</span>!(f, &quot;[&#123;&#125;]&quot;, self<span class="hljs-number">.0</span>.<span class="hljs-keyword">join</span>(&quot;, &quot;))<br>    &#125;<br>&#125;<br><br>fn main() &#123;<br>    let w = <span class="hljs-keyword">Wrapper</span>(vec![String::<span class="hljs-keyword">from</span>(&quot;hello&quot;), String::<span class="hljs-keyword">from</span>(&quot;world&quot;)]);<br>    println!(&quot;w = &#123;&#125;&quot;, w);<br>&#125;<br></code></pre></td></tr></table></figure><br>Display 的实现使用 self.0 来访问其内部的 Vec ，因为 Wrapper 是元组结构体而 Vec是结构体总位于索引 0 的项。接着就可以使用 Wrapper 中 Display 的功能了。</p>
<p>此方法的缺点是，因为 Wrapper 是一个新类型，它没有定义于其值之上的方法;必须直接在 Wrapper 上实现 Vec 的所有方法，这样就可以代理到 self.0 上 —— 这就允许我们完全像 Vec 那样对待 Wrapper 。如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 <code>Deref trait</code>并返回其内部类型是一种解决方案。如果不希望封装类型拥有所有内部类型的方法，比如为了限制封装类型的行为，则必须只自行实现所需的方法。</p>
<h2 id="三、高级类型"><a href="#三、高级类型" class="headerlink" title="三、高级类型"></a>三、高级类型</h2><p>Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名(type aliases)，一个类似于 newtype 但有着稍微不同的语义的功能。我们还会讨论 ! 类型和动态大小类型。</p>
<h3 id="为了类型安全和抽象而使用-newtype-模式"><a href="#为了类型安全和抽象而使用-newtype-模式" class="headerlink" title="为了类型安全和抽象而使用 newtype 模式"></a>为了类型安全和抽象而使用 newtype 模式</h3><p>newtype 模式可以用于一些其他我们还未讨论的功能，包括静态的确保某值不被混淆，和用来表示一个值的单元。</p>
<p>另一个 newtype 模式的应用在于抽象掉一些类型的实现细节:例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的 API，以便限制其功能。</p>
<p>新类型也可以隐藏其内部的泛型类型。例如，可以提供一个封装了 <code>HashMap&lt;i32, String&gt;</code> 的 People 类型，用来储存人名以及相应的 ID。使用 People 的代码只需与提供的公有 API 交互即可，比如向 People 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 i32 ID 赋予了这个名字了。### 类型别名用来创建类型同义词</p>
<h3 id="类型别名用来创建类型同义词"><a href="#类型别名用来创建类型同义词" class="headerlink" title="类型别名用来创建类型同义词"></a>类型别名用来创建类型同义词</h3><p>连同 newtype 模式，Rust 还提供了声明 类型别名(type alias)的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 i32 的别名 Kilometers :<br><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">Kilometers </span>= i32;<br></code></pre></td></tr></table></figure><br>这意味着 Kilometers 是 i32 的 同义词(synonym)；Kilometers 不是一个新的、单独的类型。 Kilometers 类型的值将被完全当作 i32 类型值来对待:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Kilometers</span></span> = <span class="hljs-built_in">i32</span>;<br><br><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> y: Kilometers = <span class="hljs-number">5</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x + y = &#123;&#125;&quot;</span>, x + y);<br></code></pre></td></tr></table></figure><br>因为 Kilometers 是 i32 的别名，他们是同一类型，可以将 i32 与 Kilometers 相加，也可以将 Kilometers 传递给获取 i32 参数的函数。但通过这种手段无法获得上一部分讨论的 newtype 模式所提供的类型检查的好处。</p>
<p>类型别名的主要用途是减少重复。例如，可能会有这样很长的类型:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;<br></code></pre></td></tr></table></figure><br>在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> f: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt; = <span class="hljs-built_in">Box</span>::new(|| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi&quot;</span>));<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_long_type</span></span>(f: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;) &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_long_type</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt; &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><br>类型别名通过减少项目中重复代码的数量来使其更加易于控制。这里我们为这个冗长的类型引入了一个叫做 Thunk 的别名，<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Thunk</span></span> = <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-keyword">let</span> f: Thunk = <span class="hljs-built_in">Box</span>::new(|| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi&quot;</span>));<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_long_type</span></span>(f: Thunk) &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_long_type</span></span>() -&gt; Thunk &#123;<br>    <span class="hljs-comment">// --snip--</span><br>    <span class="hljs-built_in">Box</span>::new(|| ())<br>&#125;<br></code></pre></td></tr></table></figure><br>这样就读写起来就容易多了!为类型别名选择一个好名字也可以帮助你表达意图(单词 thunk表示会在之后被计算的代码，所以这是一个存放闭包的合适的名字)。</p>
<p>类型别名也经常与 <code>Result&lt;T, E&gt;</code> 结合使用来减少重复。考虑一下标准库中的 std::io 模块。I/O 操作通常会返回一个 <code>Result&lt;T, E&gt;</code> ，因为这些操作可能会失败。标准库中的std::io::Error 结构体代表了所有可能的 I/O 错误。 std::io 中大部分函数会返回 <code>Result&lt;T, E&gt;</code> ，其中 E 是 std::io::Error ，比如 Write trait 中的这些函数:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::io::Error;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Write</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>, Error&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">flush</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_all</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_fmt</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, fmt: fmt::Arguments) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><br>在Result&lt;…, Error&gt;重复了很多。因此，std::io具有以下类型别名声明：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span></span>&lt;T&gt; = std::result::<span class="hljs-built_in">Result</span>&lt;T, std::io::Error&gt;;<br></code></pre></td></tr></table></figure><br>因为这位于 std::io 中，可用的完全限定的别名是 std::io::Result<T>; ;也就是说， <code>Result&lt;T, E&gt;</code> 中 E 放入了 std::io::Error 。 Write trait 中的函数最终看起来像这样:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Write</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">flush</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_all</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_fmt</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, fmt: fmt::Arguments) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><br>类型别名在两个方面有帮助:易于编写并在整个 std::io 中提供了一致的接口。因为这是一个别名，它只是另一个 <code>Result&lt;T, E&gt;</code> ，这意味着可以在其上使用 <code>Result&lt;T, E&gt;</code> 的任何方法，以及像 <code>?</code> 这样的特殊语法。</p>
<h3 id="从不返回的-，never-type"><a href="#从不返回的-，never-type" class="headerlink" title="从不返回的 ! ，never type"></a>从不返回的 ! ，never type</h3><p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <code>empty type</code>，因为它没有值。我们更倾向于称之为 <code>never type</code>。这个名字描述了它的作用:在函数从不返回的时候充当返回值。<br><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">fn</span> bar() -&gt; ! &#123;<br>    /<span class="hljs-regexp">/ --snip--</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><br>这读 “函数 bar 从不返回”，而从不返回的函数被称为 <code>发散函数(diverging functions)</code>。不能创建 <code>!</code> 类型的值，所以 bar 也不可能返回。<br>不过一个不能创建值的类型有什么用呢?曾经有一些看起来像这样的代码<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> guess: u32 = <span class="hljs-keyword">match</span> guess.trim<span class="hljs-literal">()</span>.parse<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-constructor">Ok(<span class="hljs-params">num</span>)</span> =&gt; num,<br>    <span class="hljs-constructor">Err(<span class="hljs-params">_</span>)</span> =&gt; continue,<br>&#125;;<br></code></pre></td></tr></table></figure><br>当时我们忽略了代码中的一些细节。match 的分支必须返回相同的类型。如下代码不能工作:<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">fn main<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">let</span> guess = <span class="hljs-string">&quot;3&quot;</span>;<br>    <span class="hljs-keyword">let</span> guess = <span class="hljs-keyword">match</span> guess.trim<span class="hljs-literal">()</span>.parse<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-constructor">Ok(<span class="hljs-params">_</span>)</span> =&gt; <span class="hljs-number">5</span>,<br>        <span class="hljs-constructor">Err(<span class="hljs-params">_</span>)</span> =&gt; <span class="hljs-string">&quot;hello&quot;</span>,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里的 guess 必须既是整型也是字符串，而 Rust 要求 guess 只能是一个类型。那么 continue 返回了什么呢?允许一个分支返回 u32 而另一个分支却以 continue 结束呢?<br>continue 的值是 <strong>!</strong> 。也就是说，当 Rust 要计算 guess 的类型时，它查看这两个分支。前者是 u32 值，而后者是 <strong>!</strong> 值。因为 <strong>!</strong> 并没有一个值，Rust决定guess 的类型是 u32 。</p>
<p>描述 <strong>!</strong> 的行为的正式方式是 never type 可以<code>强转为任何其他类型</code>。允许 match 的分支以 continue 结束是因为 continue 并不真正返回一个值；相反它把控制权交回上层循环，所以在 Err 的情况，事实上并未对 guess 赋值。</p>
<p>never type 的<code>另一个用途是 panic!</code> 。还记得 <code>Option&lt;T&gt;</code> 上的 unwrap 函数吗?它产生一个值或 panic。这里是它的定义:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::<span class="hljs-built_in">Option</span>::*;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">unwrap</span></span>(<span class="hljs-keyword">self</span>) -&gt; T &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>            <span class="hljs-literal">Some</span>(val) =&gt; val,<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>我们知道 val 是 <strong>T</strong> 类型， panic! 是 <strong>!</strong> 类型，所以整个 match 表达式的结果是 <strong>T</strong> 类型。这能工作是因为 <strong>panic!</strong> 并不产生一个值；它会终止程序。对于 None 的情况， unwrap 并不返回一个值，所以这些代码是有效。</p>
<p>最后一个有着 <strong>!</strong> 类型的表达式是 loop :<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">print!(<span class="hljs-string">&quot;forever &quot;</span>);<br><br>loop &#123;<br>    print!(<span class="hljs-string">&quot;and ever &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>这里，循环永远也不结束，所以此表达式的值是 <strong>!</strong> 。但是如果引入 break 这就不为真了， 因为循环在执行到 break 后就会终止。</p>
<h3 id="动态大小类型和-Sized-trait"><a href="#动态大小类型和-Sized-trait" class="headerlink" title="动态大小类型和 Sized trait"></a>动态大小类型和 Sized trait</h3><p>因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑:这就是 <code>动态大小类型(dynamically sized types)</code>的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。<br>让我们深入研究一个贯穿本书都在使用的动态大小类型的细节: <strong>str</strong> 。没错，不是 <strong>&amp;str</strong> ， <code>而是 str 本身</code>。 <code>str 是一个 DST</code>；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着不能创建 str 类型的变量，也不能获取 str 类型的参数。考虑一下这些代码，他们不能工作:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">let</span> <span class="hljs-built_in">s1</span>: <span class="hljs-keyword">str</span> = <span class="hljs-string">&quot;Hello there!&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">let</span> <span class="hljs-built_in">s2</span>: <span class="hljs-keyword">str</span> = <span class="hljs-string">&quot;How&#x27;s it going?&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></p>
<p>Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间， 不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。</p>
<p>虽然 <strong>&amp;T</strong> 是一个储存了 <strong>T</strong> 所在的内存位置的单个值， <strong>&amp;str</strong> 则是两个值: <strong>str 的地址</strong>和<strong>其长度</strong>。这样， <strong>&amp;str</strong> 就有了一个在编译时可以知道的大小:<code>它是 usize 长度的两倍</code>。 也就是说，我们总是知道 <strong>&amp;str</strong> 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法:<code>他们有一些额外的元信息来储存动态信息的大小。</code>这引出了动态大小类型的黄金规则:<code>必须将动态大小类型的值置于某种指针之后。</code></p>
<p>可以将 str 与所有类型的指针结合:比如 <code>Box&lt;str&gt; 或 Rc&lt;str&gt;</code> 。事实上，之前我们已经见过了，不过是另一个动态大小类型:<strong>trait</strong>。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。<code>我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 &amp;Trait 或Box&lt;Trait&gt; ( Rc&lt;Trait&gt; 也可以)</code>。trait 之所以是动态大小类型的是因为只有这样才能使用它。</p>
<h3 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h3><p>为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知:这就是 <code>Sized trait</code>。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，<code>Rust 隐式的为每一个泛型函数增加了 Sized bound</code>。也就是说，对于如下泛型函数定义:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">fn <span class="hljs-title">generic</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">t: T</span>)</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><br>实际上被当作如下处理:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">fn <span class="hljs-title">generic</span>&lt;<span class="hljs-title">T</span>: <span class="hljs-title">Sized</span>&gt;(<span class="hljs-params">t: T</span>)</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><br>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">fn <span class="hljs-title">generic</span>&lt;<span class="hljs-title">T</span>: ?<span class="hljs-title">Sized</span>&gt;(<span class="hljs-params">t: &amp;T</span>)</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><br><code>?Sized trait bound</code> 与 Sized 相对;也就是说，它可以读作 <code>“ T 可能是也可能不是 Sized 的”。这个语法只能用于 Sized ，而不能用于其他 trait。</code></p>
<p>另外注意我们将 t 参数的类型从 <strong>T</strong> 变为了 <strong>&amp;T</strong> :因为其类型可能不是 <strong>Sized</strong> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p>
<h2 id="四、高级函数与闭包"><a href="#四、高级函数与闭包" class="headerlink" title="四、高级函数与闭包"></a>四、高级函数与闭包</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>我们讨论过了如何向函数传递闭包；也可以向函数传递常规函数!这在我们希望传递已经定义的函数而不是重新定义闭包作为参数是很有用。通过函数指针允许我们使用函数作为另一个函数的参数。函数的类型是 <strong>fn</strong> ，<code>使用小写的 “f” 以便不与 Fn 闭包 trait 向混淆。</code> fn 被称为<strong>函数指针(function pointer)</strong>。指定参数为函数指针的<code>语法类似于闭包</code><br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_one</span></span>(x: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_twice</span></span>(f: <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span>, arg: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    f(arg) + f(arg)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> answer = do_twice(add_one, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The answer is: &#123;&#125;&quot;</span>, answer);<br>&#125;<br></code></pre></td></tr></table></figure><br>这会打印出 <code>The answer is: 12</code> 。 do_twice 中的 f 被指定为一个接受一个 i32 参数并返 回 i32 的 fn 。接着就可以在 do_twice 函数体中调用 f 。在 main 中，可以将函数名add_one 作为第一个参数传递给 do_twice 。</p>
<p>不同于闭包， <strong>fn 是一个类型而不是一个 trait</strong>，所以直接指定 fn 作为参数而不是声明一个带有 Fn 作为 trait bound 的泛型参数。</p>
<p><code>函数指针实现了所有三个闭包 trait( Fn 、 FnMut 和 FnOnce )</code>，所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 trait 的函数，这样它就能接受函数或闭包作为参数。</p>
<p>一个只期望接受 fn 而不接受闭包的情况的例子是与不存在闭包的外部代码交互时:C 语言的函数可以接受函数作为参数，但没有闭包。</p>
<p>作为一个既可以使用内联定义的闭包又可以使用命名函数的例子，让我们看看一个 map 的应用。使用 map 函数将一个数字 vector 转换为一个字符串 vector，就可以使用闭包:<br><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> list_of_numbers = <span class="hljs-built_in">vec</span>![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> list_of_strings: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-keyword">String</span>&gt; =<br>    list_of_numbers.iter().<span class="hljs-built_in">map</span>(|i| i.<span class="hljs-built_in">to_string</span>()).<span class="hljs-built_in">collect</span>();<br></code></pre></td></tr></table></figure><br>或者可以将函数作为 map 的参数来代替闭包:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> list_of_numbers = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> list_of_strings: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; =<br>    list_of_numbers.iter().map(<span class="hljs-built_in">ToString</span>::to_string).collect();<br></code></pre></td></tr></table></figure><br>注意这里必须使用 “高级 trait” 部分讲到的完全限定语法，因为存在多个叫做 to_string 的函数;这里使用了定义于 ToString trait 的 to_string 函数，标准库为所有实现了 Display 的类型实现了这个 trait。</p>
<p>一些人倾向于函数风格，一些人喜欢闭包。他们最终都会产生同样的代码，所以请使用对你来说更明白的吧。</p>
<p>另一个实用的模式暴露了<strong>元组结构体</strong>和<strong>元组结构体枚举</strong>成员的实现细节。这些项使用 <strong>()</strong> 作为初始化语法，这看起来就像函数调用，同时它们确实被实现为返回由参数构造的实例的函数。<code>它们也被称为实现了闭包 trait 的函数指针</code>，并可以采用类似如下的方式调用：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">Status</span> &#123;<br>    <span class="hljs-keyword">Value</span>(u32),<br>    <span class="hljs-keyword">Stop</span>,<br>&#125;<br><br>let list_of_statuses: Vec&lt;<span class="hljs-keyword">Status</span>&gt; = (<span class="hljs-number">0</span>u32.<span class="hljs-number">.20</span>).map(<span class="hljs-keyword">Status</span>::<span class="hljs-keyword">Value</span>).collect();<br></code></pre></td></tr></table></figure><br>在这里，我们Status::Value使用u32范围内的每个值创建实例，这些值map是通过使用的初始化函数调用的<code>Status::Value</code>。</p>
<h3 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h3><p>闭包表现为 trait，这意味着不能直接返回闭包。对于大部分需要返回 trait 的情况，可以使用是实现了期望返回的 trait 的具体类型替代函数的返回值。但是这不能用于闭包，因为他们没有一个可返回的具体类型；例如不允许使用函数指针 fn 作为返回值类型。<br>这段代码尝试直接返回闭包，它并不能编译:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_closure</span></span>() -&gt; <span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    |x| x + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><br>编译器给出的错误是:<br><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">$ cargo build<br>   Compiling functions-example v0.1.0 (<span class="hljs-keyword">file</span>:<span class="hljs-comment">///projects/functions-example)</span><br><span class="hljs-keyword">error</span>[E0746]: <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> cannot have <span class="hljs-keyword">an</span> unboxed trait object<br> --&gt; src/lib.rs:1:25<br>  |<br>1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 &#123;<br>  |                         ^^^^^^^^^^^^^^^^^^ doesn&#x27;t have a size known at compile-time<br>  |<br>  = <span class="hljs-keyword">note</span>: <span class="hljs-keyword">for</span> information <span class="hljs-keyword">on</span> `impl Trait`, see &lt;https:<span class="hljs-comment">//doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;</span><br><span class="hljs-keyword">help</span>: <span class="hljs-keyword">use</span> `impl Fn(i32) -&gt; i32` <span class="hljs-keyword">as</span> the <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>, <span class="hljs-keyword">as</span> all <span class="hljs-keyword">return</span> paths are of <span class="hljs-keyword">type</span> `[closure@src/lib.rs:2:5: 2:14]`, <span class="hljs-keyword">which</span> implements `Fn(i32) -&gt; i32`<br>  |<br>1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 &#123;<br>  |                         ^^^^^^^^^^^^^^^^^^^<br><br><span class="hljs-keyword">For</span> <span class="hljs-keyword">more</span> information <span class="hljs-keyword">about</span> this <span class="hljs-keyword">error</span>, try `rustc --explain E0746`.<br><span class="hljs-keyword">error</span>: could not compile `functions-example` due to previous <span class="hljs-keyword">error</span><br></code></pre></td></tr></table></figure><br>误有一次指向了 <code>Sized trait</code>!Rust 并不知道需要多少空间来储存闭包。不过我们在上一部分见过这种情况的解决办法:可以使用 trait 对象:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_closure</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span>&gt; &#123;<br>    <span class="hljs-built_in">Box</span>::new(|x| x + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br>这段代码正好可以编译。</p>
<h2 id="五、宏"><a href="#五、宏" class="headerlink" title="五、宏"></a>五、宏</h2><p>我们在println!整本书中都使用了宏，但我们还没有完全探索宏是什么以及它是如何工作的。<br><code>宏（Macro）</code>指的是 Rust 中一系列的功能：使用 <strong>macro_rules!</strong> 的 声明（Declarative）宏，和<strong>三种 过程（Procedural）宏</strong>：</p>
<ul>
<li>自定义 <strong>#[derive]</strong> 宏在<strong>结构体</strong>和<strong>枚举</strong>上指定通过 derive 属性添加的代码</li>
<li><strong>类属性（Attribute-like）宏</strong>定义可用于<strong>任意项的自定义属性</strong></li>
<li><strong>类函数宏</strong>看起来像函数不过作用于<strong>作为参数传递的 token</strong></li>
</ul>
<h3 id="宏和函数的区别"><a href="#宏和函数的区别" class="headerlink" title="宏和函数的区别"></a>宏和函数的区别</h3><p>从根本上说，宏是一种编写其他代码而写代码的方式，这被称为<strong>元编程（metaprogramming）</strong>。在探讨 <strong>derive</strong> 属性，其<strong>生成各种 trait 的实现</strong>。我们也使用过 <strong>println!</strong> 宏和 <strong>vec!</strong> 宏。所有的这些宏以<strong>展开</strong>的方式来生成比你所手写出的更多的代码。</p>
<p>元编程对于减少您必须编写和维护的代码量很有用，这也是函数的作用之一。但是，宏具有函数所没有的一些附加功能。</p>
<p>一个函数标签必须声明函数参数个数和类型。相比之下，宏能够接受不同数量的参数：用一个参数调用 <strong>println!(“hello”)</strong> 或用两个参数调用 <strong>println!(“hello {}”, name)</strong> 。而且，宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现。</p>
<p>实现一个宏而不是一个函数的缺点是<strong>宏定义要比函数定义更复杂</strong>，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。</p>
<p>宏和函数的最后一个重要的区别是：<code>在一个文件里调用宏之前必须定义它，或将其引入作用域</code>，而函数则可以在任何地方定义和调用。</p>
<h3 id="macro-rules-用于通用元编程的声明性宏"><a href="#macro-rules-用于通用元编程的声明性宏" class="headerlink" title="macro_rules!用于通用元编程的声明性宏"></a>macro_rules!用于通用元编程的声明性宏</h3><p>Rust 最常用的宏形式是 <strong>声明宏（declarative macros）</strong>。它们有时也被称为 “macros by example”、“macro_rules! 宏” 或者就是 “macros”。其核心概念是，<code>声明宏允许我们编写一些类似 Rust match 表达式的代码。</code>match 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。宏也将一个值和包含相关代码的模式进行比较；此种情况下，该值是传递给宏的 Rust 源代码字面值，模式用于和传递给宏的源代码进行比较，同时每个模式的相关代码则用于替换传递给宏的代码。<strong>所有这一切都发生于编译时。</strong></p>
<p>要定义宏，请使用<code>macro_rules!</code>构造。通过查看vec!宏是如何定义的来探索如何使用。<br><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> v: Vec&lt;u<span class="hljs-number">32</span>&gt; = vec![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><br>我们还可以使用<strong>vec!</strong>宏来创建一个包含两个整数的向量或一个包含五个字符串切片的向量。我们将无法使用函数来做同样的事情，因为我们不会预先知道值的数量或类型。</p>
<p>下面显示了一个稍微简化的vec!宏定义。<br><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment">#[macro_export]</span><br>macro_rules! vec &#123;<br>    ( <span class="hljs-variable">$(</span> <span class="hljs-variable">$x</span><span class="hljs-symbol">:expr</span> ),* ) =&gt; &#123;<br>        &#123;<br>            let mut temp_vec = Vec::new();<br>            <span class="hljs-variable">$(</span><br>                temp_vec.push(<span class="hljs-variable">$x</span>);<br>            )*<br>            temp_vec<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：vec!标准库中宏的实际定义包括预先分配正确内存量的代码。该代码是一种优化，为了使示例更简单，我们未在此处包含该代码。</p>
</blockquote>
<p>无论何时导入定义了宏的包，<code>#[macro_export] 注解说明宏应该是可用的。 如果没有该注解，这个宏不能被引入作用域。</code></p>
<p>接着使用 <strong>macro_rules!</strong> 和<strong>宏名称</strong>开始宏定义，且<strong>所定义的宏并不带感叹号</strong>。<strong>名字后跟大括号表示宏定义体</strong>，在该例中宏名称是 <strong>vec</strong> 。</p>
<p><strong>vec! 宏</strong>的结构和 <strong>match 表达式</strong>的结构类似。此处有一个<strong>单边模式 ( $( $x:expr ),* )</strong> ，后跟 <strong>=&gt;</strong> 以及和<strong>模式相关的代码块</strong>。如果模式匹配，该相关代码块将被执行。<strong>假设这是这个宏中唯一的模式，则只有这一种有效匹配</strong>，其他任何匹配都是错误的。<strong>更复杂的宏会有多个单边模式。</strong></p>
<p>宏定义中有效模式语法和模式语法是不同的，因为宏模式所匹配的是 Rust 代码结构而不是值。对于全部的宏模式语法，请查阅[参考]<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/macros-by-example.html">https://doc.rust-lang.org/reference/macros-by-example.html</a>。</p>
<p>首先，<strong>一对括号包含了整个模式</strong>。接下来是<strong>美元符号（ $ ）</strong>，后跟<strong>一对括号</strong>，<code>捕获了符合括号内模式的值以用于替换后的代码</code>。$() 内则是 <code>$x:expr</code> ，<strong>其匹配 Rust 的任意表达式</strong>，并将<strong>该表达式记作 $x</strong>。</p>
<p><strong>$()</strong> 之后的<strong>逗号说明一个可有可无的逗号分隔符可以出现在 $() 所匹配的代码之后</strong>。紧随逗号之后的 <code>* 说明该模式匹配零个或更多个 * 之前的任何模式。</code></p>
<p>当以 <strong>vec![1, 2, 3];</strong> 调用宏时，<strong>$x 模式</strong>与三个表达式 1、2 和 3 进行了<strong>三次匹配</strong>。</p>
<p>现在让我们来看看与此单边模式相关联的代码块中的模式：<code>对于每个（在 =&gt; 前面）匹配模式中的 $() 的部分，生成零个或更多个（在 =&gt; 后面）位于 $()* 内的 temp_vec.push() ，生成的个数取决于该模式被匹配的次数。$x 由每个与之相匹配的表达式所替换。</code>当以 <strong>vec![1, 2, 3];</strong> 调用该宏时，替换该宏调用所生成的代码会是下面这样：<br><figure class="highlight clojure"><table><tr><td class="code"><pre><code class="hljs clojure">&#123;<br>    let mut temp_vec = Vec::new()<span class="hljs-comment">;</span><br>    temp_vec.push(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>    temp_vec.push(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>    temp_vec.push(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>    temp_vec<br>&#125;<br></code></pre></td></tr></table></figure><br>我们已经定义了一个宏，它可以接受任意数量的任意类型的参数，并且可以生成代码来创建一个包含指定元素的向量。</p>
<p>将来，Rust 将有<strong>第二种声明性宏，它会以类似的方式工作，但会修复其中的一些边缘情况</strong>。在那次更新之后，<strong>macro_rules!</strong>将被有效地弃用。<code>考虑到这一点，以及大多数 Rust 程序员更多地使用宏而不是编写宏的事实，不会macro_rules!进一步讨论 [链接]&lt;https://veykril.github.io/tlborm/&gt;。</code></p>
<h3 id="用于从属性生成代码的过程宏"><a href="#用于从属性生成代码的过程宏" class="headerlink" title="用于从属性生成代码的过程宏"></a>用于从属性生成代码的过程宏</h3><p>宏的第二种形式是<strong>过程宏</strong>，它的作用更像<strong>函数（并且是一种过程）</strong>。过程宏接受一些代码作为输入，对该代码进行操作，并产生一些代码作为输出，而不是像声明性宏那样匹配模式并用其他代码替换代码。</p>
<p><code>有三种过程宏（自定义派生derive、类属性和类函数）都以类似的方式工作。</code></p>
<p>创建过程宏时，定义必须驻留在它们自己的具有特殊 crate 类型的 crate 中。这是出于复杂的技术原因，我们希望在未来消除。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// some_attribute 是一个使用特定宏的占位符。</span><br><span class="hljs-keyword">use</span> proc_macro;<br><br><span class="hljs-meta">#[some_attribute]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_name</span></span>(input: TokenStream) -&gt; TokenStream &#123;<br>&#125;<br></code></pre></td></tr></table></figure><br>定义过程宏的函数以 TokenStream 作为输入并生成 TokenStream 作为输出。 TokenStream 类型由包含在 Rust 中的 proc_macro crate 定义并表示令牌序列。 这是宏的核心：<code>宏所操作的源代码构成了输入 TokenStream，宏产生的代码是输出 TokenStream。</code>该函数还附加了一个属性，用于指定我们正在创建的程序宏类型。 我们可以在同一个 crate 中拥有多种程序宏。</p>
<p>让我们看看不同种类的程序宏。我们将从自定义派生宏开始，然后解释使其他形式不同的微小差异。</p>
<h3 id="如何编写自定义derive宏"><a href="#如何编写自定义derive宏" class="headerlink" title="如何编写自定义derive宏"></a>如何编写自定义derive宏</h3><p>让我们创建一个 hello_macro crate，其包含名为 HelloMacro 的 trait 和关联函数 hello_macro。不同于让 crate 的用户为其每一个类型实现 HelloMacro trait，我们将会提供一个过程式宏以便用户可以使用 <code>#[derive(HelloMacro)]</code> 注解他们的类型来得到 hello_macro 函数的默认实现。该默认实现会打印 <code>Hello, Macro! My name is TypeName!</code>，其中 TypeName 为定义了 trait 的类型名。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> hello_macro::HelloMacro;<br><span class="hljs-keyword">use</span> hello_macro_derive::HelloMacro;<br><br><span class="hljs-meta">#[derive(HelloMacro)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pancakes</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    Pancakes::hello_macro();<br>&#125;<br></code></pre></td></tr></table></figure><br>第一步是制作一个新的 library crate，如下所示：<br><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ cargo <span class="hljs-keyword">new</span> hello_macro <span class="hljs-comment">--lib</span><br></code></pre></td></tr></table></figure><br>接下来，我们将定义HelloMacrotrait 及其相关函数：<br>src/lib.rs<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">pub <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">HelloMacro</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hello_macro</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>我们有一个特征及其功能。此时，我们的 crate 用户可以实现 trait 来实现所需的功能，如下所示：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> hello_macro::HelloMacro;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pancakes</span></span>;<br><br><span class="hljs-keyword">impl</span> HelloMacro <span class="hljs-keyword">for</span> Pancakes &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hello_macro</span></span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, Macro! My name is Pancakes!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    Pancakes::hello_macro();<br>&#125;<br></code></pre></td></tr></table></figure><br>但是，他们需要为他们想要使用的每种类型编写实现块hello_macro；我们想让他们不必做这项工作。</p>
<p>此外，我们还不能提供hello_macro带有默认实现的函数，该函数将打印实现 trait 的类型的名称：Rust 没有反射功能，因此它无法在运行时查找类型的名称。我们需要一个宏来在编译时生成代码。</p>
<p>下一步是定义程序宏。</p>
<p>我们的hello_macro项目中创建一个名为的新 crate ：<br><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ cargo <span class="hljs-keyword">new</span> hello_macro_derive <span class="hljs-comment">--lib</span><br></code></pre></td></tr></table></figure><br>我们的两个 crate 紧密相关，因此我们在 crate 的目录中创建了程序宏hello_macrocrate。如果我们更改中的特征定义hello_macro，我们也必须更改中过程宏的实现hello_macro_derive。这两个 crate 需要单独发布，使用这些 crate 的程序员需要将它们添加为依赖项并将它们都引入范围。</p>
<p>我们需要将hello_macro_derive crate<code>声明为程序宏(proc-macro) crate</code>。我们还需要来自<code>syn</code>和<code>quotecrate</code> 的功能，我们需要将它们添加为依赖项。将以下内容添加到 <strong>Cargo.toml</strong> 文件中hello_macro_derive：<br>hello_macro_derive/Cargo.toml<br><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">proc-macro</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">syn</span> = <span class="hljs-string">&quot;1.0&quot;</span><br><span class="hljs-attr">quote</span> = <span class="hljs-string">&quot;1.0&quot;</span><br></code></pre></td></tr></table></figure><br>要开始定义程序宏，请注意，在我们为impl_hello_macro函数添加定义之前，此代码不会编译。<br>hello_macro_derive/src/lib.rs<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro;<br><br><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> syn;<br><br><span class="hljs-meta">#[proc_macro_derive(HelloMacro)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hello_macro_derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;<br>    <span class="hljs-comment">// Construct a representation of Rust code as a syntax tree</span><br>    <span class="hljs-comment">// that we can manipulate</span><br>    <span class="hljs-keyword">let</span> ast = syn::parse(input).unwrap();<br><br>    <span class="hljs-comment">// Build the trait implementation</span><br>    impl_hello_macro(&amp;ast)<br>&#125;<br></code></pre></td></tr></table></figure><br>注意 <strong>hello_macro_derive</strong> 函数中<strong>代码分割的方式</strong>，它负责<strong>解析 TokenStream</strong>，而 <strong>impl_hello_macro 函数则负责转换语法树</strong>：<code>这让编写一个过程式宏更加方便。</code>外部函数中的代码（在这里是 hello_macro_derive）几乎在所有你能看到或创建的过程宏 crate 中都一样。内部函数（在这里是 impl_hello_macro）的函数体中所指定的代码则依过程宏的目的而各有不同。</p>
<p>现在，我们已经引入了三个新的 crate：<code>proc_macro</code> 、 <code>syn</code> 和 <code>quote</code> 。Rust 自带 <strong>proc_macro crate</strong>，因此无需将其加到 Cargo.toml 文件的依赖中。proc_macro crate 是<strong>编译器用来读取和操作我们 Rust 代码的 API</strong>。</p>
<p><strong>syn crate 将字符串中的 Rust 代码解析成为一个可以操作的数据结构。quote 则将 syn 解析的数据结构转换回 Rust 代码。</strong>这些 crate 让解析任何我们所要处理的 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作。</p>
<p>当用户在一个类型上指定 <strong>#[derive(HelloMacro)]</strong> 时，hello_macro_derive 函数将会被调用。原因在于我们已经使用 <strong>proc_macro_derive</strong> 及其指定名称对 <strong>hello_macro_derive</strong> 函数进行了注解：<strong>HelloMacro</strong> ，其匹配到 trait 名，这是大多数过程宏遵循的习惯。</p>
<p>该函数首先将来自 TokenStream 的 input 转换为一个我们可以解释和操作的数据结构。这正是 syn 派上用场的地方。<strong>syn 中的 parse_derive_input 函数</strong>获取一个 TokenStream 并返回一个表示解析出 Rust 代码的 DeriveInput 结构体。从字符串 struct Pancakes; 中解析出来的 DeriveInput 结构体的相关部分：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-class">DeriveInput </span>&#123;<br>    <span class="hljs-comment">// --snip--</span><br><br><span class="hljs-symbol">    ident:</span> <span class="hljs-class">Ident </span>&#123;<br><span class="hljs-symbol">        ident:</span> <span class="hljs-string">&quot;Pancakes&quot;</span>,<br><span class="hljs-symbol">        span:</span> <span class="hljs-meta">#0 bytes(95..103)</span><br>    &#125;,<br><span class="hljs-symbol">    data:</span> Struct(<br>        <span class="hljs-class">DataStruct </span>&#123;<br><span class="hljs-symbol">            struct_token:</span> Struct,<br><span class="hljs-symbol">            fields:</span> Unit,<br><span class="hljs-symbol">            semi_token:</span> Some(<br>                Semi<br>            )<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><br>该结构体的字段展示了我们<strong>解析的 Rust 代码是一个类单元结构体</strong>，其 ident（ identifier，表示名字）为 Pancakes。</p>
<p>此时，<strong>尚未定义 impl_hello_macro 函数</strong>，其用于构建所要包含在内的 Rust 新代码。但在此之前，注意其<strong>输出也是 TokenStream</strong>。所返回的 TokenStream 会被加到我们的 crate 用户所写的代码中，因此，当用户编译他们的 crate 时，他们会获取到我们所提供的额外功能。</p>
<p>你可能也注意到了，当调用 syn::parse 函数失败时，我们用 unwrap 来使 hello_macro_derive 函数 panic。在错误时 panic 对过程宏来说是必须的，因为 <strong>proc_macro_derive</strong> 函数必须返回 <strong>TokenStream</strong> 而不是 <strong>Result</strong>，以此来符合过程宏的 API。这里选择用 unwrap 来简化了这个例子；在生产代码中，则应该通过 panic! 或 expect 来提供关于发生何种错误的更加明确的错误信息。</p>
<p>现在我们有了将注解的 Rust 代码从 TokenStream 转换为 DeriveInput 实例的代码，让我们来创建在注解类型上实现 HelloMacro trait 的代码。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">impl_hello_macro</span></span>(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;<br>    <span class="hljs-keyword">let</span> name = &amp;ast.ident;<br>    <span class="hljs-keyword">let</span> gen = quote! &#123;<br>        <span class="hljs-keyword">impl</span> HelloMacro <span class="hljs-keyword">for</span> #name &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hello_macro</span></span>() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, Macro! My name is &#123;&#125;!&quot;</span>, <span class="hljs-built_in">stringify!</span>(#name));<br>            &#125;<br>        &#125;<br>    &#125;;<br>    gen.into()<br>&#125;<br></code></pre></td></tr></table></figure><br>我们得到一个包含以 <strong>ast.ident</strong> 作为注解类型名字（标识符）的 Ident 结构体实例。结构体表明当 impl_hello_macro 函数运行于 ident 字段的值是 “Pancakes”。因此，name 变量会包含一个 Ident 结构体的实例，当打印时，会是字符串 “Pancakes”，也就是结构体的名称。</p>
<p><strong>quote! 宏</strong>让我们可以编写希望返回的 Rust 代码。<strong>quote! 宏</strong>执行的直接结果并不是编译器所期望的并需要转换为 <strong>TokenStream</strong>。为此需要<strong>调用 into 方法</strong>，它会消费这个中间表示（intermediate representation，IR）并<strong>返回所需的 TokenStream 类型值</strong>。这个宏也提供了一些非常酷的模板机制；我们可以写 <strong>#name</strong> ，然后 <strong>quote!</strong> 会以名为 name 的变量值来替换它。你甚至可以做一些类似常用宏那样的重复代码的工作。</p>
<p>我们期望我们的过程式宏能够为通过 <strong>#name</strong> 获取到的用户注解类型生成 <strong>HelloMacro trait 的实现</strong>。该 trait 的实现有一个函数 hello_macro ，其函数体包括了我们期望提供的功能：打印 <strong>Hello, Macro! My name is 和注解的类型名</strong>。</p>
<p>此处所使用的 <strong>stringify!</strong> 为 Rust 内置宏。其接收一个 Rust 表达式，如 1 + 2 ， 然后<code>在编译时将表达式转换为一个字符串常量</code>，如 “1 + 2” 。这与 <strong>format!</strong> 或 <strong>println!</strong> 是不同的，它计算表达式并将结果转换为 <strong>String</strong> 。有一种可能的情况是，所输入的 <strong>#name</strong> 可能是一个需要打印的表达式，因此我们用 <strong>stringify!</strong> 。 <strong>stringify!</strong> 编译时也保留了一份将 <strong>#name</strong> 转换为字符串之后的内存分配。</p>
<p>此时，cargo build 应该都能成功编译 hello_macro 和 hello_macro_derive 。我们将这些 crate 连接到代码中来看看过程宏的行为！在 projects 目录下用 cargo new pancakes 命令新建一个二进制项目。需要将 hello_macro 和 hello_macro_derive 作为依赖加到 pancakes 包的 Cargo.toml 文件中去。如果你正将 hello_macro 和 hello_macro_derive 的版本发布到 crates.io 上，其应为常规依赖；如果不是，则可以像下面这样将其指定为 path 依赖：<br><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hello_macro</span> = &#123; path = <span class="hljs-string">&quot;../hello_macro&quot;</span> &#125;<br><span class="hljs-attr">hello_macro_derive</span> = &#123; path = <span class="hljs-string">&quot;../hello_macro/hello_macro_derive&quot;</span> &#125;<br></code></pre></td></tr></table></figure><br>然后执行 cargo run：其应该打印 Hello, Macro! My name is Pancakes!。其包含了该过程宏中 HelloMacro trait 的实现，而无需 pancakes crate 实现它；<strong>#[derive(HelloMacro)]</strong> 增加了该 trait 实现。</p>
<h3 id="类属性宏"><a href="#类属性宏" class="headerlink" title="类属性宏"></a>类属性宏</h3><p>类属性宏与自定义派生宏相似，不同于为 <strong>derive 属性生成代码</strong>，它们允许你<strong>创建新的属性</strong>。它们也更为灵活；<code>derive 只能用于结构体和枚举；属性还可以用于其它的项，比如函数。</code>作为一个使用类属性宏的例子，可以创建一个名为 route 的属性用于注解 web 应用程序框架（web application framework）的函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">#[route(GET, <span class="hljs-string">&quot;/&quot;</span>)]<br>fn <span class="hljs-function"><span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span> &#123;<br></code></pre></td></tr></table></figure><br><code>#[route] 属性</code>将由框架本身定义为一个<strong>过程宏</strong>。其宏定义的函数签名看起来像这样：<br><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">#<span class="hljs-selector-attr">[proc_macro_attribute]</span><br><span class="hljs-selector-tag">pub</span> <span class="hljs-selector-tag">fn</span> <span class="hljs-selector-tag">route</span>(<span class="hljs-attribute">attr</span>: TokenStream, <span class="hljs-attribute">item</span>: TokenStream) <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">TokenStream</span> &#123;<br></code></pre></td></tr></table></figure><br>这里有两个 <strong>TokenStream</strong> 类型的参数；第一个用于属性内容本身，也就是 <code>GET, &quot;/&quot; 部分</code>。第二个是属性<strong>所标记的项</strong>：<code>在本例中，是 fn index() &#123;&#125; 和剩下的函数体。</code></p>
<p>除此之外，<code>类属性宏与自定义派生宏工作方式一致：创建 proc-macro crate 类型的 crate 并实现希望生成代码的函数！</code></p>
<h3 id="类函数宏"><a href="#类函数宏" class="headerlink" title="类函数宏"></a>类函数宏</h3><p>类函数宏定义看起来像函数调用的宏。类似于 <strong>macro_rules!</strong>，它们比函数更灵活；例如，可以接受未知数量的参数。然而 <strong>macro_rules!</strong> 宏只能使用之前 “使用 macro_rules! 的声明宏用于通用元编程” 介绍的类匹配的语法定义。类函数宏获取 <strong>TokenStream</strong> 参数，其定义使用 Rust 代码操纵 TokenStream，<code>就像另两种过程宏一样。一个类函数宏例子是可以像这样被调用的 sql! 宏</code>：<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">let <span class="hljs-keyword">sql</span> = <span class="hljs-keyword">sql</span>!(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> posts <span class="hljs-keyword">WHERE</span> id=<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><br>这个宏会解析其中的 SQL 语句并检查其是否是句法正确的，这是比 macro_rules! 可以做到的更为复杂的处理。sql! 宏应该被定义为如此：<br><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#[proc_macro]</span><br>pub fn sql<span class="hljs-function"><span class="hljs-params">(input: TokenStream)</span> -&gt;</span> TokenStream &#123;<br></code></pre></td></tr></table></figure><br>这类似于自定义派生宏的签名：获取括号中的 token，并返回希望生成的代码。</p>

      
       
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '07584e1e38d09c739a16',
            clientSecret: '6a466750b46c76ed9cc8ee0fe0d78e0c33898937',
            repo: 'yangandmore.github.io',
            owner: 'Yangandmore',
            admin: ['Yangandmore'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yangandmore
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
