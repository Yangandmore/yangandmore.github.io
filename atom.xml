<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小杨的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-20T05:33:52.796Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-目录</title>
    <link href="http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/"/>
    <id>http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/</id>
    <published>2023-02-18T15:04:05.000Z</published>
    <updated>2023-02-20T05:33:52.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我在看<strong>小鹏哥</strong>写的<strong>设计模式</strong>中一句话让我很有感触：<br><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">讲道理没有ifelse解决不了的逻辑，不⾏就在加⼀⾏!<br></code></pre></td></tr></table></figure><br>这个现象太真实了。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>模式在构造复杂系统时的重要性早已在其他领域中被认可。软件领域中的设计模式为开发人员提供了一种 使用专家设计经验的有效途径。在使用设计模式前，最好需要熟悉“类型”和“多态”，或“接口”继承与“实现”继承的关系。</p><p>设计模式捕获了随时间进化与发展 的问题的求解方法，因此它们并不是人们从一开始就采用的设计方案。它们反映了不为人知的 重新设计和重新编码的成果，而这些都来自软件开发者为了设计出灵活可复用的软件而长时间 进行的艰苦努力。设计模式捕获了这些解决方案，并用简洁易用的方式表达出来。</p><h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><h3 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2. 里氏代换原则"></a>2. 里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3. 依赖倒转原则"></a>3. 依赖倒转原则</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5-迪米特法则，又称最少知道原则"><a href="#5-迪米特法则，又称最少知道原则" class="headerlink" title="5. 迪米特法则，又称最少知道原则"></a>5. 迪米特法则，又称最少知道原则</h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6. 合成复用原则"></a>6. 合成复用原则</h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="23个设计模式"><a href="#23个设计模式" class="headerlink" title="23个设计模式"></a>23个设计模式</h1><p>下面介绍了各个模式的类型及大致范围</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">创建型</th><th style="text-align:center">结构型</th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center">范围</td><td style="text-align:center">类</td><td style="text-align:center">工厂函数</td><td style="text-align:center">适配器(类)</td><td style="text-align:center">模版方法、解释器</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">对象</td><td style="text-align:center">抽象工厂、构建者、原型模式、单例模式</td><td style="text-align:center">适配器(对象)、桥接模式、组成模式、装饰者、外观模式、享元模式、代理模式</td><td style="text-align:center">责任链、命令模式、迭代器、中介者、备忘录、观察者、状态模式、策略模式、访问者</td></tr></tbody></table></div><p>大致分类的方式：</p><ol><li>完成什么工作：创建型模式与对象的创建有关;结构型模式处理类或对象的组合;行为型 模式对类或对象怎样交互和怎样分配职责进行描述。</li><li>用于类还是用于对象：类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了；对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。</li></ol><p>下图中也描述了这些模式之间的关系<br><img src="/img/DesignPatterns/00.png" alt="github"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/">抽象工厂</a><br><a href="https://yangandmore.github.io/2023/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/">静态工厂</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/">构建者</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/">原型模式</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5/">单例模式</a></p><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">适配器(对象)</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/">桥接模式</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/">组成模式</a><br><a href="https://yangandmore.github.io/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/">装饰者</a><br><a href="https://yangandmore.github.io/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/">外观模式</a><br><a href="https://yangandmore.github.io/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">享元模式</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/">代理模式</a></p><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/">责任链</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/">命令模式</a><br><a href="https://yangandmore.github.io/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/">迭代器</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/">中介者</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/">备忘录</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/">观察者</a><br><a href="https://yangandmore.github.io/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/">状态模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/">策略模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/">访问者</a></p>]]></content>
    
    
    <summary type="html">设计模式-目录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-02-17T08:10:10.353Z</updated>
    
    <content type="html"><![CDATA[<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><p>提供一个接口来完成计算方式。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来，就创建需要对比的类型，并创建对应的对比起就可以了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">Number</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Number n1, Number n2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n1.a &gt; n2.a &amp;&amp; n1.b &gt; b2.b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后并使用这个对比工具即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Number n1 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        Number n2 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        <br>        Comparator com = <span class="hljs-keyword">new</span> NumberComparator();<br>        <span class="hljs-keyword">int</span> res = com.compara(n1, n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>如果需要修改算法，我们只需要增加对比器的实现即可。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一<br>个类的方法。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的<br>算法。当这些变体实现为一个算法的类层次时 [ H O 8 7 ] ,可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数<br>据结构。</li><li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。<br>将相关的条件分支移入它们各自的 S t r a t e g y 类中以代替这些条件语句。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/21.png" alt="github"></p>]]></content>
    
    
    <summary type="html">策略模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模版模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-02-17T08:51:19.946Z</updated>
    
    <content type="html"><![CDATA[<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>准备算法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>        water();<br>        eat();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>final表示无法重写，因此该方法只能使用，无法覆盖，该顺序已经被固定成一个模板。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowerTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>控制子类扩展。模板方法只在特定点调用“许在这些点进行扩展。hook”操作， 这样就只允许在这些点进行扩展。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/22.png" alt="github"></p>]]></content>
    
    
    <summary type="html">模版模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-02-18T07:01:06.478Z</updated>
    
    <content type="html"><![CDATA[<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>专家在评审项目时，不同专家针对不同项目进行评审</p><p>首先项目部分<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Project</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>创建两个项目类型<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> FoodProject extends Project&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> safe;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FoodProject</span><span class="hljs-params">(String name, String safe)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.safe = safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToolProject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> quality;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToolProject</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> quality)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.quality = quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>针对项目，建立了食评项目和工具项目两个类型，针对他们的数据分别为食品安全等级和工具效率等级。</p><p>接下来就是不同的专家分别评审两者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject foodProject)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject toolProject)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后针对不同专家，处理两者的方式也不同<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVisitor</span> <span class="hljs-title">implement</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;食评项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,安全等级:&quot;</span>+project.getSafe());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;工具项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,质量等级:&quot;</span>+project.getQuality());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样大致完成基本功能</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 访问者使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/23.png" alt="github"></p>]]></content>
    
    
    <summary type="html">访问者模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Spire包处理文档</title>
    <link href="http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-02-16T06:49:03.842Z</updated>
    
    
    <summary type="html">使用Spire包处理文档</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"/>
    <id>http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-02-17T07:10:37.255Z</updated>
    
    <content type="html"><![CDATA[<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p>首先创建状态机，或者说上下文。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        state.start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        state.close(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>再看看状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来建立对应的两个状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.close(<span class="hljs-keyword">new</span> CloseState());<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.start(<span class="hljs-keyword">new</span> StartState());<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>准备好后就可以使用了。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        <br>        context.setState(<span class="hljs-keyword">new</span> StartState());<br>        context.close();<br>        context.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/20.png" alt="github"></p>]]></content>
    
    
    <summary type="html">状态模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-02-15T01:58:18.056Z</updated>
    
    <content type="html"><![CDATA[<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>首先是中介者接口定义，接口中的提供了功能定义了赢的人是谁，输的人有谁，以及赢了多少<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及实现该接口的对象，主要对用户进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mediator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span> </span>&#123;<br>        winer.add(data);<br>        foreach(Colleage c : losers) &#123;<br>            c.subtraction(data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是用户的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后我们针对用户进行实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data += data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data -= data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>主要通过中介者来对同事的数据进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Mediator mediator = <span class="hljs-keyword">new</span> ConcreteMediator();<br>        <br>        Colleague c1 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">100</span>);<br>        Colleague c2 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">800</span>);<br>        Colleague c3 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">400</span>);<br>        <br>        mediator.win(c1, <span class="hljs-number">10</span>, c2, c3);<br>        mediator.win(c3, <span class="hljs-number">100</span>, c1);<br>        mediator.win(c2, -<span class="hljs-number">10</span>, c3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/17.png" alt="github"></p>]]></content>
    
    
    <summary type="html">中介者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-02-15T08:07:42.986Z</updated>
    
    <content type="html"><![CDATA[<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mement <span class="hljs-title">saveCurrentStateToMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(state);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = m.getState();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面建立了原发器的状态字段，以及提供对当前状态的保存以及恢复功能，使用了另一个类来存储当前状态。但是他并不会保存这些状态，只是用这些记录来恢复。</p><p>针对每一次记录都使用下面的对象来单独保存。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后使用一个备忘录管理类来管理这些备忘录<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CareTaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Memento&gt; datas = <span class="hljs-keyword">new</span> ArrayList&lt;Memento&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        datas.add(m)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> datas.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Originator originator = <span class="hljs-keyword">new</span> Originator();<br>        CareTaker careTaker = <span class="hljs-keyword">new</span> CareTaker();<br>        originator.setState(<span class="hljs-string">&quot;状态1&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态2&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态3&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        <br>        originator.restore(careTaker.get(<span class="hljs-number">0</span>));<br>        originator.restore(careTaker.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>必须保存一个对象在某一个时刻的 (部分)状态, 这样以后需要时它才能恢复到先前的状态。</li><li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/18.png" alt="github"></p>]]></content>
    
    
    <summary type="html">备忘录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-02-15T08:55:40.527Z</updated>
    
    <content type="html"><![CDATA[<p>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。</p><p>首先定义观察接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后创建多个观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user:&quot;</span>+arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是被观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; obs;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Observable</span><span class="hljs-params">()</span> </span>&#123;<br>        obs = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">if</span> (!obs.contains(o)) &#123;<br>            obs.addElement(o);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        obs.removeElement(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        notifyObservers(<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * a temporary array buffer, used as a snapshot of the state of</span><br><span class="hljs-comment">         * current Observers.</span><br><span class="hljs-comment">         */</span><br>        Object[] arrLocal;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!changed)<br>                <span class="hljs-keyword">return</span>;<br>            arrLocal = obs.toArray();<br>            clearChanged();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arrLocal.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>            ((Observer)arrLocal[i]).update(<span class="hljs-keyword">this</span>, arg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        obs.removeAllElements();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> changed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> obs.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后继承该类，创建被观察者。这里会发送一条消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setChanged();<br>        notifyObservers(msg);<br>        <span class="hljs-keyword">this</span>.clearChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Observer u1 = <span class="hljs-keyword">new</span> UserObserver();<br>        Observer u2 = <span class="hljs-keyword">new</span> UserObserver();<br>        Subject subject = <span class="hljs-keyword">new</span> Subject();<br>        subject.addObserver(u1);<br>        subject.addObserver(u2);<br>        <br>        subject.setMessage(<span class="hljs-string">&quot;消息1&quot;</span>);<br>        subject.setMessage(<span class="hljs-string">&quot;消息2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象是紧密耦合的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/19.png" alt="github"></p>]]></content>
    
    
    <summary type="html">观察者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-解释器</title>
    <link href="http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"/>
    <id>http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/</id>
    <published>2023-02-12T20:34:01.000Z</published>
    <updated>2023-02-13T14:57:21.077Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个语言，定义他的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>那么根据结构建立一个简单的解释器<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>参数解析<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String key;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VarExpression</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.get(<span class="hljs-keyword">this</span>.key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及符号解析，具备了符号左右的参数添加<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Expression leftVar, rightVar;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SymbolExpression</span><span class="hljs-params">(Expression leftVar, Expression rightVar)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.leftVar = leftVar;<br>        <span class="hljs-keyword">this</span>.rightVar = rightVar;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>首先准备一个加法符号<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SymbolExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddExpression</span><span class="hljs-params">(Expression leftVar, Expression rightVar)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(leftVar, rightVar);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.leftVar.interpreter(data) + <span class="hljs-keyword">super</span>.rightVar.interpreter(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来只需要使用配置的对象解决问题即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p><ol><li>该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。他们无需构建抽象语法树即可解释表达式，这也可以节省空间而且还可能节省时间。</li><li>效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将她们转换成另一个形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/15.png" alt="github"></p>]]></content>
    
    
    <summary type="html">解释器</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器</title>
    <link href="http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"/>
    <id>http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/</id>
    <published>2023-02-12T20:34:01.000Z</published>
    <updated>2023-02-14T02:52:38.709Z</updated>
    
    <content type="html"><![CDATA[<p>提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。</p><p>熟悉java就应该知道，Iterator模式这个在java中用的非常广泛。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用ArrayList<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span> </span>&#123;<br>    Object[] arr = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == arr.lenth) &#123;<br>            Object[] newArr = <span class="hljs-keyword">new</span> Object[arr.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(arr, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, arr.length);<br>            arr = newArr;<br>        &#125;<br>        arr[index] = item;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面是一个普通ArrayList下的构建，还不具备迭代器，只能使用索引下标来进行迭代。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里建立迭代器的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后让ArrayList实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E[] arr = (E[])<span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == arr.lenth) &#123;<br>            E[] newArr = (E[])<span class="hljs-keyword">new</span> Object[arr.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(arr, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, arr.length);<br>            arr = newArr;<br>        &#125;<br>        arr[index] = item;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayListIterator();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentIndex = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (currentIndex &gt;= index) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            E item = (E)arr[currentIndex];<br>            currentIndex++;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时使用新ArrayList中的Iterator，构建一个迭代器。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Iterator iterator = list.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>            String data = iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口 (即, 支持多态迭代)。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/16.png" alt="github"></p>]]></content>
    
    
    <summary type="html">迭代器</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-命令</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/</id>
    <published>2023-02-11T13:12:56.000Z</published>
    <updated>2023-02-12T13:05:02.536Z</updated>
    
    <content type="html"><![CDATA[<p>将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Receiver receiver = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenCommand</span><span class="hljs-params">(Receiver receiver)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        receiver.action();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是接收者如何处理消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收者处理消息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面大致是命令收到后会让接收者收到一条消息。</p><p>接下来就是发送消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Command command = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span> </span>&#123;<br>        command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>大致准备好后，就可以使用了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Command command = OpenCommand(<span class="hljs-keyword">new</span> Receiver());<br>        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();<br>        invoker.setCommand(command);<br>        invoker.invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>将可用过程语言中的回调函数表达这种参数化机制。回调函数是指函数先在某处注册，而他将在稍后某个需要的时候被调用。命令模式是回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求。一个命令对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那实现该请求。</li><li>支持取消操作。</li><li>支持修改日志。</li><li>用构建在原语操作上的高层操作构造一个系统，这样一种结构在支持事务的信息系统上很常见。一个事务封装了对数据的一组变动。命令模式提供了对事物进行组建的方法。命令模式有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事物以扩展系统。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/14.png" alt="github"></p>]]></content>
    
    
    <summary type="html">命令</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/</id>
    <published>2023-02-11T07:43:01.000Z</published>
    <updated>2023-02-10T15:32:04.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代理。</li><li>虚拟代理（Virtual Proxy）根据需要创建开销很大的对象。</li><li>保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li><li>智能指引（Smart Reference）取代了简单的指针，他在访问对象时执行一些附加操作。典型用途包括：<ul><li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放他。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查是否已经锁定了他，以确保其他对象不能改变它。</li></ul></li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/12.png" alt="github"></p>]]></content>
    
    
    <summary type="html">代理</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-职责链</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/</id>
    <published>2023-02-11T07:43:01.000Z</published>
    <updated>2023-02-11T05:51:31.181Z</updated>
    
    <content type="html"><![CDATA[<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>有点像按钮点击，当我们点击按钮后，点击事件并不是直接传递给这个按钮，而是一层一层向下传递。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">window -&gt; groupView -&gt; view<br></code></pre></td></tr></table></figure><br>首先是点击事件<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> thisType;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后是组件父类<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    Weight parent;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Weight</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = w;<br>        <span class="hljs-keyword">this</span>.thisType = thisType;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来就可以使用它来构建控件了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Button</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, thisType);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (testType == thisType) &#123;<br>            System.out.println(<span class="hljs-string">&quot;BUTTON Click&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            w.click(testType);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextView</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, thisType);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (testType == thisType) &#123;<br>            System.out.println(<span class="hljs-string">&quot;TEXTVIEW Click&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            w.click(testType);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwitchView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SwitchView</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, thisType);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (testType == thisType) &#123;<br>            System.out.println(<span class="hljs-string">&quot;SWITCHVIEW Click&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w != <span class="hljs-keyword">null</span>) &#123;<br>            w.click(testType);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;该链无法完成任务&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来，创建这个链<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Weight w = <span class="hljs-keyword">new</span> SwitchView(<span class="hljs-keyword">new</span> Button(<span class="hljs-keyword">new</span> TextView(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>), <span class="hljs-number">2</span>);<br>        w.click(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>有多个的对象可以处理一个请求，具体哪个对象来处理，可以在运行时觉得。</li><li>想在不明确指定接收者的情况下，在多个对象中的有一个提交一个请求。</li><li>可处理一个请求的对象集合应被动态指定。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/13.png" alt="github"></p>]]></content>
    
    
    <summary type="html">职责链</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-享元</title>
    <link href="http://example.com/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"/>
    <id>http://example.com/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/</id>
    <published>2023-02-10T23:12:38.000Z</published>
    <updated>2023-02-10T15:05:32.162Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程，在面对事物时会针对面向对象建立映射。<br>但是如果同类的对象使用过多，就会面临内存占用率过高，产生难以预估的内存消耗。为此，享元模式，描述了如何共享对象，使得可以使用他们并无需高昂的代价。<br>例如需要提供一个富文本编。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Glyph</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFont</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是具备绘图功能。下面就负责存储富文本的每一个字符。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> <span class="hljs-title">implement</span> <span class="hljs-title">Glyph</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span> </span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFont</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>当然，这里不仅仅是字符具备该功能，比如一些线条等。</p><p>为了避免每一个字体属性都分配存储空间，可以将该属性存储到外部缓存中。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlyphContext</span> </span>&#123;<br>    List&lt;Font&gt; fonts;<br>    <span class="hljs-comment">// add</span><br>    <span class="hljs-comment">// remove</span><br>    <span class="hljs-comment">// get</span><br>&#125;<br></code></pre></td></tr></table></figure><br>接下来就需要提供一个工厂，他来负责构建一些Glyph，当需要字体属性时，就去存储空间去找；不需要，则直接创建即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlyphFactory</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Character&gt; chars;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Glyph <span class="hljs-title">createCharacter</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!chars.has(<span class="hljs-keyword">char</span>)) &#123;<br>            <span class="hljs-keyword">char</span>.add(<span class="hljs-keyword">new</span> Character(<span class="hljs-keyword">char</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> chars.get(<span class="hljs-keyword">char</span>);<br>    &#125;<br>    pubic GlyphContext context;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>享元模式的有效性很大程度上取决于如何使用它以及在何处使用它。以下情况都成立使用：</p><ol><li>一个应用程序使用了大量的对象</li><li>完全由于使用大量的对象，造成很大的存储开销</li><li>对象的大多数状态都可变为外部状态</li><li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li><li>应用程序不依赖于对象标识。由于flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/11.png" alt="github"></p>]]></content>
    
    
    <summary type="html">享元</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-外观</title>
    <link href="http://example.com/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"/>
    <id>http://example.com/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/</id>
    <published>2023-02-08T19:59:30.000Z</published>
    <updated>2023-02-08T12:01:47.359Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式和对外提供的SDK非常相像。对外的出入口固定，所有子系统功能都由外观的出入口提供，内部单独完成一整套的信息并对外公开。<br>他与单例模式配合非常好，因为单例只会提供一个对象，即出入口，所有的对接只和这个对象对接即可。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变的越来越复杂。大多数模式使用时会产生更多更小的类。这使得子系统更具有可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。外观模式可以提供一个简单的缺省视图，这一视图对大多数用户已经足够，而那些需要更多可定制性的用户可以越过外观模式。</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入外观模式将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</li><li>当需要构建一个层次结构的子系统，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让他们仅通过外观模式进行通信，从而简化他们的依赖性。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/10.png" alt="github"></p>]]></content>
    
    
    <summary type="html">外观</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰</title>
    <link href="http://example.com/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/"/>
    <id>http://example.com/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/</id>
    <published>2023-02-07T18:47:30.000Z</published>
    <updated>2023-02-08T11:28:00.460Z</updated>
    
    <content type="html"><![CDATA[<p>最好的例子就是ui图，在针对富文本进行编辑的时候，工具栏、文本栏、保存/取消栏等，都是是在其基础上进行装饰的效果。</p><p>首先是基础绘图组件<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VisualComponent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>以及具备该功能抽象类<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">pubic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">abstract</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VisualComponet</span> </span>&#123;<br>    <br>    VisualComponent component;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        component.draw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>接下来就可以使用抽象类的子类完成工作<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BorderDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BorderDecorator</span><span class="hljs-params">(VIsualComponent component)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBorder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.draw();<br>        drawBorder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样在原有的基础draw上，增加了其他的操作。一层嵌套一层形成新的子类，并在原有基础上更具有针对性增加功能。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可能撤销的职责</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/9.png" alt="github"></p>]]></content>
    
    
    <summary type="html">装饰</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式- 桥接</title>
    <link href="http://example.com/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/"/>
    <id>http://example.com/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/</id>
    <published>2023-02-06T19:46:00.000Z</published>
    <updated>2023-02-06T13:10:47.040Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">pubic <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Food</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatFood</span> <span class="hljs-title">implement</span> <span class="hljs-title">Food</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫粮&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogFood</span> <span class="hljs-title">implement</span> <span class="hljs-title">Food</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗粮&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>准备动物<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">protected</span> Food food;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(Food food)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.food = food;<br>    &#125;<br>    <br>    <span class="hljs-function">pubic <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(Food food)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(Food food)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(food);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;mimi-&quot;</span>);<br>        food.name();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(Food food)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(food);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;wowo-&quot;</span>);<br>        food.name();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个流程代码中写的很清楚了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Dog(<span class="hljs-keyword">new</span> DogFood()).eat();<br>        <span class="hljs-keyword">new</span> Dog(<span class="hljs-keyword">new</span> CatFood()).eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>看着狗在吃猫粮，原则上有点说不通，但是确实可以，只要是粮食。整个设计是将抽象类嵌入一个接口，让他具有使用这个接口的能力。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>不希望在抽象和他的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li><li>类的抽象以及他的实现都应该可以通过生成子类的方法加以扩充。这时桥接模式使你可以对不同的抽象接口和实现部分进行组合，并分别对他们进行扩充。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，及客户的代码不必重新编译。</li><li>必须将一个对象分解成两个部分。称这种类层次结构为<strong>嵌套的概括</strong>。</li><li>在多个对象间共享实现（可能是引用计数），但同时要求客户并不知道这一点。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/7.png" alt="github"></p>]]></content>
    
    
    <summary type="html">桥接</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式- 组合</title>
    <link href="http://example.com/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/"/>
    <id>http://example.com/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/</id>
    <published>2023-02-06T19:46:00.000Z</published>
    <updated>2023-02-07T10:49:04.114Z</updated>
    
    <content type="html"><![CDATA[<p>组合很好的例子就是画图的时候，图中有图，有文字，有线条等。</p><p>基础接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Graphic</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Graphic graphic)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Graphic graphic)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> child)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>看看普通leaf组建<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Graphic</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;文本&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Graphic graphic)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Graphic graphic)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> child)</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>他并不具备子部件功能</p><p>看看Composite组建<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Picture</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Graphic</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(Graphic g : list) <br>            g.draw();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Graphic graphic)</span> </span>&#123;<br>        list.add(graphic);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Graphic graphic)</span> </span>&#123;<br>        list.remove(graphic);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> child)</span> </span>&#123;<br>        ...<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>想表示对象的部分-整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构中的所有对象</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/8.png" alt="github"></p>]]></content>
    
    
    <summary type="html">组合</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型</title>
    <link href="http://example.com/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/"/>
    <id>http://example.com/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/</id>
    <published>2023-02-02T18:00:35.000Z</published>
    <updated>2023-02-20T05:51:03.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>克隆（clone）非常适合这里的说明，复制一个类实例。</p><p>但是这里涉及到了：浅拷贝和深拷贝。<br>他们在java中有原始类型和引用类型（这真对引用类型）。所谓浅拷贝只是拷贝对象的引用，而非里面这个对象里面的所有值；深拷贝则相反，并不知拷贝引用，而是新建一个引用并复制原始对象中的所有值。</p><p><img src="/img/DesignPatterns/4.png" alt="github"></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>当一个系统应该独立于他的产品创建、构成及表示时</li><li>当要实例化的类是在运行时刻指定时，例如动态装载</li><li>为了避免创建一个与产品类层次平行的工厂类层次时</li><li>当一个类的实例只能有几个不同状态组合中的一种时</li></ol><p>建立相应数目的原型并克隆他可能比每次用合适的手工实例更方便。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/3.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>客户请求一个原型克隆自身。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol><li>它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。此外，这些模式使客户无需改变即可使用与特定应用相关的类。</li><li>运行时刻增加和删除产品Prototype允许只通过客户注册原型实例就可以将一个新的具体产品类并入系统。它比其他创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。</li><li>改变值以指定新对象高度动态的系统允许你通过对象复合定义新的行为-例如，通过为一个对象变量指定值—并且不定义新的类。你通过实例化已有类并且将这些实例注册 为客户对象的原型，就可以有效定义新类别的对象。客户可以将职责代理给原型，从而表现出新的行为。</li><li>改变结构以指定新对象许多应用由部件和子部件来创建对象。例如电路设计编辑器就是由子电路来构造电路的。为方便起见，这样的应用通常允许你实例化复杂的、用户定义的结构，比方说，一次又一次的重复使用一个特定的子电路。</li><li>用类动态配置应用一些运行时刻环境允许你动态将类装载到应用中。</li></ol>]]></content>
    
    
    <summary type="html">原型</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
