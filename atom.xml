<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小杨的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-23T14:06:46.065Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM-工具</title>
    <link href="http://example.com/2023/05/23/JVM%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2023/05/23/JVM%E5%B7%A5%E5%85%B7/</id>
    <published>2023-05-23T08:02:25.000Z</published>
    <updated>2023-05-23T14:06:46.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps（Java Virtual Machine Process Status Tool）是JDK提供的一个可以列出正在运行的Java虚拟机的进程信息的命令行工具，它可以显示Java虚拟机进程的执行主类（Main Class，main()函数所在的类）名称、本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）等信息。另外，jps命令只能显示它有访问权限的Java进程的信息。<br>命令参数说明：</p><blockquote><p>-q：不显示主类名称、JAR文件名和传递给主方法的参数，只显示本地虚拟机唯一ID。<br>-mlvV：我们可以指定这些参数的任意组合。<br>-m：显示Java虚拟机启动时传递给main()方法的参数。<br>-l：显示主类的完整包名，如果进程执行的是JAR文件，也会显示JAR文件的完整路径。<br>-v：显示Java虚拟机启动时传递的JVM参数。<br>-V：不显示主类名称、JAR文件名和传递给主方法的参数，只显示本地虚拟机唯一ID。<br>hostid：指定的远程主机，可以是ip地址和域名, 也可以指定具体协议，端口。如果不指定，则显示本机的Java虚拟机的进程信息。<br>-help：显示jps命令的帮助信息。</p></blockquote><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat 是JDK中提供的一个命令行工具，主要用来打印JVM 性能数据相关的统计数据。主要包含以下几个方面：<br>垃圾回收(GC)方面数据<br>编译(Compilation)相关数据<br>类加载信息(Class Loader)</p><p>jstat 使用很简单，只要在命令行中执行如下命令：<br> jstat -gc -t 11256 10000 10<br>参数解释：</p><blockquote><p>-gc :打印相关的统计参数<br>-t:  在每行日志之前加上JVM的启动时间<br>11256 : 目标Java进程的ID<br>10000: jstat命令执行间隔时间(milliseconds)，10000表示每10s打印一行日志<br>10: jstat命令的执行次数，(和上面的时间间隔一起，表示jstat会每10s执行1次，总共执行10次).</p></blockquote><p>参数意义：</p><ul><li>time :  JVM启动时间(单位为秒)</li><li>S0C ：年轻代中S0区的容量 （字节）</li><li>S1C ：年轻代中S1区的容量 (字节)</li><li>S0U ：年轻代中S0区目前已使用空间 (字节)</li><li>S1U ：年轻代中S1区目前已使用空间 (字节)</li><li>EC ：年轻代中Eden区的容量 (字节)</li><li>EU ：年轻代中Eden区目前已使用空间 (字节)</li><li>OC ：老年代的容量 (字节)</li><li>OU ：老年代目前已使用空间 (字节)</li><li>YGC ：从应用程序启动到采样时年轻代中GC次数</li><li>YGCT ：从应用程序启动到采样时年轻代中GC所用时间(s)</li><li>FGC ：从应用程序启动到采样时老年代(全GC)GC次数</li><li>FGCT ：从应用程序启动到采样时老年代(全GC)GC所用时间(s)</li><li>GCT：从应用程序启动到采样时GC用的总时间(s)</li></ul><p><a href="https://img-blog.csdnimg.cn/aaa166818181449da9f695d45f8c5ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16">https://img-blog.csdnimg.cn/aaa166818181449da9f695d45f8c5ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16</a></p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>jmap是JDK自带的监控工具，在JDK的根目录中可以找到。主要用来查看Java进程对内存的使用情况<br>1、查看类列表，包含实例数、占用内存大小<br><code>jmap -histo[:live] pid</code><br>2、查看动态链接库的列表<br><code>jmap pid</code><br>3、查看Java堆的概要信息<br><code>jmap -heap pid</code><br>4、生成Java虚拟机的堆转储快照 dump文件<br><code>jmap -dump:[live,] format=b,file=./heap.hprof pid</code></p><blockquote><p>live参数是可选的，如果指定，则只转储堆中的活动对象；如果没有指定，则转储堆中的所有对象。<br>format=b表示以hprof二进制格式转储Java堆的内存。<br>file=用于指定快照dump文件的文件名。</p></blockquote><p>注意，如果是k8s中自启动的java项目的pid可能为1，导致无法找到这个默认进程。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>主要是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言。<br>使用jmap等方法生成java的堆文件后，使用其进行分析。</p><h2 id="第一步：导出堆"><a href="#第一步：导出堆" class="headerlink" title="第一步：导出堆"></a>第一步：导出堆</h2><p><code>jmap -dump:live,file=a.log pid</code><br>除了jmap还有以下方法获取</p><ol><li>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）、</li><li>虚拟机启动时如果指定了 -XX:+HeapDumpOnOutOfMemoryError 选项, 则在抛出 OutOfMemoryError 时, 会自动执行堆转储。</li><li>使用 hprof 命令</li></ol><h2 id="第二步：分析堆文件"><a href="#第二步：分析堆文件" class="headerlink" title="第二步：分析堆文件"></a>第二步：分析堆文件</h2><p><code>jhat -J-Xmx512M a1.log</code><br>说明：有时dump出来的堆很大，在启动时会报堆空间不足的错误，可加参数：jhat -J-Xmx512m 。这个内存大小可根据自己电脑进行设置。<br>解析Java堆转储文件,并启动一个 web server</p><h2 id="第三步：查看html"><a href="#第三步：查看html" class="headerlink" title="第三步：查看html"></a>第三步：查看html</h2><p><code>http://ip:7000/</code></p><p>对于jhat启动后显示的html页面中功能：</p><ul><li>（1）显示出堆中所包含的所有的类</li><li>（2）从根集能引用到的对象</li><li>（3）显示平台包括的所有类的实例数量</li><li>（4）堆实例的分布表</li><li>（5）执行对象查询语句</li></ul><p>当需要进行语句查询是：<br>输入内容如：<br><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#查询长度大于100的字符串</span><br><span class="hljs-keyword">select</span> s <span class="hljs-keyword">from</span> java.lang.String s <span class="hljs-keyword">where</span> s.<span class="hljs-keyword">count</span> &gt; <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照。<br>jstack 命令格式如下<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">jstack <span class="hljs-selector-attr">[ option ]</span> pid <br>jstack <span class="hljs-selector-attr">[ option ]</span> executable core <br>jstack <span class="hljs-selector-attr">[ option ]</span> <span class="hljs-selector-attr">[server-id@]</span>remote-hostname-or-IP <br></code></pre></td></tr></table></figure></p><p>option<br>选项    作用</p><ul><li>-F    当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-m    如果调用到本地方法的话，可以显示C/C++的堆栈</li><li>-l    除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</li></ul><p>Java语言定义了6种线程池状态：</p><ul><li>New：创建后尚未启动的线程处于这种状态，不会出现在Dump中。</li><li>RUNNABLE：包括Running和Ready。线程开启start（）方法，会进入该状态，在虚拟机内执行的。</li><li>Waiting：无限的等待另一个线程的特定操作。</li><li>Timed Waiting：有时限的等待另一个线程的特定操作。</li><li>阻塞（Blocked）：在程序等待进入同步区域的时候，线程将进入这种状态，在等待监视器锁。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul><p>Dump文件的线程状态一般其实就以下3种：</p><ul><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li></ul><p>Dump 文件分析关注重点</p><ul><li>runnable，线程处于执行中</li><li>deadlock，死锁（重点关注）</li><li>blocked，线程被阻塞 （重点关注）</li><li>Parked，停止</li><li>locked，对象加锁</li><li>waiting，线程正在等待</li><li>waiting to lock 等待上锁</li><li>Object.wait()，对象等待中</li><li>waiting for monitor entry 等待获取监视器（重点关注）</li><li>Waiting on condition，等待资源（重点关注），最常见的情况是线程在等待网络的读写</li></ul><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo命令用于打印指定Java进程或核心文件或远程调试服务器的Java配置信息。这些配置信息包括Java系统属性和Java虚拟机(JVM)命令行标志。<br>如果指定的进程运行在64位JVM上，则需要用：jinfo -J-d64 -sysprops pid命令。<br>jinfo命令可能会在之后的版本中删除。<br>语法<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jinfo </span>[ option ] pid 连接到正在运行的进程<br><span class="hljs-keyword">jinfo </span>[ option ] executable core 连接到核心文件<br><span class="hljs-keyword">jinfo </span>[ option ] [ servier-id ] remote-hostname-<span class="hljs-keyword">or-IP </span>要连接到远程<span class="hljs-built_in">DEBUG</span>服务器<br></code></pre></td></tr></table></figure></p><ul><li>executable：生成core dump的Java可执行文件</li><li>core：要打印内存映射的核心文件</li><li>server-id：服务器的ID。如果多个DEBUG服务器在同一个远程主机上运行，则各个服务器的ID必须唯一</li><li>remote-hostname：远程DEBUG服务器的主机名</li><li>IP：远程DEBUG服务器的IP</li></ul><p>参数说明</p><ul><li>no-option<br>打印命令行标志和系统属性的【name-value】对。</li><li>-flag name<br>打印指定命令行标志的【name-value】对。</li><li>-flag [+|-]name<br>启用或禁用指定的命令行标志。<br>表示启用，- 表示禁用。</li><li>-flag name=value<br>将指定的命令行标志设置为指定的值。<br>注意：不是所有的flag都可以通过命令行改变！！！</li><li>-flags<br>打印传递给JVM的命令行标志。</li><li>-sysprops<br>以【name-value】对的形式打印Java系统属性。</li><li>-h or -help<br>打印jinfo命令的帮助信息。</li></ul><h2 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h2><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对正在运行的环境进行查看。</p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>jdk自带全能工具，可以分析内存快照、线程快照;监控内存变化、GC变化等。<br><code>jvisualvm --openpid 44620</code></p><p>安装插件<br>在这里找到对应jdk版本号的地址<a href="https://visualvm.github.io/pluginscenters.html，复制到插件中心里面即可。">https://visualvm.github.io/pluginscenters.html，复制到插件中心里面即可。</a></p><h2 id="Memory-Analyzer-Tool"><a href="#Memory-Analyzer-Tool" class="headerlink" title="Memory Analyzer Tool"></a>Memory Analyzer Tool</h2><p>一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br>下载地址 <a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a><br>这里需要找对版本号。</p><h2 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h2><p>一款专业分析gc日志的工具<br>需要自己编译运行<br>git 地址<br><code>https://github.com/jewes/gchisto</code></p>]]></content>
    
    
    <summary type="html">JVM-工具</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>相机学习2-我的富士学习</title>
    <link href="http://example.com/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/"/>
    <id>http://example.com/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/</id>
    <published>2023-04-24T18:02:25.000Z</published>
    <updated>2023-04-26T14:02:32.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="曝光模式"><a href="#曝光模式" class="headerlink" title="曝光模式"></a>曝光模式</h1><h2 id="程序自动曝光P"><a href="#程序自动曝光P" class="headerlink" title="程序自动曝光P"></a>程序自动曝光P</h2><p>若要使快门速度和光圈均由照相机调整已获得理想曝光，请将快门速度和光圈设置为A。<br>若拍照对象位于照相机测光范围之外，快门速度和光圈将显示<code>---</code>。</p><p>如有需要，可旋转前指令拨盘选择快门和光圈的其他组合而不更改曝光。<br>程序切换在以下情况中不可用</p><ul><li>安装的闪光灯支持TTL自动</li><li>动态范围选择了自动</li><li>感光度拨盘旋转至A</li></ul><h2 id="快门优先AE-S"><a href="#快门优先AE-S" class="headerlink" title="快门优先AE S"></a>快门优先AE S</h2><p>将光圈设为A并使用快门速度拨盘，可手动调整快门速度而有照片相机选择光圈获得的理想曝光。</p><p>在180X以外的设定下，也可以通过旋转前指令拨盘以1/3EV为步长调整快门速度。即使在板块们按钮期间也可调整快门速度。</p><p>若无法在所选快门速度下达到正确的曝光，半按快门按钮时光圈将显示红色。<br>若拍摄对象位于测光范围之外，光圈将显示为<code>---</code>。</p><h2 id="光圈优先AE-A"><a href="#光圈优先AE-A" class="headerlink" title="光圈优先AE A"></a>光圈优先AE A</h2><p>将快门速度旋转至A并根据需要调整光圈，可手动调整光圈至由相机选择快门速度已获得理想曝光。</p><p>即使在半按快门按钮期间也可以调整光圈。</p><p>若无法在光圈下达到正常曝光，将显示红色。<br>若拍摄对象位于相机测光范围之外，快门速度将显示<code>---</code>。</p><p>手动曝光 M<br>-<br>将快门速度和光圈均设为A以外的值可改变照相机建议的曝光值。屏幕将显示M。</p><p>在180X以外的的设定下，也可以通过选择前指令拨盘以1/3EV为步长调整快门速度。<br>手动曝光显示包含曝光指示，当前设定下照片将会曝光不足或曝光过度的量通过最左侧的曝光指示提示。</p><h1 id="DRIVE拨盘"><a href="#DRIVE拨盘" class="headerlink" title="DRIVE拨盘"></a>DRIVE拨盘</h1><p>BKT：包围，在一些列照片中自动更改设定<br>CH：高速连拍<br>CL：低速连拍<br>S：单幅画面<br>多重曝光：创建由两次曝光组合的照片<br>创意滤镜：拍摄带滤镜效果的照片<br>全景：按照屏幕指南创建全景照片</p><h1 id="色彩相关"><a href="#色彩相关" class="headerlink" title="色彩相关"></a>色彩相关</h1><p><code>XT-1</code>只有<code>色彩</code>功能。</p><ol><li>色彩的加减即是整体饱和度的加减，影响全局饱和度</li><li>色彩的加减不会影响色相</li></ol><h1 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h1><p>一共三个档次，每一次提升都需要提升一档ISO。</p><ol><li>提高ISO会下降很小的画质，但是可以显著降低高光区域的曝光</li><li>不影响阴影区域的曝光</li><li>主要用于恢复高光细节</li></ol><h1 id="高光色调"><a href="#高光色调" class="headerlink" title="高光色调"></a>高光色调</h1><ol><li>高光加就是增强高光</li><li>高光减则是减轻高光</li></ol><h1 id="阴影色调"><a href="#阴影色调" class="headerlink" title="阴影色调"></a>阴影色调</h1><ol><li>加阴影则是增强阴影</li><li>减阴影则是减弱阴影</li></ol><h1 id="锐度"><a href="#锐度" class="headerlink" title="锐度"></a>锐度</h1><p>让整体画面更加锐利。</p><ol><li>人物一般降低锐度</li><li>静物一般增加锐度</li></ol><h1 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h1><p>一般情况是在ISO125开始工作，显著改善ISO下的噪点。</p><h1 id="长时间曝光降噪"><a href="#长时间曝光降噪" class="headerlink" title="长时间曝光降噪"></a>长时间曝光降噪</h1><p>一般指快门8s后开始工作，星空下效果很好。</p><h1 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h1><p>色温的高低会让画面呈现的冷暖不同。</p><h1 id="胶片模拟的底层逻辑"><a href="#胶片模拟的底层逻辑" class="headerlink" title="胶片模拟的底层逻辑"></a>胶片模拟的底层逻辑</h1><p>风格差异：</p><ol><li>色相/饱和度/亮度；高光与阴影的偏色</li><li>高光/阴影； 照片的反差与对比度</li></ol><p>最终成像：<br>同一种胶片模拟通过机内设置可产生完全不同的风格<br>白平衡与偏移的影响最为显著。</p><ul><li>PROVIA/标准：基础拍摄</li><li>Velvia/鲜艳：色彩饱和、对比度高，用于自然风景</li><li>ASTIA/柔和：增加用于肖像颜色范围，同时保留天空蓝色，适合户外肖像</li><li>PRO Neg.Hi：提供的对比度在n.s.下提供的稍多，在户外进行肖像拍摄时推荐</li><li>PRO Neg.Std：色调柔和，增加用于肤色的色相范围，适合摄影棚肖像</li><li>黑白：标准黑白</li><li>黑白+黄滤镜：对比度稍强，并稍微降低天空的亮度</li><li>黑白+红滤镜：对比度增强，大幅降低天空的亮度</li><li>黑白+绿滤镜：柔化黑白肖像的肤色</li><li>棕褐色：棕褐色照片</li></ul><h1 id="一些使用参数"><a href="#一些使用参数" class="headerlink" title="一些使用参数"></a>一些使用参数</h1><h2 id="晴天"><a href="#晴天" class="headerlink" title="晴天"></a>晴天</h2><ol><li>胶片 c.n.</li><li>色温5200K</li><li>色调H-2，S-2</li><li>动态范围 400</li><li>色彩+3 锐度+4</li></ol><h2 id="温柔黄昏胶片滤镜"><a href="#温柔黄昏胶片滤镜" class="headerlink" title="温柔黄昏胶片滤镜"></a>温柔黄昏胶片滤镜</h2><ol><li>胶片c.c.</li><li>色彩+4</li><li>锐度0</li><li>高ISO降噪-4</li><li>色温6050K red3，blue0</li><li>ISO最高6400</li><li>动态范围自动</li><li>曝光补偿0-2/3</li><li>色调 H+1，S-2</li></ol><h2 id="日系清新胶片滤镜"><a href="#日系清新胶片滤镜" class="headerlink" title="日系清新胶片滤镜"></a>日系清新胶片滤镜</h2><ol><li>胶片n.c.</li><li>色彩+2</li><li>锐度+2</li><li>高ISO降噪 关</li><li>白平衡 日光，red-2，blue-2</li><li>ISO最高6400</li><li>动态范围自动</li><li>曝光补偿+2/3</li><li>色调 H-0.5，S-0.5</li></ol><h2 id="夜色复古胶片滤镜"><a href="#夜色复古胶片滤镜" class="headerlink" title="夜色复古胶片滤镜"></a>夜色复古胶片滤镜</h2><ol><li>胶片c.c.</li><li>色彩+2</li><li>白平衡 阴天 red-2，blue-2</li><li>动态范围 100</li><li>色调H-1，S+2</li><li>降噪-1</li></ol><h2 id="电影扫街胶片滤镜"><a href="#电影扫街胶片滤镜" class="headerlink" title="电影扫街胶片滤镜"></a>电影扫街胶片滤镜</h2><p>胶片c.c.<br>白平衡 5500K<br>锐度+3<br>动态范围400<br>色调 H+2，S+2<br>降噪-2</p><h2 id="静谧氛围胶片滤镜"><a href="#静谧氛围胶片滤镜" class="headerlink" title="静谧氛围胶片滤镜"></a>静谧氛围胶片滤镜</h2><p>胶片c.c.<br>色彩 +1<br>锐度 +1<br>白平衡 日光 red+2，blue-3<br>ISO最高6400<br>动态范围400<br>色调H-1，S+2<br>降噪-2</p>]]></content>
    
    
    <summary type="html">相机</summary>
    
    
    
    <category term="相机" scheme="http://example.com/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>相机学习1-基础部分</title>
    <link href="http://example.com/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/"/>
    <id>http://example.com/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/</id>
    <published>2023-04-09T08:59:25.000Z</published>
    <updated>2023-04-25T06:06:52.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h1><p>光圈越大，亮度越高。<br>光圈数值和大小相反，数值越小，光圈越大。</p><h1 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h1><p>快门越快，亮度越小。<br>一般使用分数来表示，数值越大，快门越小。</p><h1 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h1><p>ISO相当于在cmos上加上一个亮片，ISO越高，亮度越高，但是照片质量会降低，增加颗粒感，因为它是靠电子信号来发光。<br>iso并非越低越好，而是越接近原生iso越好，比如有的相机原生iso在400那么这时iso100的画质不如iso400，再比如有的iso可以低至50，而尼康D850的iso可以低至64，但由于iso50是拓展的iso画质是不如D850的iso64的。</p><h1 id="景深和虚化"><a href="#景深和虚化" class="headerlink" title="景深和虚化"></a>景深和虚化</h1><p>光圈的大小不仅仅会影响亮度，还会影响景深和虚化。</p><h1 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h1><p>大光圈导致浅景深，小光圈导致深景深。</p><h1 id="虚化"><a href="#虚化" class="headerlink" title="虚化"></a>虚化</h1><p>大光圈导致虚化强，小光圈导致虚化弱。</p><h1 id="动态模糊"><a href="#动态模糊" class="headerlink" title="动态模糊"></a>动态模糊</h1><p>快门的快慢不仅仅会影响亮度，还会影响动态模糊。<br>在亮度不够使，自动快门会导致快门时间过长，导致手抖可能发生照片模糊，测试需要将快门变慢，如果要保持自动，则需要设置其他的功能提高亮度。<br>但是慢快门可以让照片好看，即慢速快门。慢速快门拍摄技巧，可用于拍摄光绘，星轨，车流，火花可使用三脚架保持相机稳定，防止糊掉。</p><p>大太阳下，如何既有虚化（大光圈，浅景深，模糊背景），又有动态模糊（慢快门，让光在CMOS上运动）？<br>既有虚化，又有运动模糊，可以拍摄出一种运动感、速度感。引入  ND滤镜    （控光工具，可理解为相机用墨镜🕶可以降低画面亮度，有可变和固定参数两种。）</p><h1 id="相机档位"><a href="#相机档位" class="headerlink" title="相机档位"></a>相机档位</h1><p>Aperture 光圈<br>Shutter 快门<br>Program 程序（辅助）<br>Manual 全手动</p><div class="table-container"><table><thead><tr><th>档位</th><th>光圈</th><th>快门</th><th>ISO</th></tr></thead><tbody><tr><td>A</td><td>你</td><td>相机</td><td>你</td></tr><tr><td>S</td><td>相机</td><td>你</td><td>你</td></tr><tr><td>P</td><td>相机</td><td>相机</td><td>你</td></tr><tr><td>M</td><td>你</td><td>你</td><td>你</td></tr></tbody></table></div><h1 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h1><p>若IOS为手动挡</p><div class="table-container"><table><thead><tr><th>档位</th><th>光圈</th><th>快门</th><th>ISO</th></tr></thead><tbody><tr><td>A</td><td>你</td><td>曝光补偿</td><td>你</td></tr><tr><td>S</td><td>曝光补偿</td><td>你</td><td>你</td></tr><tr><td>P</td><td>曝光补偿</td><td>曝光补偿</td><td>你</td></tr><tr><td>M</td><td>你</td><td>你</td><td>你</td></tr></tbody></table></div><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>亮度说明图<br>左侧为偏暗<br>右侧为偏暗<br>中间表示明暗过渡的部分</p><h1 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h1><h1 id="除杂物"><a href="#除杂物" class="headerlink" title="除杂物"></a>除杂物</h1><p>保持画面干净整洁</p><ol><li>手动清除杂物</li><li>调整取景角度</li><li>大光圈虚化，或者放大画面规避</li></ol><h1 id="视角独特"><a href="#视角独特" class="headerlink" title="视角独特"></a>视角独特</h1><ol><li>低角度往上拍，突显高贵</li><li>高角度往下拍，娇小可爱，邻家感觉</li><li>远拍，距离感</li><li>近拍，感觉亲和</li><li>广角拍摄，纳入更多环境元素</li><li>特写拍摄:代入感强</li></ol><p>空间拍摄技巧，让画面更具纵深感和层次感<br>在空间上找可以延伸的最远方向<br>利用引导线<br>多个平面堆叠<br>添置前景遮挡</p><h1 id="突出主题（影明暗，色彩强弱，空间虚实）"><a href="#突出主题（影明暗，色彩强弱，空间虚实）" class="headerlink" title="突出主题（影明暗，色彩强弱，空间虚实）"></a>突出主题（影明暗，色彩强弱，空间虚实）</h1><ol><li>光影明暗</li><li>色彩强弱</li><li>空间虚实</li><li>明显的引导线</li></ol><h1 id="平衡主体"><a href="#平衡主体" class="headerlink" title="平衡主体"></a>平衡主体</h1><p>平衡画面重心，不要过于强调画面主体<br>画面元素，明暗占比会影响画面重心。色彩艳丽占比。<br>保证脸部光线要均匀。</p><h1 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h1><p>没有经过压缩的原始文件</p><h1 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h1><p>黑白颜色标准，推算别的颜色，白平衡则是告诉相机那一个是白色。<br>具备功能都会指明场景，晴天、雨天、灯下等。</p><h1 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h1><p>全局测光<br>中央测光<br>点测光</p><h1 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h1><p>光圈变小，将对焦范围变大<br>手动扭动对焦环，设置对焦距离</p><p>单次自动对焦:AF-S<br>连续自动对焦:AF-C（拍摄运动物体）<br>手动对焦:mf（手拧对焦环对焦）<br>自动手动混合:DMF（在相机自动对焦后，仍可以手拧对焦环微调）</p>]]></content>
    
    
    <summary type="html">相机</summary>
    
    
    
    <category term="相机" scheme="http://example.com/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NginxProxyManager增加ssl</title>
    <link href="http://example.com/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/"/>
    <id>http://example.com/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-30T09:01:12.209Z</updated>
    
    <content type="html"><![CDATA[<p>NginxProxyManager增加custom ssl<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">openssl genrsa -out root.key <span class="hljs-number">1024</span><br><br>openssl req -<span class="hljs-keyword">new</span> -out root.csr -key root.key<br><br>openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days <span class="hljs-number">3650</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">NginxProxyManager增加ssl</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JVM—SafePoint</title>
    <link href="http://example.com/2023/03/15/JVM_SafePoint/"/>
    <id>http://example.com/2023/03/15/JVM_SafePoint/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-23T06:18:41.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h2><p>JVM的主要任务是执行Java程序，而JVM运行时本身也是一个程序，但是为了执行Java程序JVM还有不少辅助工作，比如进行GC、JIT编译等等。一般会把运行在JVM上的用户Java程序称为<code>mutator</code>。</p><p>在GC中，JVM中一般的GC都使用可达性分析，也就是从应用程序的一些GC Root(比如运行中的线程栈里的方法栈帧中本地变量表、操作数表中的引用、静态变量引用等)开始通过引用进行引用图遍历，如果在JVM遍历的过程中mutator也在运行，则mutator则可能会修改这个对象图的引用关系，如果JVM不对这种并发修改进行特殊处理，可能导致一些非可回收对象没有被遍历到，从而被标记成垃圾对象而被错误的回收。<br>如果要完全并发GC，JVM的实现成本会比较大，并且很多情况下整体的吞吐量是会降低的。<br>因此在很多GC收集器中都会有一些StopTheWorld阶段，这个StopTheWorld就是safepoint。在safepoint中不会有mutator操作对象，并且线程栈和heap中每个位置的数据类型也是确定的。</p><p>一个线程要么在safepoint中，要么不在safepoint中。上面提到的StopTheWorld指的是全局safepoint，也就是要求所有线程都处于safepoint状态。后面如果没有特别说明safepoint也指的是全局safepoint。</p><h2 id="SafePoint-如何实现的"><a href="#SafePoint-如何实现的" class="headerlink" title="SafePoint 如何实现的"></a>SafePoint 如何实现的</h2><p>可以这么理解，SafePoint 可以插入到代码的某些位置，每个线程运行到 SafePoint 代码时，主动去检查是否需要进入 SafePoint，这个主动检查的过程，被称为 Polling。<br>在hotspot实现中safepoint是协作式的，当JVM需要mutator进入safepoint时，会设置一个状态标记表示要进入safepoint了，每个mutator线程都会在合适的时机检查这个状态标记，如果发现需要进入safepoint则会暂停自己。</p><p>针对 SafePoint，线程有 5 种情况；假设现在有一个操作触发了某个 VM 线程所有线程需要进入 SafePoint（例如现在需要 GC），如果其他线程现在：</p><ul><li>运行字节码：运行字节码时，解释器会看线程是否被标记为 poll armed，如果是，VM 线程调用 <code>SafepointSynchronize::block(JavaThread *thread)</code>进行 block。</li><li>运行 native 代码：当运行 native 代码时，VM 线程略过这个线程，但是给这个线程设置 poll armed，让它在执行完 native 代码之后，它会检查是否 poll armed，如果还需要停在 SafePoint，则直接 block。</li><li>运行 JIT 编译好的代码：由于运行的是编译好的机器码，直接查看本地 local polling page 是否为脏，如果为脏则需要 block。这个特性是在 Java 10 引入的 JEP 312: Thread-Local Handshakes 之后，才是只用检查本地 local polling page 是否为脏就可以了。</li><li>处于 BLOCK 状态：在需要所有线程需要进入 SafePoint 的操作完成之前，不许离开 BLOCK 状态</li><li>处于线程切换状态或者处于 VM 运行状态：会一直轮询线程状态直到线程处于阻塞状态（线程肯定会变成上面说的那四种状态，变成哪个都会 block 住）。</li></ul><h2 id="如何排查safepoint相关问题"><a href="#如何排查safepoint相关问题" class="headerlink" title="如何排查safepoint相关问题"></a>如何排查safepoint相关问题</h2><p>在JVM启动参数上增加一些参数可以打印出应用暂停和safepoint相关信息。 如果版本&lt;=jdk8<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>如果版本&gt;jdk8<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-Xlog:gc*=info::time,tags,tid -Xlog:safepoint=info::time,tags,tid<br></code></pre></td></tr></table></figure></p><h2 id="深入Safepoint"><a href="#深入Safepoint" class="headerlink" title="深入Safepoint"></a>深入Safepoint</h2><p><img src="/img/Safepoint/0.png" alt="github"><br>可以看到，jvm中的每个子系统都或多或少的与安全点相关。因此在需要学会思考，编写的代码会与安全点有何关系之类的问题。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>java线程：他是jvm中线程概念的一种特殊化，是专门针对执行java代码的线程。线程本地gc根被定义为一个oop，它是指向java线程本地的java堆的指针，这里代表的java堆上对象，是可达性分析树的根。<br>可变线程状态：是一种java线程状态，特指可以改变java堆的线程状态。例如，分配对象或修改设置字段或其线程本地gc根，这种状态有时也被称为不安全状态。<br>安全点：他是一个全局JVM状态，这里的直观概念是在这个点或状态下，java世界停止了。所以他是安全的，因为所有其他应用线程停止了，这样jvm可以独占访问检查和处理。更技术性的定义是没有java线程在内部执行或可以转换到可变线程状态。技术定义的另一部分是所有java线程的线程本地gc根都可以访问或发布到JVM。<br>Safepointing作为动词，也称为stop the world，是jvm到达一个安全点的过程或者机制。并且有一个更古老的直观概念，这围绕着暂停或停止所有正在执行的java线程的过程，这对于抽象来说是可以的，但这次我们将了解到这是一种更加精细和进化的机制，它严重依赖于线程之间的协作，使用一种称为协作挂起的技术。<br>合作暂停：是一种基于轮询的技术。这意味着java线程将在VM中的指定位置检查或轮询线程本地状态。在暂停时，JVM会阻止java线程转换为可变线程状态，并且在暂停时，jvm会触发java线程从可变线程状态转换为不可变线程状态。并且由于这种转换，线程本地gc根将被发布。由于这种转换，线程本地gc根将被发布，传统上将系统带到安全点对于提供某种形式的自动内存管理的运行时来说是必要的<strong>邪恶机制</strong>。被称为如此的原因是，这是运行时延迟和不确定性的主要来源之一。<br>安全点就想轮回或苦难一样，我们想摆脱他们以达到涅槃。<br>新的衍生技术，例如线程握手和线程栈水位线，他们使得安全点机制可以更轻量级或更精细化。<br>谁需要安全点，因为某些操作因素，导致必须达到安全点才能完成任务，相反，某些操作必须在非安全点才能完成一样。</p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>java线程有一个叫做线程状态的字段（_thread_state），_thread_state的目的是跟踪java线程正在执行的代码的哪一部分。</p><p>这是java线程的状态转换：<br><img src="/img/Safepoint/2.png" alt="github"></p><ol><li>可变线程状态是一种线程可以改变java堆或其线程本地gc根的状态。</li><li>不可变线程状态是不能做这些事情的状态。</li><li>过渡状态，他们就像可变状态和不可变状态之间的桥梁。</li></ol><p>转换状态具有安全的检查或轮询指令以及适当的防护。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>看看下面的情况：<br>我们有了一个新线程，他开始在VM状态下运行。假设这个线程现在想要执行一些java代码；为了做到这一点，他需要遍历到java状态的转换；正如我们所说的状态转换包含安全点检查；这里的一些值得注意的状态转换时，处于运行java代码的状态可以在不执行安全点检查的情况下转换到状态VM和状态native，而是在线程返回状态java时执行安全点检查。<br>这里的另一个重要说明是，在native状态下执行的代码被认为是安全的，这意味着在安全点期间，java线程实际上可以继续运行native代码，这也意味着与安全点涉及阻塞或停止所有java线程的直观概念相悖。这只意味着她们不会在敏感的可变状态下执行。</p><h2 id="java线程本地gc根（Java-Thread-Local-GC-Roots）"><a href="#java线程本地gc根（Java-Thread-Local-GC-Roots）" class="headerlink" title="java线程本地gc根（Java Thread Local GC Roots）"></a>java线程本地gc根（Java Thread Local GC Roots）</h2><p>在我们将安全点定义为全局jvm状态时，所有java线程的线程本地gc根都可以访问或发不到jvm。当前所有的垃圾收集器都是跟踪型垃圾收集器，这意味着他们从所谓的根集开始跟踪可达性树，这是一组立即可以访问的oops（对象指针），是根集的一个子集，即java线程本地可访问的根集。</p><p>让我们看看这些线程本地gc根是什么</p><h3 id="本地jni句柄"><a href="#本地jni句柄" class="headerlink" title="本地jni句柄"></a>本地jni句柄</h3><p>java线程有一个成为活动句柄（_active_handles）的字段，他是一个本地jni句柄，提供给在本地状态下运行的jni代码对应的oop的间接访问，但是分配解除分配甚至取消引用jni句柄涉及首先执行vm状态，这将会执行安全点检查。本地jni句柄是自动管理的，因此，当代码从jni方法返回时，他会从进行安全点检查的状态native转换为状态java。由该方法分配的本地jni句柄被释放。</p><h3 id="句柄区域"><a href="#句柄区域" class="headerlink" title="句柄区域"></a>句柄区域</h3><p>java线程也有一个叫做句柄区域（_handle_area）的字段，句柄区域及其他伙伴句柄，提供与本地jni句柄几乎相同的间接功能，但是这些是针对在VM状态下运行的代码。<br>重要的区别是这些句柄不是自动管理的，而是必须由程序员手动管理。HandleMark用于描述句柄范围，并且HandleMark析构函数将为该特定范围是否分配的句柄，并且范围也可以嵌套。</p><h3 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h3><p>该线程还有一个内部结构体，并且有一个对应字段叫做锚（_anchor）。他由三个指针组成：</p><ul><li>_last_java_sp 表示最后一个java堆栈指针</li><li>_last_java_pc 表示最后一个java程序计数器</li><li>_last_java_fp 表示最后一个java帧指针</li></ul><p>最后一个java帧是外部遍历线程栈的入口点。我们排出JFR采集的帧。<br>如果线程在其堆栈上至少有一个java激活记录或帧，并且他当前不在状态java中，则设置他。所以处于状态java的线程在转换到其他状态之前，会设置这个锚（last java fram ljf）。<br>相反，他在线程重新进入状态java时被清除。</p><p>这里的anchor结构只需要设置_last_java_sp，因为其他字段要么与该上下文无关，要么可以通过堆栈便利代码推导出来。堆栈上的java帧可能包含普通、压缩的或派生的oops。所以，如果和之前讨论的句柄对比下，这些事裸oops，即他们没有处理引用定向，他们是直接指针。<br>ordinary指的是一般对象普通的oop；压缩oop是oop的压缩版本，他是32位大小；派生的oop是指向对象的指针，不是直接指向其对象头的。例如，我们可以考虑一个指针，他指向数组中的一个元素，派生oop始终与基址相关，对于java中的特定代码位置，对于像是代表特定的代码位置的程序计数器，堆栈槽和寄存器包含相对于该程序计数器的oops，是由编译器生成的一段元数据描述的，是叫做OopMap的一个东西。为了精确定位帧中的oop，OopMap使用栈指针的相对地址或RegisterMap的索引的相对地址来描述位置。<br>并非所有代码代码位置都有OopMap，他们主要与调用点和安全点轮询页面指令相关联。对于堆栈遍历，每帧的返回地址将于一个OopMap相关联。</p><h3 id="java线程-CPU上下文"><a href="#java线程-CPU上下文" class="headerlink" title="java线程 CPU上下文"></a>java线程 CPU上下文</h3><p>执行java代码的线程也有一个cpu上下文，并且根据调用约定和出于性能原因，理想情况下，oops由寄存器分配器直接放入寄存器中。<br>Hotspot广泛使用称为Stubs或StubRoutines的东西，他们是特定于平台的特殊程序集帮助程序。<br>Stub的一个重要特性就是在线程暂停他的工作让出CPU的时候保存CPU上下文，并且在线程回归之行的时候恢复CPU上下文，在某种程度上类似于上下文切换。</p><p>RegisterMap用于将oop映射描述的位置解析为寄存器，还有一些线程本地gc根。</p><p>例如潜在的未决异常和一些与jvmti相关的状态。</p><h1 id="将系统带到安全点的过程"><a href="#将系统带到安全点的过程" class="headerlink" title="将系统带到安全点的过程"></a>将系统带到安全点的过程</h1><h2 id="VMThread-is-the-coordinator"><a href="#VMThread-is-the-coordinator" class="headerlink" title="VMThread is the coordinator"></a>VMThread is the coordinator</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> VMThread::loop() &#123;<br>    ...<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (should_terminate()) <span class="hljs-keyword">break</span>;<br>        wait_for_operation();<br>        <span class="hljs-keyword">if</span> (should_terminate()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">assert</span>(_next_vm_operation != NULL, <span class="hljs-string">&quot;Must have one&quot;</span>);<br>        inner_execute(_next_vm_operation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该过程由从VMThread请求安全点操作的客户端启动，它通过将VM_Operation类型的对象排入队列并将其属性evaluate_at_safepoint()设置为true来实现。<br>VMThread将等待出队并启动安全点过程以服务提交的请求。</p><h2 id="VMThread-SafepointSynchronize-begin"><a href="#VMThread-SafepointSynchronize-begin" class="headerlink" title="VMThread - SafepointSynchronize::begin()"></a>VMThread - SafepointSynchronize::begin()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> SafepointSynchronize::begin() &#123;<br>    <span class="hljs-keyword">assert</span>(Thread::current()-&gt;is_VM_thread(), <span class="hljs-string">&quot;Only VM thread may execute a safepoint&quot;</span>);<br>    <br>    Threads_lock-&gt;lock();<br>    <span class="hljs-keyword">assert</span>(_state == _not_synchronized, <span class="hljs-string">&quot;trying to safepoint synchronize with wrong state&quot;</span>);<br>    <span class="hljs-keyword">int</span> nof_threads = Threads::number_of_threads();<br>    ...<br>    arm_safepoint();<br>    <br>    <span class="hljs-keyword">int</span> iterations = synchronize_threads(safepoint_limit_time, nof_threads, &amp;initial_running);<br>    <span class="hljs-keyword">assert</span>(_waiting_to_block == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;No thread should be running&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是VMThread运行的第一部分。他由三个部分组成：</p><ol><li><strong>组装</strong>java线程</li><li>同步，即等待所有java线程</li><li>当所有线程都被认为是安全的，即已经到达全局jvm安全点状态时，VMThread运行提交的操作</li></ol><p>首先看看组装部分</p><h3 id="VMThread-arm-safepoint"><a href="#VMThread-arm-safepoint" class="headerlink" title="VMThread - arm_safepoint()"></a>VMThread - arm_safepoint()</h3><p>java线程有一个嵌入的结构体。<br>_poll_data字段，由两个指针组成_polling_word和_polling_page。arming本质上意味着VMThread更改了安全点检查中使用的所谓轮询页面的内存保护。并且他从内存保护状态PAGE_READONLY更改为PAGE_NOACCESS。<br>这里VMThread大致完成了封装了java线程的内存页，它有效的删除了线程转换到任何红色不安全可变状态的能力。他切换了从蓝色到红色的所有链接。这意味着，VMThread通过这个进程所做的事情现在状态机制被替换成了一个临时的状态机制。</p><p>然而，这只是合作暂停的一部分。之前说的是，JVM阻止了java线程转变到被归类为可变的线程状态。</p><p>定义的第二部分是JVM触发java线程从可变状态为不可变状态。作为这个转换线程的结果，本地gc根被发布。<br>如何确保那些已经在可变状态下运行的线程变为不可变状态，对于在VM状态下运行的线程，他需要等待，知道线程自己执行转换。在VM状态中只有少数地方显式滴执行安全点检查。例如当争用VM下的互斥锁或监视器时。<br>这种设计的前提是java线程应该在状态VM中话费尽可能少的时间。</p><p>但是在状态Java中运行的现场就不一样了。<br>我们不能像在状态VM中那样，等待状态Java中的线程自行过渡。例如，一个线程可以执行无限循环，这是完全合法的，在这种情况下，JVM永远不会到达安全点。因此，要解决这个问题，需要有一种适当的机制来疏散或推出当前运行java代码的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (n == first) &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">int</span> second = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (scond == n) &#123;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>    <span class="hljs-keyword">int</span> nth = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        nth = getSuccressor(first, second);<br>        first = second;<br>        second = nth;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nth;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuccressor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> second)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码完成斐波那契数列，实现版本迭代。<br>但是在了解到细节时，最好谈谈x64调用约定或应用程序二进制接口，以及Hotspot Java调用约定以及他们之间的关系。<br>windows平台ABI按顺序在寄存器中传递前四个参数，其余的按从右到左（RTL）的顺序在堆栈上传递。还有32个字节的影子栈区域需要由调用者分配。System V ABI定义了参数在这六个寄存器中传递。而其余的也从右到左在堆栈上传递。<br>在栈下面有一个128字节的红色区域，Hotspot java调用约定定义了6个寄存器，用于在windows平台上参数传递，其余的从右到左在堆栈上传递，有一个自定义版本的堆栈保护，这只适用于System V平台。<br>对于所有这些，栈需要在16字节的边界上对齐。如果仔细观察，就会发现Hotspot java调用约定是平台ABI的一个移位或旋转版本，这种移位或旋转是因为通过跳过第一个ABI寄存器，我们可以调用非静态jni方法，而不必打乱参数。<br>相反，我们只将jni结束指针直接放在第一个ABI寄存器中。大多数寄存器都被认为是易失的，即调用方必须在调用过程中保留寄存器。除了RBP寄存器，是被调用的保存，如果存在压缩oops，R12就会保存java堆基址，而R15寄存器保存当前线程。所以这些寄存器可以被认为是常数。</p><p>JIT编译器在常规代码流中插入了安全点检查或轮询指令，他由两个指令组成：<br>第一个是从驻留在r15中的java线程加载轮询页面指针，然后执行一个test，解除轮询页面引用。除了在代码流中插入safepoint检查指令之外，JIT还确保这里的测试指令具有关联的OopMap，但对于这个特定的例子，这个特定的OopMap是空的。原因是，这段代码并没有真正使用任何java对象，因为他是一个静态方法，他没有接受对象，而且他只用了java原始类型。<br><img src="/img/Safepoint/3.png" alt="github"><br>Safepoint检查由编译器插入到循环头中，就像这里这样，以便捕获长时间运行的循环，并且在方法返回之前。</p><p>让我们看一下被调用的方法getSuccessor<br><img src="/img/Safepoint/4.png" alt="github"><br>这里可以看到安全点检查指令有点不同，这是一个cmp，而不是一个test，这是安全点检查的一个更优化版本。这与衍生技术如跨线程握手和线程水位线有关。不幸的事，这个版本不能应用于所有上下文中，后面会知道为什么在不同情况下需要不同的轮询指令。<br>在这段代码中，safepoint检查比较指令没有关联的OopMap，这是为什么？这是因为在方法末尾的safepoint调用指令是在栈帧出栈之后，但在返回指令之前插入的。这意味着调用者的返沪指令位于栈的顶部，通过表示一个调用点，他有一个关联的OopMap。<br>如果我们返回调用方，我们可以看到安全点检查，这是一个test指令，尝试解除对她从r15（java线程位于寄存器r15中）加载的轮询页面的引用。但是如果VMThread封装了轮询页面，即它将内存保护从PAGE_READONLY更改为PAGE_NO_ACCESS。<br>硬件将报非发访问或者segmentation fault，这又会通知操作系统，反过来通知寄存器信号或异常处理程序。Hotspot JVM将向各自的操作系统注册新号处理程序，以获取有关此事件的通知。利用硬件和操作系统提供的信息，我们可以确定发生了什么，所以在这个例子中，这是非法访问或者segmentation fault，并且还提供了有关哪个指令导致他的信息，内存地址。<br>所以在信号处理程序内部，我们可以确定内存地址是安全点轮询页面，所以我们知道这种非法访问或者segmentation fault并不是真正的崩溃，但它与合作暂停有关。<br>我们保存被困在名为saved_exception_pc的java线程字段中的指令，操作系统还为我们提供了处于trap时的状态和cpu上下文，我们可以在信号处理程序中重写cpu上下文，也就是说我们可以修改指令指针（IP），而不是指向捕获他的原始java代码，而是指向特定的StubRoutine。<br>当线程在展开所有异常处理程序后恢复时，操作系统重新加载这个现在修改的cpu上下文，并且线程继续在指定的StubRoutine中运行，而不是在原来的java代码中运行。</p><p>看一下Hotspot StubRoutine的代表性实例<br><img src="/img/Safepoint/5.png" alt="github"><br>这个叫做StubRoutineBlob，代表了汇编代码。</p><ol><li>我们说在循环中间进行曲折进给，这意味着栈上没有正确的返回地址，所以我们要解决这个问题，所以我吗需要为他分配一个槽。</li><li>这里很重要，我们正在栈上建立一个新栈帧，一个与java代码本身没有直接关系的对象，而是一个元对象。并且因为jvm是java语言的元理论的实现，可以看到很多这些元结构与真正的java代码混合在一起，所以让我们称这个对象为合成帧或者Stub帧来表示这种差异。</li><li>rflags寄存器被推入栈</li><li>如果还记得调用约定，说过堆栈需要在16字节边界上对齐</li><li>然后将cpu上下文的通用寄存器溢出到栈上</li><li>此处浮点寄存器也被溢出，如果查看这些Stub帧的大小，会发现她们非常大，例如此帧大小为360个字或近3000个字节，而这样做的原因当然是大部分cpu上下文都溢出了</li><li>如果记得在信号处理程序中，我们保存了错误指令的地址，我们现在将这个地址写入我们一开始分配的栈槽，我们这样做是为了让他成为返回地址，这样做的原因不仅仅是为了以后能够返回到代码中断的地方，更重要的是，test指令有一个关联的OopMap，并且在安全点期间，栈必须具有所有返回地址的OopMaps，而StubRoutines发挥的另一个重要的作用是在java ABI和特定平台ABI之间切换，这也是为什么这些Stub帧是平台特定的原因。</li><li>可以看到，因为我吗即将调用进入JVM，改掉用需要在此处添加到平台ABI的调用，对于这个例子在windows上，首先需要分配一个32字节的栈空间，然后将线程作为rcx中的第一个参数传递</li><li>在我们对安全点定义中，说过所有java线程的线程本地gc根都可以访问或发布到jvm，并且详细说明了_last_java_frame是发布到jvm的重要部分，因为它提供了遍历栈的入口点，其cpu上下文的一部分，直接在寄存器中，因此出现了一个棘手的问题，即如何使线程的cpu上下文可访问或发布到jvm以使其到达安全点，答案是使用Stub帧提供解决方案，通过将cpu上下文溢出到栈中，进入这些Stub帧之一，她看起来就像一个常规帧。cpu上下被塑造成一个栈帧。</li><li>所以确实可以在这里看到_last_java_frame或锚字段将被设置为指向Stub帧而不是真正的java代码帧</li><li>重要的方面也是这些合成Stub帧也有OopMaps，这个特定的OopMap将详细说明每个寄存器在堆栈上的位置，OopMap的值类型表示栈位置，确实属于调用者帧，这里是fibonacci方法，之前提到了一个RegisterMap，其中也会填充那些Stub帧中的位置信息，并与调用者中的OopMap一起，即fibonacci方法的OopMap，表示放在寄存器中的oops可以被解析出</li></ol><h3 id="SafepointSynchronize-block"><a href="#SafepointSynchronize-block" class="headerlink" title="SafepointSynchronize::block()"></a>SafepointSynchronize::block()</h3><p>所以负责将这个特定线程的cpu上下文和堆栈导出到VM。当我们最终进入VM操作的时候，将java线程的线程状态字段设置为阻塞，连同Full Fence完全内存屏障指令，这对于线程本地gc根可见或发不到VM非常重要。线程现在将等待全局信号量，在VM线程运行VM操作之后，她发出信号量以及当线程恢复的时候，他将解除自己的轮询页并从中断的地方继续执行。<br><img src="/img/Safepoint/6.png" alt="github"></p><p>至此，关于Hotspot JVM中的安全点到此结束。<br>Safepoint 可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，线程可以暂停。在 SafePoint 保存了其他位置没有的一些当前线程的运行信息，供其他线程读取。这些信息包括：线程上下文的任何信息，例如对象或者非对象的内部指针等等。我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息，才是确定的，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候，才会感知。</p>]]></content>
    
    
    <summary type="html">JVM—SafePoint</summary>
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码指令大全</title>
    <link href="http://example.com/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-05-11T10:21:38.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0X01</td><td>aconst_null</td><td></td><td>null值入栈</td></tr><tr><td>0X02</td><td>iconst_m1</td><td></td><td>-1(int)值入栈</td></tr><tr><td>0X03</td><td>iconst_0</td><td></td><td>0(int)值入栈</td></tr><tr><td>0X04</td><td>iconst_1</td><td></td><td>1(int)值入栈</td></tr><tr><td>0X05</td><td>iconst_2</td><td></td><td>2(int)值入栈</td></tr><tr><td>0X06</td><td>iconst_3</td><td></td><td>3(int)值入栈</td></tr><tr><td>0X07</td><td>iconst_4</td><td></td><td>4(int)值入栈</td></tr><tr><td>0X08</td><td>iconst_5</td><td></td><td>5(int)值入栈</td></tr><tr><td>0X09</td><td>lconst_0</td><td></td><td>0(long)值入栈</td></tr><tr><td>0X0a</td><td>lconst_1</td><td></td><td>1(long)值入栈</td></tr><tr><td>0X0b</td><td>fconst_0</td><td></td><td>0(float)值入栈</td></tr><tr><td>0X0c</td><td>fconst_1</td><td></td><td>1(float)值入栈</td></tr><tr><td>0X0d</td><td>fconst_2</td><td></td><td>2(float)值入栈</td></tr><tr><td>0X0e</td><td>dconst_0</td><td></td><td>0(double)值入栈</td></tr><tr><td>0X0f</td><td>dconst_1</td><td></td><td>1(double)值入栈</td></tr><tr><td>0X10</td><td>bipush</td><td>valuebyte</td><td>valuebyte值带符号扩展成int值入栈</td></tr><tr><td>0X11</td><td>sipush</td><td>valuebyte1、valuebyte2(valuebyte1 &lt;&lt; 8)</td><td>valuebyte2 值带符号扩展成int值入栈</td></tr><tr><td>0X12</td><td>ldc</td><td>indexbyte1</td><td>常量池中的常量值（int, float, string reference, object reference）入栈</td></tr><tr><td>0X13</td><td>ldc_w</td><td>indexbyte1、indexbyte2</td><td>常量池中常量（int, float, string reference, object reference）入栈</td></tr><tr><td>0X14</td><td>ldc2_w</td><td>indexbyte1、indexbyte2</td><td>常量池中常量（long, double）入栈</td></tr></tbody></table></div><h2 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0X19</td><td>(wide)aload</td><td>indexbyte</td><td>从局部变量indexbyte中装载引用类型值入栈</td></tr><tr><td>0X2a</td><td>aload_0</td><td></td><td>从局部变量0中装载引用类型值入栈</td></tr><tr><td>0X2b</td><td>aload_1</td><td></td><td>从局部变量1中装载引用类型值入栈</td></tr><tr><td>0X2c</td><td>aload_2</td><td></td><td>从局部变量2中装载引用类型值入栈</td></tr><tr><td>0X2d</td><td>aload_3</td><td></td><td>从局部变量3中装载引用类型值入栈</td></tr><tr><td>0X15</td><td>(wide)iload</td><td>indexbyte</td><td>从局部变量indexbyte中装载int类型值入栈</td></tr><tr><td>0X1a</td><td>iload_0</td><td></td><td>从局部变量0中装载int类型值入栈</td></tr><tr><td>0X1b</td><td>iload_1</td><td></td><td>从局部变量1中装载int类型值入栈</td></tr><tr><td>0X1c</td><td>iload_2</td><td></td><td>从局部变量2中装载int类型值入栈</td></tr><tr><td>0X1d</td><td>iload_3</td><td></td><td>从局部变量3中装载int类型值入栈</td></tr><tr><td>0X16</td><td>(wide)lload</td><td>indexbyte</td><td>从局部变量indexbyte中装载long类型值入栈</td></tr><tr><td>0X1e</td><td>lload_0</td><td></td><td>从局部变量0中装载int类型值入栈</td></tr><tr><td>0X1f</td><td>lload_1</td><td></td><td>从局部变量1中装载int类型值入栈</td></tr><tr><td>0X20</td><td>lload_2</td><td></td><td>从局部变量2中装载int类型值入栈</td></tr><tr><td>0X21</td><td>lload_3</td><td></td><td>从局部变量3中装载int类型值入栈</td></tr><tr><td>0X17</td><td>(wide)fload</td><td>indexbyte</td><td>从局部变量indexbyte中装载float类型值入栈</td></tr><tr><td>0X22</td><td>fload_0</td><td></td><td>从局部变量0中装载float类型值入栈</td></tr><tr><td>0X23</td><td>fload_1</td><td></td><td>从局部变量1中装载float类型值入栈</td></tr><tr><td>0X24</td><td>fload_2</td><td></td><td>从局部变量2中装载float类型值入栈</td></tr><tr><td>0X25</td><td>fload_3</td><td></td><td>从局部变量3中装载float类型值入栈</td></tr><tr><td>0X18</td><td>(wide)dload</td><td>indexbyte</td><td>从局部变量indexbyte中装载double类型值入栈</td></tr><tr><td>0X26</td><td>dload_0</td><td></td><td>从局部变量0中装载double类型值入栈</td></tr><tr><td>0X27</td><td>dload_1</td><td></td><td>从局部变量1中装载double类型值入栈</td></tr><tr><td>0X28</td><td>dload_2</td><td></td><td>从局部变量2中装载double类型值入栈</td></tr><tr><td>0X29</td><td>dload_3</td><td></td><td>从局部变量3中装载double类型值入栈</td></tr><tr><td>0X32</td><td>aaload</td><td></td><td>从引用类型数组中装载指定项的值</td></tr><tr><td>0X2e</td><td>iaload</td><td></td><td>从int类型数组中装载指定项的值</td></tr><tr><td>0X2f</td><td>laload</td><td></td><td>从long类型数组中装载指定项的值</td></tr><tr><td>0X30</td><td>faload</td><td></td><td>从float类型数组中装载指定项的值</td></tr><tr><td>0X31</td><td>daload</td><td></td><td>从double类型数组中装载指定项的值</td></tr><tr><td>0X33</td><td>baload</td><td></td><td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）</td></tr><tr><td>0X34</td><td>caload</td><td></td><td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）</td></tr><tr><td>0X35</td><td>saload</td><td></td><td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）</td></tr></tbody></table></div><h2 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0X3a</td><td>(wide)astore</td><td>indexbyte</td><td>将栈顶引用类型值保存到局部变量indexbyte中</td></tr><tr><td>0X4b</td><td>astroe_0</td><td></td><td>将栈顶引用类型值保存到局部变量0中</td></tr><tr><td>0X4c</td><td>astroe_1</td><td></td><td>将栈顶引用类型值保存到局部变量1中</td></tr><tr><td>0X4d</td><td>astroe_2</td><td></td><td>将栈顶引用类型值保存到局部变量2中</td></tr><tr><td>0X4e</td><td>astroe_3</td><td></td><td>将栈顶引用类型值保存到局部变量3中</td></tr><tr><td>0X36</td><td>(wide)istore</td><td>indexbyte</td><td>将栈顶int类型值保存到局部变量indexbyte中</td></tr><tr><td>0X3b</td><td>istroe_0</td><td></td><td>将栈顶int类型值保存到局部变量0中</td></tr><tr><td>0X3c</td><td>istroe_1</td><td></td><td>将栈顶int类型值保存到局部变量1中</td></tr><tr><td>0X3d</td><td>istroe_2</td><td></td><td>将栈顶int类型值保存到局部变量2中</td></tr><tr><td>0X3e</td><td>istroe_3</td><td></td><td>将栈顶int类型值保存到局部变量3中</td></tr><tr><td>0X37</td><td>(wide)lstore</td><td>indexbyte</td><td>将栈顶long类型值保存到局部变量indexbyte中</td></tr><tr><td>0X3f</td><td>lstroe_0</td><td></td><td>将栈顶long类型值保存到局部变量0中</td></tr><tr><td>0X40</td><td>lstroe_1</td><td></td><td>将栈顶long类型值保存到局部变量1中</td></tr><tr><td>0X41</td><td>lstroe_2</td><td></td><td>将栈顶long类型值保存到局部变量2中</td></tr><tr><td>0X42</td><td>lstroe_3</td><td></td><td>将栈顶long类型值保存到局部变量3中</td></tr><tr><td>0X38</td><td>(wide)fstore</td><td>indexbyte</td><td>将栈顶float类型值保存到局部变量indexbyte中</td></tr><tr><td>0X43</td><td>fstroe_0</td><td></td><td>将栈顶float类型值保存到局部变量0中</td></tr><tr><td>0X44</td><td>fstroe_1</td><td></td><td>将栈顶float类型值保存到局部变量1中</td></tr><tr><td>0X45</td><td>fstroe_2</td><td></td><td>将栈顶float类型值保存到局部变量2中</td></tr><tr><td>0X46</td><td>fstroe_3</td><td></td><td>将栈顶float类型值保存到局部变量3中</td></tr><tr><td>0X39</td><td>(wide)dstore</td><td>indexbyte</td><td>将栈顶double类型值保存到局部变量indexbyte中</td></tr><tr><td>0X47</td><td>dstroe_0</td><td></td><td>将栈顶double类型值保存到局部变量0中</td></tr><tr><td>0X48</td><td>dstroe_1</td><td></td><td>将栈顶double类型值保存到局部变量1中</td></tr><tr><td>0X49</td><td>dstroe_2</td><td></td><td>将栈顶double类型值保存到局部变量2中</td></tr><tr><td>0X4a</td><td>dstroe_3</td><td></td><td>将栈顶double类型值保存到局部变量3中</td></tr><tr><td>0X53</td><td>aastore</td><td></td><td>将栈顶引用类型值保存到指定引用类型数组的指定项</td></tr><tr><td>0X4f</td><td>iastore</td><td></td><td>将栈顶int类型值保存到指定int类型数组的指定项</td></tr><tr><td>0X50</td><td>lastore</td><td></td><td>将栈顶long类型值保存到指定long类型数组的指定项</td></tr><tr><td>0X51</td><td>fastore</td><td></td><td>将栈顶float类型值保存到指定float类型数组的指定项</td></tr><tr><td>0X52</td><td>dastore</td><td></td><td>将栈顶double类型值保存到指定double类型数组的指定项</td></tr><tr><td>0X54</td><td>bastore</td><td></td><td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项</td></tr><tr><td>0X55</td><td>castore</td><td></td><td>将栈顶char类型值保存到指定char类型数组的指定项</td></tr><tr><td>0X56</td><td>sastore</td><td></td><td>将栈顶short类型值保存到指定short类型数组的指定项</td></tr></tbody></table></div><h2 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0Xc4</td><td>wide</td><td></td><td>使用附加字节扩展局部变量索引（iinc指令特殊）</td></tr></tbody></table></div><h2 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td></td><td>空操作。</td></tr><tr><td>0x57</td><td>pop</td><td></td><td>从栈顶弹出一个字长的数据。</td></tr><tr><td>0x58</td><td>pop2</td><td></td><td>从栈顶弹出两个字长的数据。</td></tr><tr><td>0x59</td><td>dup</td><td></td><td>复制栈顶一个字长的数据，将复制后的数据压栈。</td></tr><tr><td>0x5a</td><td>dup_x1</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td></tr><tr><td>0x5b</td><td>dup_x2</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5c</td><td>dup2</td><td></td><td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td></tr><tr><td>0x5f</td><td>swap</td><td></td><td>交换栈顶两个字长的数据的位置。Java指令中没有提供以两个字长为单位的交换指令。</td></tr></tbody></table></div><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x86</td><td>i2f</td><td></td><td>将栈顶int类型值转换为float类型值。</td></tr><tr><td>0x85</td><td>i2l</td><td></td><td>将栈顶int类型值转换为long类型值。</td></tr><tr><td>0x87</td><td>i2d</td><td></td><td>将栈顶int类型值转换为double类型值。</td></tr><tr><td>0x8b</td><td>f2i</td><td></td><td>将栈顶float类型值转换为int类型值。</td></tr><tr><td>0x8c</td><td>f2l</td><td></td><td>将栈顶float类型值转换为long类型值。</td></tr><tr><td>0x8d</td><td>f2d</td><td></td><td>将栈顶float类型值转换为double类型值。</td></tr><tr><td>0x88</td><td>l2i</td><td></td><td>将栈顶long类型值转换为int类型值。</td></tr><tr><td>0x89</td><td>l2f</td><td></td><td>将栈顶long类型值转换为float类型值。</td></tr><tr><td>0x8a</td><td>l2d</td><td></td><td>将栈顶long类型值转换double类型值。</td></tr><tr><td>0x8e</td><td>d2i</td><td></td><td>将栈顶double类型值转换为int类型值。</td></tr><tr><td>0x90</td><td>d2f</td><td></td><td>将栈顶double类型值转换为float类型值。</td></tr><tr><td>0x8f</td><td>d2l</td><td></td><td>将栈顶double类型值转换为long类型值。</td></tr><tr><td>0x91</td><td>i2b</td><td></td><td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x92</td><td>i2c</td><td></td><td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x93</td><td>i2s</td><td></td><td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td></tr></tbody></table></div><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x60</td><td>iadd</td><td></td><td>将栈顶两int类型数相加，结果入栈。</td></tr><tr><td>0x64</td><td>isub</td><td></td><td>将栈顶两int类型数相减，结果入栈。</td></tr><tr><td>0x68</td><td>imul</td><td></td><td>将栈顶两int类型数相乘，结果入栈。</td></tr><tr><td>0x6c</td><td>idiv</td><td></td><td>将栈顶两int类型数相除，结果入栈。</td></tr><tr><td>0x70</td><td>irem</td><td></td><td>将栈顶两int类型数取模，结果入栈。</td></tr><tr><td>0x74</td><td>ineg</td><td></td><td>将栈顶int类型值取负，结果入栈。</td></tr><tr><td>0x61</td><td>ladd</td><td></td><td>将栈顶两long类型数相加，结果入栈。</td></tr><tr><td>0x65</td><td>lsub</td><td></td><td>将栈顶两long类型数相减，结果入栈。</td></tr><tr><td>0x69</td><td>lmul</td><td></td><td>将栈顶两long类型数相乘，结果入栈。</td></tr><tr><td>0x6d</td><td>idiv</td><td></td><td>将栈顶两long类型数相除，结果入栈。</td></tr><tr><td>0x71</td><td>lrem</td><td></td><td>将栈顶两long类型数取模，结果入栈。</td></tr><tr><td>0x75</td><td>lneg</td><td></td><td>将栈顶long类型值取负，结果入栈。</td></tr><tr><td>0x84</td><td>(wide)iinc</td><td>indexbyte constbyte</td><td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td></tr></tbody></table></div><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x62</td><td>fadd</td><td></td><td>将栈顶两float类型数相加，结果入栈。</td></tr><tr><td>0x66</td><td>fsub</td><td></td><td>将栈顶两float类型数相减，结果入栈。</td></tr><tr><td>0x6a</td><td>fmul</td><td></td><td>将栈顶两float类型数相乘，结果入栈。</td></tr><tr><td>0x6e</td><td>fdiv</td><td></td><td>将栈顶两float类型数相除，结果入栈。</td></tr><tr><td>0x72</td><td>frem</td><td></td><td>将栈顶两float类型数取模，结果入栈。</td></tr><tr><td>0x76</td><td>fneg</td><td></td><td>将栈顶float类型值取反，结果入栈。</td></tr><tr><td>0x63</td><td>dadd</td><td></td><td>将栈顶两double类型数相加，结果入栈。</td></tr><tr><td>0x67</td><td>dsub</td><td></td><td>将栈顶两double类型数相减，结果入栈。</td></tr><tr><td>0x6b</td><td>dmul</td><td></td><td>将栈顶两double类型数相乘，结果入栈。</td></tr><tr><td>0x6f</td><td>ddiv</td><td></td><td>将栈顶两double类型数相除，结果入栈。</td></tr><tr><td>0x73</td><td>drem</td><td></td><td>将栈顶两double类型数取模，结果入栈。</td></tr><tr><td>0x77</td><td>dneg</td><td></td><td>将栈顶double类型值取负，结果入栈。</td></tr></tbody></table></div><h2 id="逻辑运算——移位运算"><a href="#逻辑运算——移位运算" class="headerlink" title="逻辑运算——移位运算"></a>逻辑运算——移位运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x78</td><td>ishl</td><td></td><td>左移int类型值。</td></tr><tr><td>0x79</td><td>lshl</td><td></td><td>左移long类型值。</td></tr><tr><td>0x7a</td><td>ishr</td><td></td><td>算术右移int类型值。</td></tr><tr><td>0x7b</td><td>lshr</td><td></td><td>算术右移long类型值。</td></tr><tr><td>0x7c</td><td>iushr</td><td></td><td>逻辑右移int类型值。</td></tr><tr><td>0x7d</td><td>lushr</td><td></td><td>逻辑右移long类型值。</td></tr></tbody></table></div><h2 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x73</td><td>iand</td><td></td><td>对int类型按位与运算。</td></tr><tr><td>0x7f</td><td>land</td><td></td><td>对long类型的按位与运算。</td></tr><tr><td>0x80</td><td>ior</td><td></td><td>对int类型的按位或运算。</td></tr><tr><td>0x81</td><td>lor</td><td></td><td>对long类型的按位或运算。</td></tr><tr><td>0x82</td><td>ixor</td><td></td><td>对int类型的按位异或运算。</td></tr><tr><td>0x83</td><td>lxor</td><td></td><td>对long类型的按位异或运算。</td></tr></tbody></table></div><h2 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值为0则跳转。</td></tr><tr><td>0x9a</td><td>ifne</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值不为0则跳转。</td></tr><tr><td>0x9b</td><td>iflt</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值小于0则跳转。</td></tr><tr><td>0x9e</td><td>ifle</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值小于等于0则跳转。</td></tr><tr><td>0x9d</td><td>ifgt</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值大于0则跳转。</td></tr><tr><td>0x9c</td><td>ifge</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值大于等于0则跳转。</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值相等则跳转。</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值不相等则跳转。</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前小于后则跳转。</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前小于等于后则跳转。</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前大于后则跳转。</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前大于等于后则跳转。</td></tr><tr><td>0xc6</td><td>ifnull</td><td>branchbyte1 branchbyte2</td><td>若栈顶引用值为null则跳转。</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>branchbyte1 branchbyte2</td><td>若栈顶引用值不为null则跳转。</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>branchbyte1 branchbyte2</td><td>若栈顶两引用类型值相等则跳转。</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>branchbyte1 branchbyte2</td><td>若栈顶两引用类型值不相等则跳转。</td></tr></tbody></table></div><h2 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x94</td><td>lcmp</td><td></td><td>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</td></tr><tr><td>0x95</td><td>fcmpl</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x96</td><td>fcmpg</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x97</td><td>dcmpl</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x98</td><td>dcmpg</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr></tbody></table></div><h2 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xa7</td><td>goto</td><td>branchbyte1 branchbyte2</td><td>无条件跳转到指定位置。</td></tr><tr><td>0xc8</td><td>goto_w</td><td>branchbyte1 branchbyte2 branchbyte3 branchbyte4</td><td>无条件跳转到指定位置（宽索引）。</td></tr></tbody></table></div><h2 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xaa</td><td>tableswitch</td><td>defaultbyte1-4 lowbyte1-4 highbyte1-4 jump offsets…</td><td>通过索引访问跳转表，并跳转。</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>defaultbyte1-4 npairs1-4 matcj offsets…</td><td>通过键值访问跳转表，并跳转。</td></tr></tbody></table></div><h2 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbf</td><td>athrow</td><td></td><td>抛出异常。</td></tr><tr><td>0xa8</td><td>jsr</td><td>branchbyte1 branchbyte2</td><td>跳转到子例程序。</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>branchbyte-4</td><td>跳转到子例程序（宽索引）。</td></tr><tr><td>0xa9</td><td>(wide)ret</td><td>indexbyte</td><td>返回子例程序。</td></tr></tbody></table></div><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbb</td><td>new</td><td>indexbyte1 indexbyte2</td><td>创建新的对象实例。</td></tr><tr><td>0xc0</td><td>checkcast</td><td>indexbyte1 indexbyte2</td><td>类型强转。</td></tr><tr><td>0xc1</td><td>instanceof</td><td>indexbyte1 indexbyte2</td><td>判断类型。</td></tr><tr><td>0xb4</td><td>getfield</td><td>indexbyte1 indexbyte2</td><td>获取对象字段的值。</td></tr><tr><td>0xb5</td><td>putfield</td><td>indexbyte1 indexbyte2</td><td>给对象字段赋值。</td></tr><tr><td>0xb2</td><td>getstatic</td><td>indexbyte1 indexbyte2</td><td>获取静态字段的值。</td></tr><tr><td>0xb3</td><td>putstatic</td><td>indexbyte1 indexbyte2</td><td>给静态字段赋值。</td></tr></tbody></table></div><h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbc</td><td>newarray</td><td>atype</td><td>创建type类型的数组。</td></tr><tr><td>0xbd</td><td>anewarray</td><td>indexbyte1 indexbyte2</td><td>创建引用类型的数组。</td></tr><tr><td>0xbe</td><td>arraylength</td><td></td><td>获取一维数组的长度。</td></tr><tr><td>0xbe</td><td>multianewarray</td><td>indexbyte1 indexbyte2 dimension</td><td>创建dimension维度的数组。</td></tr></tbody></table></div><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xb7</td><td>invokespecial</td><td>indexbyte1 indexbyte2</td><td>编译时方法绑定调用方法。</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>indexbyte1 indexbyte2</td><td>运行时方法绑定调用方法。</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>indexbyte1 indexbyte2</td><td>调用静态方法。</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>indexbyte1 indexbyte2 count 0</td><td>调用接口方法。</td></tr></tbody></table></div><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xac</td><td>ireturn</td><td></td><td>返回int类型值。</td></tr><tr><td>0xad</td><td>lreturn</td><td></td><td>返回long类型值。</td></tr><tr><td>0xae</td><td>freturn</td><td></td><td>返回float类型值。</td></tr><tr><td>0xaf</td><td>dreturn</td><td></td><td>返回double类型值。</td></tr><tr><td>0xb0</td><td>areturn</td><td></td><td>返回引用类型值。</td></tr><tr><td>0xb1</td><td>return</td><td></td><td>void函数返回。</td></tr></tbody></table></div><h2 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc2</td><td>monitorenter</td><td></td><td>进入并获得对象监视器。</td></tr><tr><td>0xc3</td><td>monitorexit</td><td></td><td>释放并退出对象监视器。</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">Java字节码指令大全</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java锁</title>
    <link href="http://example.com/2023/03/15/java%E9%94%81/"/>
    <id>http://example.com/2023/03/15/java%E9%94%81/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-04-26T05:00:16.249Z</updated>
    
    <content type="html"><![CDATA[<p>Java中常见锁分为两种：一种是<code>Synchronized</code>修饰的锁；另一种就是<code>java.util.concurrent</code>包下的各种同步锁，他们基于<code>AbstractQueuedSynchronizer（AQS）框架来构建的</code>，而<code>AQS</code>的核心数据结构是<code>CLH锁</code>的变体。</p><h2 id="一、无锁、偏向锁、轻量级锁和重量级锁"><a href="#一、无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="一、无锁、偏向锁、轻量级锁和重量级锁"></a>一、无锁、偏向锁、轻量级锁和重量级锁</h2><p>Synchronized 锁的底层类别</p><div class="table-container"><table><thead><tr><th>所状态</th><th>存储内容</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td>01</td><td></td></tr><tr><td>偏向锁</td><td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td>01</td><td></td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td><td></td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>10</td><td></td></tr></tbody></table></div><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。<br><strong><em>在jdk1.6之前，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，这种方式就是synchronized最初实现同步的方式（依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步），synchronized 是重量级锁，效率低下。</em></strong></p><p>在jvm中，对象在内存中除了本身的数据外还会有个对象头，其对象头中有两类信息：<code>mark word</code>和<code>类型指针</code>；另外对于数组而言还会有一份记录数组长度的数据。类型指针是指向该对象所属类对象的指针，mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32bit，64位系统上长度为64bit。<br><img src="/img/JavaLock/0.png" alt="github"><br>表格中可以看到存储数据格式会随着锁的不同而不同。<br>当对象状态为偏向锁时，mark word存储的是偏向的线程ID；当状态为轻量级锁时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁时，为指向堆中的monitor对象的指针。</p><h2 id="1-1-全局安全点（safepoint）"><a href="#1-1-全局安全点（safepoint）" class="headerlink" title="1.1 全局安全点（safepoint）"></a>1.1 全局安全点（safepoint）</h2><p>代表了一个状态，在该状态下所有线程都是暂停的。</p><h2 id="1-2-偏向锁"><a href="#1-2-偏向锁" class="headerlink" title="1.2 偏向锁"></a>1.2 偏向锁</h2><p>偏向锁在获取资源的时候会在资源对象上记录该对象是偏向该线程的，偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。</p><h3 id="1-2-1-偏向锁获取过程"><a href="#1-2-1-偏向锁获取过程" class="headerlink" title="1.2.1 偏向锁获取过程"></a>1.2.1 偏向锁获取过程</h3><ol><li>访问Mark Word中偏向锁标志位是否设置成1，锁标志位是否为01——确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>执行同步代码。</li></ol><h3 id="1-2-2-偏向锁的释放"><a href="#1-2-2-偏向锁的释放" class="headerlink" title="1.2.2.偏向锁的释放"></a>1.2.2.偏向锁的释放</h3><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点safepoint，它会首先暂停拥有偏向锁的线程A，然后判断这个线程A，此时有两种情况：</p><ol><li>A线程已经退出了同步代码块，或者是已经不存活了，如果是上面两种情况之一的，此时就会直接撤销偏向锁，变成无锁状态</li><li>A线程还在同步代码块中，此时将A线程的偏向锁升级为轻量级锁。下面说明了怎么升级。</li></ol><h3 id="1-2-3-批量重偏向"><a href="#1-2-3-批量重偏向" class="headerlink" title="1.2.3 批量重偏向"></a>1.2.3 批量重偏向</h3><h4 id="为什么有批量重偏向"><a href="#为什么有批量重偏向" class="headerlink" title="为什么有批量重偏向"></a>为什么有批量重偏向</h4><p>当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。这个过程是要消耗一定的成本的，所以如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p><h4 id="批量重偏向的原理"><a href="#批量重偏向的原理" class="headerlink" title="批量重偏向的原理"></a>批量重偏向的原理</h4><ol><li>首先引入一个概念epoch，其本质是一个时间戳，代表了偏向锁的有效性，epoch存储在可偏向对象的MarkWord中。除了对象中的epoch，对象所属的类class信息中，也会保存一个epoch值。</li><li>每当遇到一个全局安全点时(这里的意思是说批量重偏向没有完全替代了全局安全点，全局安全点是一直存在的)，比如要对class C 进行批量再偏向，则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new</li><li>然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，仅将epoch_new的值赋给被锁定的对象中，也就是现在偏向锁还在被使用的对象才会被赋值epoch_new。</li><li>退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为（3）步骤里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作。</li></ol><h2 id="1-3-轻量级锁"><a href="#1-3-轻量级锁" class="headerlink" title="1.3 轻量级锁"></a>1.3 轻量级锁</h2><h3 id="1-3-1-轻量级锁的获取过程"><a href="#1-3-1-轻量级锁的获取过程" class="headerlink" title="1.3.1 轻量级锁的获取过程"></a>1.3.1 轻量级锁的获取过程</h3><ol><li>在代码进入同步块的时候，如果同步对象锁状态为偏向状态（就是锁标志位为“01”状态，是否为偏向锁标志位为“1”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。官方称之为 Displaced Mark Word（所以这里我们认为Lock Record和 Displaced Mark Word其实是同一个概念）。这时候线程堆栈与对象头的状态如图所示：<br><img src="/img/JavaLock/1.png" alt="github"></li><li><p>拷贝对象头中的Mark Word复制到锁记录中。</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象头的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象头的mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p></li><li><p>如果上面这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下所示：<br><img src="/img/JavaLock/2.png" alt="github"></p></li><li><p>如果上面这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧。</p></li></ol><ul><li>如果是就说明当前线程已经拥有了这个对象的锁，现在是重入状态，那么设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。重入之后然后结束。接着就可以直接进入同步块继续执行。</li><li>如果不是说明这个锁对象已经被其他线程抢占了，说明此时有多个线程竞争锁，那么它就会自旋等待锁，一定次数后仍未获得锁对象，说明发生了竞争，需要膨胀为重量级锁。</li></ul><p>下图为重入三次时的lock record示意图，左边为锁对象，右边为当前线程的栈帧，重入之后然后结束。接着就可以直接进入同步块继续执行。<br><img src="/img/JavaLock/6.png" alt="github"></p><p>自旋原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗 CPU 的，如果一直获取不到锁，那线程也不能一直占用 CPU 自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM 对于自旋周期的选择，JDK1.6 之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，自旋不会一直持续下去，这时争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁。</p><h3 id="1-3-2-轻量级锁的解锁过程"><a href="#1-3-2-轻量级锁的解锁过程" class="headerlink" title="1.3.2 轻量级锁的解锁过程"></a>1.3.2 轻量级锁的解锁过程</h3><ul><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</li><li>如果替换成功，整个同步过程就完成了。</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ul><h2 id="1-4-重量级锁"><a href="#1-4-重量级锁" class="headerlink" title="1.4 重量级锁"></a>1.4 重量级锁</h2><h3 id="1-4-1-重量级锁加锁和释放锁机制"><a href="#1-4-1-重量级锁加锁和释放锁机制" class="headerlink" title="1.4.1 重量级锁加锁和释放锁机制"></a>1.4.1 重量级锁加锁和释放锁机制</h3><p>调用omAlloc分配一个ObjectMonitor对象，把锁对象头的mark word锁标志位变成 “10 ”，然后在mark word存储指向ObjectMonitor对象的指针</p><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><img src="/img/JavaLock/3.png" alt="github"></p><ol><li>当多个线程同时访问一段同步代码时，首先会进入 _EntryList 队列中。</li><li>当某个线程获取到对象的Monitor后进入临界区域，并把Monitor中的 _owner 变量设置为当前线程，同时Monitor中的计数器 _count 加1。即获得对象锁。</li><li>若持有Monitor的线程调用 wait() 方法，将释放当前持有的Monitor，*owner变量恢复为null，*count自减1，同时该线程进入 _WaitSet 集合中等待被唤醒。</li><li>在WaitSet 集合中的线程会被再次放到EntryList 队列中，重新竞争获取锁。</li><li>若当前线程执行完毕也将释放Monitor并复位变量的值，以便其他线程进入获取锁。</li></ol><h3 id="1-4-2-Monitor-对象"><a href="#1-4-2-Monitor-对象" class="headerlink" title="1.4.2 Monitor 对象"></a>1.4.2 Monitor 对象</h3><p>本质上是一个管程：管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。<br>在HotSpot虚拟机中，Monitor是基于C++的ObjectMonitor类实现的，结构体如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>    _header       = NULL;<br>    _count        = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 约为 _WaitSet 和 _EntryList 的节点数之和</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录重入次数</span><br>    _object       = NULL;<br>    _owner        = NULL; <span class="hljs-comment">// _owner指向持有ObjectMonitor对象的线程</span><br>    _WaitSet      = NULL; <span class="hljs-comment">// 双向循环链表：存放处于wait状态的线程队列，即调用wait()方法的线程</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = NULL ;<br>    _succ         = NULL ;<br>    _cxq          = NULL ;  <span class="hljs-comment">// 单向链表：多个线程争抢锁，会先存入这个</span><br>    FreeNext      = NULL ;<br>    _EntryList    = NULL ;  <span class="hljs-comment">// 双向循环链表：存放处于等待锁block状态的线程队列</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h3 id="1-4-3-锁竞争机制"><a href="#1-4-3-锁竞争机制" class="headerlink" title="1.4.3 锁竞争机制"></a>1.4.3 锁竞争机制</h3><h4 id="1-4-3-1-ObjectMonitor的并发管理逻辑"><a href="#1-4-3-1-ObjectMonitor的并发管理逻辑" class="headerlink" title="1.4.3.1 ObjectMonitor的并发管理逻辑"></a>1.4.3.1 ObjectMonitor的并发管理逻辑</h4><p><code>ObjectMonitor::enter()</code> 和 <code>ObjectMonitor::exit()</code> 分别是ObjectMonitor获取锁和释放锁的方法。线程解锁后还会唤醒之前等待的线程，根据策略选择直接唤醒_cxq队列中的头部线程去竞争，或者将_cxq队列中的线程加入_EntryList，然后再唤醒_EntryList队列中的线程去竞争。<br><img src="/img/JavaLock/4.png" alt="github"></p><h4 id="1-4-3-2-ObjectMonitor-enter"><a href="#1-4-3-2-ObjectMonitor-enter" class="headerlink" title="1.4.3.2 ObjectMonitor::enter()"></a>1.4.3.2 ObjectMonitor::enter()</h4><p><img src="/img/JavaLock/5.png" alt="github"><br>看一下ObjectMonitor::enter()方法竞争锁的流程：</p><ol><li>首先尝试通过 CAS 把 ObjectMonitor 中的 _owner 设置为当前线程，设置成功就表示获取锁成功。通过 _recursions 的自增来表示重入。</li><li>如果没有CAS成功，那么就开始启动自适应自旋，自旋还不行的话，就包装成 ObjectWaiter 对象加入到 _cxq 单向链表之中。</li><li>加入_cxq链表后，再次尝试是否可以CAS拿到锁，再次失败就要阻塞(block)，底层调用了pthread_mutex_lock。</li></ol><h4 id="1-4-3-3-ObjectMonitor-exit-方法"><a href="#1-4-3-3-ObjectMonitor-exit-方法" class="headerlink" title="1.4.3.3 ObjectMonitor::exit()方法"></a>1.4.3.3 ObjectMonitor::exit()方法</h4><p><img src="/img/JavaLock/7.png" alt="github"></p><ol><li>线程执行 Object.wait()方法时，会将当前线程加入到 _waitSet 这个双向链表中，然后再运行ObjectMonitor::exit() 方法来释放锁。</li><li>可重入锁就是根据 _recursions 来判断的，重入一次就执行 _recursions++，解锁一次就执行 _recursions—，如果 _recursions 减到 0 ，就说明需要释放锁了。</li><li>线程解锁后还会唤醒之前等待的线程。当线程执行 Object.notify()方法时，从 _waitSet 头部拿线程节点，然后根据策略（QMode指定）决定将线程节点放在哪里，包括_cxq 或 _EntryList 的头部或者尾部，然后唤醒队列中的线程。</li></ol><h2 id="1-5-synchronized关键字"><a href="#1-5-synchronized关键字" class="headerlink" title="1.5 synchronized关键字"></a>1.5 synchronized关键字</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>同步代码块的加锁、解锁是通过 Javac 编译器实现的，底层是借助monitorenter和monitorerexit，为了能够保证无论代码块正常执行结束 or 抛出异常结束，都能正确释放锁，Javac 编译器在编译的时候，会对monitorerexit进行特殊处理<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 同步数据</span><br>            System.out.println(<span class="hljs-string">&quot;hehehe&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后通过<code>javap -c Test.class &gt;&gt; test.txt</code>查看其编译后的字节码:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.Test();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: dup<br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: monitorenter<br>       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       7: ldc           #3                  // String hehehe<br>       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>      <span class="hljs-number">12</span>: aload_1<br>      <span class="hljs-number">13</span>: monitorexit<br>      <span class="hljs-number">14</span>: goto          <span class="hljs-number">22</span><br>      <span class="hljs-number">17</span>: astore_2<br>      <span class="hljs-number">18</span>: aload_1<br>      <span class="hljs-number">19</span>: monitorexit<br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: athrow<br>      <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">4</span>    <span class="hljs-number">14</span>    <span class="hljs-number">17</span>   any<br>          <span class="hljs-number">17</span>    <span class="hljs-number">20</span>    <span class="hljs-number">17</span>   any<br>&#125;<br></code></pre></td></tr></table></figure><br>monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取mark word里面存储的monitor，当 monitor的进入计数器为 0，那线程可以成功取得monitor，并将计数器值设置为1，取锁成功。</p><p>值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从上面的字节码中也可以看出有两个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><h3 id="同步实例方法"><a href="#同步实例方法" class="headerlink" title="同步实例方法"></a>同步实例方法</h3><p>同步方法的加锁、解锁是通过 Javac 编译器实现的，底层是借助<code>ACC_SYNCHRONIZED</code>访问标识符来实现的，代码如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步数据</span><br>        System.out.println(<span class="hljs-string">&quot;hehehe&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.Test();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       3: ldc           #3                  // String hehehe<br>       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h3><p>给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀ 个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有 ⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤ 这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前 实例对象锁。</p><p><img src="/img/JavaLock/8.png" alt="github"></p><h2 id="二、处理器架构"><a href="#二、处理器架构" class="headerlink" title="二、处理器架构"></a>二、处理器架构</h2><p>在了解下面锁之前，我们先需要一些处理器架构基础知识。</p><h2 id="2-1-SMP架构"><a href="#2-1-SMP架构" class="headerlink" title="2.1 SMP架构"></a>2.1 SMP架构</h2><p>即对称多处理器结构，在这种架构中，一台计算机由多个CPU组成，并共享内存和其他资源，所有的CPU都可以平等的访问内存、I/O等。虽然可以同时使用多个CPU，但从外部表现来看，它们就如同一台单CPU机器一样，操作系统将任务队列对称地分布于多个CPU之上，从而极大地提高了整个系统的数据处理能力。<br><img src="/img/JavaLock/12.png" alt="github"><br>但是随着CPU数量的增加，每个CPU都要访问共享资源，而资源在某些场景下只能单线程访问，在某些场景下的操作又必须通知到其他CPU，那么这就带来了性能损耗、资源浪费，成为了系统瓶颈。</p><h2 id="2-2-NUMA架构"><a href="#2-2-NUMA架构" class="headerlink" title="2.2 NUMA架构"></a>2.2 NUMA架构</h2><p>即非一致存储访问，这种模型的是为了解决smp扩容性很差而提出的技术方案。它按组将CPU分为多模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O等，模块之间的访问通过互联模块完成（类似远程通信），访问本地资源的速度会远高于访问外部资源<br><img src="/img/JavaLock/13.png" alt="github"><br>NUMA架构相当于打包多个SMP架构的CPU，它能较好解决SMP架构存在的扩展问题；但是，在NUMA的单个CPU模块中，虽然控制了CPU数量减少了共享资源的操作时的性能损耗，由于存在互联模块的工作，在CPU模块增加时，并不能线性的增加系统性能。</p><h2 id="2-3-MPP架构"><a href="#2-3-MPP架构" class="headerlink" title="2.3 MPP架构"></a>2.3 MPP架构</h2><p>MPP 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。 其基本特征是由多个 SMP 服务器（每个 SMP 服务器称节点）通过节点互联网络连接而成，每个节点只访问自己的本地资源（内存、存储等），是一种完全无共享（Share Nothing）结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现512个节点互联，数千个 CPU。 实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU。<br><img src="/img/JavaLock/14.png" alt="github"><br>可以将MMP理解为刀片服务器，每个刀扇里的都是一台独立SMP架构服务器，并且每个刀扇之间均有高性能的网络设备进行交互，保证smp服务器之间的数据传输性能。MMP架构比较依赖管理系统的处理能力来保障通信。</p><h2 id="三、CLH-锁"><a href="#三、CLH-锁" class="headerlink" title="三、CLH 锁"></a>三、CLH 锁</h2><p>CLH队列锁是一种基于链表的可扩展、高性能、公平的自旋锁, 申请线程仅仅在本地变量上自旋，不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。能确保无饥饿性，提供先来先服务的公平性。<br>CLH 锁的核心思想：将众多线程长时间对某资源(比如锁状态)的竞争，通过有序化这些线程将其转化为只需对前驱节点的本地变量检测。而唯一存在竞争的地方就是在入队列之前对尾节点tail的竞争，但此时竞争的线程数量已经少了很多了。比起所有线程直接对某资源竞争的轮询次数也减少了很多，这也大大节省了CPU缓存同步的消耗，从而大大提升系统性能。</p><p>当一个线程需要获取锁时：</p><ol><li><p>创建一个QNode, 将其中的 locked 设置为 true，表示需要获取锁，myPred 表示对其前驱节点的引用。<br><img src="/img/JavaLock/9.png" alt="github"></p></li><li><p>线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred<br><img src="/img/JavaLock/10.png" alt="github"></p><p> 线程B需要获得锁，同样的流程再来一遍<br><img src="/img/JavaLock/11.png" alt="github"></p></li><li><p>线程就在前驱节点的 locked 字段上旋转，直到前驱结点释放锁(即前驱节点的锁值 locked == false)</p></li><li>当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点。<br><img src="/img/JavaLock/12.png" alt="github"></li></ol><p>由于自旋过程中，监控的是前置节点的变量，因此在SMP架构的共享内存模式，能更好的提供性能。<br>在NUMA架构下，如果当前节点与前驱节点不在同一CPU模块下，跨CPU模块会带来额外的系统开销，而MCS锁更适用于NUMA架构。</p><h2 id="四、MCS-锁"><a href="#四、MCS-锁" class="headerlink" title="四、MCS 锁"></a>四、MCS 锁</h2><p>MCS锁中线程只对当前节点的本地变量自旋，而前驱节点则负责通知其结束自旋操作。<br>正因为如此，它解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题 。<br>每个节点在解锁时更新后继节点的锁值（locked），在这一刻，该节点的后置节点会结束自旋，并进行加锁。</p><p>NUMA架构下MCS锁的性能略优于CLH锁。</p><h2 id="4-1-CLH锁在NUMA架构下低于MCS锁的原因"><a href="#4-1-CLH锁在NUMA架构下低于MCS锁的原因" class="headerlink" title="4.1 CLH锁在NUMA架构下低于MCS锁的原因"></a>4.1 CLH锁在NUMA架构下低于MCS锁的原因</h2><p>CLH锁和MCS锁为线程节点分配的内存通常都会分配到与对应线程执行cpu核心绑定的NUMA节点的存储器中，而不同线程对应的cpu则可能位于不同的NUMA节点中。CLH锁会无限轮训前驱节点的isLocked状态，这一操作在前驱节点线程与当前线程不位于同一NUMA节点时，会不断的进行远程节点访问，性能较低；而MCS锁中，当前线程则是无限轮训自己线程节点的isLocked，这种情况下都是本地NUMA节点内存的访问。</p><h2 id="五、AQS"><a href="#五、AQS" class="headerlink" title="五、AQS"></a>五、AQS</h2><p>AQS（AbstractQueuedSynchronizer，队列同步器）<br>核心思想：如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。<br>AQS 使用一个volatile int state（代表共享资源）成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><p>内部队列改造：</p><ol><li>在结构上引入了头节点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关</li><li>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段</li><li>在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋</li><li>head节点使用的是虚拟节点</li></ol><p>AQS的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管理同步状态，在 AQS 里由一个int型的state来代表这个状态。将资源封装为Node,通过cas改变state值。<br><img src="/img/JavaLock/15.png" alt="github"></p><p>AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>从这里看是基本都是JCU包中的功能，大致使用了volatile来管理变量，完成并发。</p><h2 id="5-1-源码部分"><a href="#5-1-源码部分" class="headerlink" title="5.1 源码部分"></a>5.1 源码部分</h2><h3 id="5-1-1-节点"><a href="#5-1-1-节点" class="headerlink" title="5.1.1 节点"></a>5.1.1 节点</h3><p>节点有AQS的静态内部类Node定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><br><span class="hljs-comment">// 共享模式</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br><br><span class="hljs-comment">// 独占模式</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CANCELLED，值为1，表示当前的线程被取消</span><br><span class="hljs-comment"> * SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="hljs-comment"> * CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="hljs-comment"> * PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="hljs-comment"> * 值为0，表示当前节点在sync队列中，等待着获取锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br><br><span class="hljs-comment">// 前驱结点</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">// 后继结点</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">// 与该结点绑定的线程</span><br><span class="hljs-keyword">volatile</span> Thread thread;<br><br><span class="hljs-comment">// 存储condition队列中的后继节点</span><br>Node nextWaiter;<br><br><span class="hljs-comment">// 是否为共享模式</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>&#125;<br><br><span class="hljs-comment">// 获取前驱结点</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>Node p = prev;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br>Node() &#123; <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>&#125;<br><br>Node(Thread thread, Node mode) &#123; <span class="hljs-comment">// Used by addWaiter</span><br><span class="hljs-keyword">this</span>.nextWaiter = mode;<br><span class="hljs-keyword">this</span>.thread = thread;<br>&#125;<br><br>Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br><span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br><span class="hljs-keyword">this</span>.thread = thread;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>类中有两个常量SHARE和EXCLUSIVE，顾名思义这两个常量用于表示这个节点支持共享模式还是独占模式</p><ul><li>共享模式指的是允许多个线程获取同一个锁而且可能获取成功</li><li>独占模式指的是一个锁如果被一个线程持有，其他线程必须等待</li></ul><p>多个线程读取一个文件可以采用共享模式，而当有一个线程在写文件时不会允许另一个线程写这个文件，这就是独占模式的应用场景。</p><h3 id="5-1-2-CAS操作"><a href="#5-1-2-CAS操作" class="headerlink" title="5.1.2 CAS操作"></a>5.1.2 CAS操作</h3><p>AQS有三个重要的变量：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队头结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 队尾结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 代表共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>&#123;<br>    state = newState;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><br><code>compareAndSetState</code>方法是以乐观锁的方式更新共享资源。<br>独占锁是一种悲观锁，就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，即Compare And Swap。</p><p>head、tail、state三个变量都是volatile的。，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果一个字段被声明成，Java线程内存模型确保所有线程看到这个变量的值是一致的。volatile保证共享变量的可见性，CAS保证更新操作的原子性。</p><ul><li>声明共享变量为volatile</li><li>使用CAS的原子条件更新来实现线程之间的同步</li><li>配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信</li></ul><p><img src="/img/JavaLock/16.png" alt="github"></p><h3 id="5-1-3-方法"><a href="#5-1-3-方法" class="headerlink" title="5.1.3 方法"></a>5.1.3 方法</h3><p>AQS定义两种资源共享方式：</p><ul><li>Exclusive：独占，只有一个线程能执行，如ReentrantLock</li><li>Share：共享，多个线程可同时执行，如CountDownLatch</li></ul><h4 id="5-1-3-1-模板方法"><a href="#5-1-3-1-模板方法" class="headerlink" title="5.1.3.1 模板方法"></a>5.1.3.1 模板方法</h4><h5 id="1-acquire-int"><a href="#1-acquire-int" class="headerlink" title="1. acquire(int)"></a>1. acquire(int)</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。获取到资源后，线程就可以去执行其临界区代码了。</p><p>流程如下：</p><ol><li>尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p>下面是每个方法的实现代码</p><h6 id="1-1-tryAcquire-int"><a href="#1-1-tryAcquire-int" class="headerlink" title="1.1 tryAcquire(int)"></a>1.1 tryAcquire(int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。</p><p>AQS只是一个框架，在这里定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS），至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了。当然，自定义同步器在进行资源访问时要考虑线程安全的影响。 这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire，而共享模式下只用实现tryAcquireShared。如果都定义成，那么每个模式也要去实现另一模式下的接口。说到底，还是站在咱们开发者的角度，尽量减少不必要的工作量。</p><h6 id="1-2-addWaiter-Node"><a href="#1-2-addWaiter-Node" class="headerlink" title="1.2 addWaiter(Node)"></a>1.2 addWaiter(Node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用当前线程构造结点</span><br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果队尾结点不为空，将当前节点插入队尾</span><br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 队尾结点为空（队列还没有初始化），则转调enq入队</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，compareAndSetTail方法也是调用Unsafe类实现CAS操作，更新队尾。</p><h6 id="1-3-enq-Node"><a href="#1-3-enq-Node" class="headerlink" title="1.3 enq(Node)"></a>1.3 enq(Node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// CAS自旋，直到插入成功</span><br>        Node t = tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 队尾为空，则先初始化队列，new一个虚拟节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                tail = head; <span class="hljs-comment">// 头尾指针都指向傀儡节点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 插入队尾</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码CAS自旋volatile变量，也是AtomicInteger、AtomicBoolean等原子量的灵魂。</p><h6 id="1-4-acquireQueued-Node-int"><a href="#1-4-acquireQueued-Node-int" class="headerlink" title="1.4 acquireQueued(Node, int)"></a>1.4 acquireQueued(Node, int)</h6><p>通过tryAcquire()和addWaiter()，如果线程获取资源失败，已经被放入等待队列尾部了。但是，后面还有一项重要的事没干，就是让线程进入阻塞状态，直到其他线程释放资源后唤醒自己。过程跟在银行办理业务时排队拿号有点相似，acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 是否获取到了资源</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 等待过程中有没有被中断</span><br>        <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 自旋，直到</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 前驱是head，则有资格去尝试获取资源</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 获取资源成功，将自己置为队头，并回收其前驱（旧的队头）</span><br>                setHead(node);<br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 获取资源失败，</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>如果获取资源失败后，会调用两个函数，shouldParkAfterFailedAcquire和parkAndCheckInterrupt，下面来看看它俩是干什么的。</p><h6 id="1-5-shouldParkAfterFailedAcquire-Node-Node"><a href="#1-5-shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="1.5 shouldParkAfterFailedAcquire(Node, Node)"></a>1.5 shouldParkAfterFailedAcquire(Node, Node)</h6><p>该函数的作用是“在获取资源失败后是否需要阻塞”：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus; <span class="hljs-comment">// 前驱状态</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">// Node.SIGNAL，代表前驱释放资源后会通知后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 代表前驱已取消任务，相当于退出了等待队列</span><br>        <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// 一个个往前找，找到最近一个正常等待的前驱，排在它的后面</span><br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 前驱状态正常，则将其状态置为SIGNAL，意为，释放资源后通知后继结点</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>整个流程中，如果前驱节点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><h6 id="1-6-parkAndCheckInterrupt"><a href="#1-6-parkAndCheckInterrupt" class="headerlink" title="1.6 parkAndCheckInterrupt()"></a>1.6 parkAndCheckInterrupt()</h6><p>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 使线程进入waiting状态</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><br>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：被unpark()或被interrupt()。</p><h6 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h6><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h5 id="2-release-int"><a href="#2-release-int" class="headerlink" title="2. release(int)"></a>2. release(int)</h5><p>release()是acquire()的逆操作，是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 状态不为0，证明需要唤醒后继结点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="2-1-tryRelease-int"><a href="#2-1-tryRelease-int" class="headerlink" title="2.1 tryRelease(int)"></a>2.1 tryRelease(int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可，也不需要考虑线程安全的问题。</p><h6 id="2-2-unparkSuccessor-Node"><a href="#2-2-unparkSuccessor-Node" class="headerlink" title="2.2 unparkSuccessor(Node)"></a>2.2 unparkSuccessor(Node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 将当前结点状态置零</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <br>    Node s = node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 后继结点为空或者已取消</span><br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 从队尾开始向前寻找，找到第一个正常的后继结点</span><br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        LockSupport.unpark(s.thread); <span class="hljs-comment">// 唤醒该结点上的线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程。</p><h5 id="3-acquireShared-int"><a href="#3-acquireShared-int" class="headerlink" title="3. acquireShared(int)"></a>3. acquireShared(int)</h5><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>    doAcquireShared(arg);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123; <span class="hljs-comment">// 留给子类实现</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><br>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</p><h6 id="3-1-doAcquireShared-int"><a href="#3-1-doAcquireShared-int" class="headerlink" title="3.1 doAcquireShared(int)"></a>3.1 doAcquireShared(int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="hljs-comment">// 以共享模式加入队尾</span><br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123; <span class="hljs-comment">// 前驱是队头（队头肯定是已经拿到资源的结点）</span><br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg); <span class="hljs-comment">// 尝试获取资源</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 获取资源成功</span><br>                    setHeadAndPropagate(node, r); <span class="hljs-comment">// 将自己置为队头，若还有剩余资源，向后传播</span><br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt(); <span class="hljs-comment">// 如果等待过程中被打断过，此时将中断补上。</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 判断状态，寻找合适的前驱，进入waiting状态，等着被unpark()或interrupt()</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的功能类似于独占模式下的acquireQueued()。</p><p>跟独占模式比，有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。因为老大先唤醒老二，老二一看资源不够自己用继续park()，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。</p><h6 id="3-2-setHeadAndPropagate-Node-int"><a href="#3-2-setHeadAndPropagate-Node-int" class="headerlink" title="3.2 setHeadAndPropagate(Node, int)"></a>3.2 setHeadAndPropagate(Node, int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    Node h = head;<br>    setHead(node); <span class="hljs-comment">// 将自己置为队头</span><br>    <br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) <span class="hljs-comment">// 后继结点也为共享模式，则触发释放资源函数</span><br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继节点，毕竟是共享模式。</p><h5 id="4-releaseShared-int"><a href="#4-releaseShared-int" class="headerlink" title="4. releaseShared(int)"></a>4. releaseShared(int)</h5><p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="hljs-comment">// 尝试释放资源</span><br>        doReleaseShared(); <span class="hljs-comment">// 释放成功，继续唤醒后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123; <span class="hljs-comment">// 留给子类实现</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><br>跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于可重入的考量；而共享模式下的releaseShared()则没有这种要求，多线程可并发执行，不适用于可重入。</p><h6 id="4-1-doReleaseShared"><a href="#4-1-doReleaseShared" class="headerlink" title="4.1 doReleaseShared()"></a>4.1 doReleaseShared()</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123; <span class="hljs-comment">// 头结点不为空且有后继结点</span><br>            <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>)) <span class="hljs-comment">// 头结点状态，SIGNAL——&gt;0</span><br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 状态更新失败则循环进行，直到成功</span><br>                unparkSuccessor(h); <span class="hljs-comment">// 唤醒后继结点</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-comment">// 头结点状态，0——&gt;PROPAGATE</span><br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 持续循环，直到状态更新成功</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// 头结点没变，则结束循环；否则继续</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，AQS的独占模式与共享模式下的实现原理剖析的差不多了。</p><h4 id="5-1-3-2-可重写的方法"><a href="#5-1-3-2-可重写的方法" class="headerlink" title="5.1.3.2 可重写的方法"></a>5.1.3.2 可重写的方法</h4><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。<br>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，成功则返回true，失败则返回false。</li></ul><p>初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。<br>任务分为N个子线程去执行，也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="5-2-为什么AQS框架底层使用CLH队列结构作为基础"><a href="#5-2-为什么AQS框架底层使用CLH队列结构作为基础" class="headerlink" title="5.2 为什么AQS框架底层使用CLH队列结构作为基础"></a>5.2 为什么AQS框架底层使用CLH队列结构作为基础</h2><p>由于AQS中需要让大量并发争用锁的线程频繁的被阻塞和唤醒，出于性能的考虑，为避免过多的线程上下文切换，AQS本身没有再利用操作系统底层提供的线程阻塞/唤醒机制通过互斥锁来保证同步队列的并发安全，而是使用基于CAS的乐观重试机制来构造一个无锁，并发安全的同步队列。<br>AQS作为一个通用的同步器框架，是需要支持超时、中断等取消加锁的，而前面提到基础版的CLH锁和MCS锁都存在一个缺陷，即无法很好的支持超时、中断等取消加锁的场景。<br>引入了显式前驱节点引用的CLH锁比起MCS锁可以更加简单的实现超时、中断等加锁过程中临时退出加锁的场景。而由于AQS中的线程在征用锁失败时不会占用CPU一直自旋等待，而是被设置为阻塞态让出CPU（LockSupport.park），因此MCS锁在NUMA架构下性能略高的优点也就不是那么重要了。</p><h2 id="5-3-一些锁"><a href="#5-3-一些锁" class="headerlink" title="5.3 一些锁"></a>5.3 一些锁</h2><h3 id="5-3-1-ReentrantLock"><a href="#5-3-1-ReentrantLock" class="headerlink" title="5.3.1 ReentrantLock"></a>5.3.1 ReentrantLock</h3><h4 id="5-3-1-1-公平和非公平锁"><a href="#5-3-1-1-公平和非公平锁" class="headerlink" title="5.3.1.1 公平和非公平锁"></a>5.3.1.1 公平和非公平锁</h4><p>Reentrantlock 可以是公平锁，也可以是非公平锁。<br>ReentrantLock 的构造函数中，默认的无参构造函数将会把Sync对象创建为 NonfairSync 对象，这是一个”非公平锁”; 而另一个构造函数ReentrantLock(boolean fair) 传入参数为 true 时将会把 Sync 对象创建为”公平锁”FairSync。</p><h4 id="5-3-1-2-可重入"><a href="#5-3-1-2-可重入" class="headerlink" title="5.3.1.2 可重入"></a>5.3.1.2 可重入</h4><h3 id="5-3-2-CountDownLatch"><a href="#5-3-2-CountDownLatch" class="headerlink" title="5.3.2 CountDownLatch"></a>5.3.2 CountDownLatch</h3><h3 id="5-3-3-CyclicBarrier"><a href="#5-3-3-CyclicBarrier" class="headerlink" title="5.3.3 CyclicBarrier"></a>5.3.3 CyclicBarrier</h3><h3 id="5-3-4-Semaphore"><a href="#5-3-4-Semaphore" class="headerlink" title="5.3.4 Semaphore"></a>5.3.4 Semaphore</h3><h2 id="、乐观锁和悲观锁"><a href="#、乐观锁和悲观锁" class="headerlink" title="、乐观锁和悲观锁"></a>、乐观锁和悲观锁</h2><p>Java中，<code>synchronized关键字</code>和<code>Lock的实现类</code>都是悲观锁。悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 悲观锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    lock.lock();<br>    <span class="hljs-comment">// 同步数据</span><br>    lock.unlock();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 同步数据</span><br>&#125;<br><br><span class="hljs-comment">// 乐观锁</span><br><span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>atomicInteger.incrementAndGet();<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java锁</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中的CAS操作</title>
    <link href="http://example.com/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/"/>
    <id>http://example.com/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/</id>
    <published>2023-03-15T22:01:12.000Z</published>
    <updated>2023-04-25T06:15:18.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是CAS"><a href="#一、什么是CAS" class="headerlink" title="一、什么是CAS"></a>一、什么是CAS</h2><p>Compare And Swap的缩写，中文翻译成比较并交换。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><h2 id="二、引出CAS"><a href="#二、引出CAS" class="headerlink" title="二、引出CAS"></a>二、引出CAS</h2><p>看看下面代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> COUNT = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(COUNT);<br><br>    <span class="hljs-keyword">final</span> Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                count++;<br>                atomicInteger.getAndIncrement();<br>            &#125;<br>            latch.countDown();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; COUNT; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(runnable).start();<br>    &#125;<br>    latch.await();<br>    System.out.println(<span class="hljs-string">&quot;理论结果：&quot;</span> + <span class="hljs-number">1000</span>*COUNT);<br>    System.out.println(<span class="hljs-string">&quot;count:&quot;</span> + count);<br>    System.out.println(<span class="hljs-string">&quot;atomic:&quot;</span> + atomicInteger.intValue());<br>&#125;<br></code></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">理论结果：<span class="hljs-number">10000</span><br>count:<span class="hljs-number">9997</span><br>atomic:<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><br>多次允许后发现，count的结果永远不正确，而atomic的数据永远是正确的。</p><h2 id="三、Atomic"><a href="#三、Atomic" class="headerlink" title="三、Atomic"></a>三、Atomic</h2><p>根据操作的目标数据类型</p><ul><li>基本原子类</li><li>数组原子类</li><li>原子引用类型</li><li>字段更新原子类</li></ul><h2 id="3-1-基本原子类"><a href="#3-1-基本原子类" class="headerlink" title="3.1 基本原子类"></a>3.1 基本原子类</h2><p>基本原子类的功能，是通过原子方式更新 Java 基础类型变量的值。基本原子类主要包括了以下三个：</p><ul><li>AtomicInteger：整型原子类。</li><li>AtomicLong：长整型原子类。 </li><li>AtomicBoolean ：布尔型原子类。</li></ul><h2 id="3-2-数组原子类"><a href="#3-2-数组原子类" class="headerlink" title="3.2 数组原子类"></a>3.2 数组原子类</h2><p>数组原子类的功能，是通过原子方式更数组里的某个元素的值。数组原子类主要包括了以下三个：</p><ul><li>AtomicIntegerArray：整型数组原子类。</li><li>AtomicLongArray：长整型数组原子类。</li><li>AtomicReferenceArray ：引用类型数组原子类。</li></ul><h2 id="3-3-原子引用类型"><a href="#3-3-原子引用类型" class="headerlink" title="3.3 原子引用类型"></a>3.3 原子引用类型</h2><p>引用原子类主要包括了以下三个：</p><ul><li>AtomicReference：引用类型原子类。</li><li>AtomicMarkableReference ：带有更新标记位的原子引用类型。</li><li>AtomicStampedReference ：带有更新版本号的原子引用类型。<br><strong><em>AtomicStampedReference通过引入“版本”的概念，来解决ABA的问题。</em></strong></li></ul><h2 id="3-4-字段更新原子类"><a href="#3-4-字段更新原子类" class="headerlink" title="3.4 字段更新原子类"></a>3.4 字段更新原子类</h2><p>字段更新原子类主要包括了以下三个：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器。 </li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li></ul><h2 id="3-5-基本函数"><a href="#3-5-基本函数" class="headerlink" title="3.5 基本函数"></a>3.5 基本函数</h2><div class="table-container"><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取当前的值</td></tr><tr><td>public final int getAndSet(int newValue)</td><td>获取当前的值，然后设置新的值</td></tr><tr><td>public final int getAndIncrement()</td><td>获取当前的值，然后自增</td></tr><tr><td>public final int getAndDecrement()</td><td>获取当前的值，然后自减</td></tr><tr><td>public final int getAndAdd(int delta)</td><td>获取当前的值，并加上预期的值</td></tr><tr><td>boolean compareAndSet(int expect, int update)</td><td>通过 CAS 方式设置整数值</td></tr></tbody></table></div><h2 id="3-6-Unsafe类"><a href="#3-6-Unsafe类" class="headerlink" title="3.6 Unsafe类"></a>3.6 Unsafe类</h2><p>Unsafe 提供了CAS 方法，直接通过native 方式（封装 C++代码）调用了底层的 CPU 指令 cmpxchg。从名字中我们可以看出来这个类对普通程序员来说是“危险”的，一般应用开发者不会用到这个类。</p><h3 id="3-6-1-Unsafe-提供的-CAS-方法"><a href="#3-6-1-Unsafe-提供的-CAS-方法" class="headerlink" title="3.6.1 Unsafe 提供的 CAS 方法"></a>3.6.1 Unsafe 提供的 CAS 方法</h3><p>主要如下： 定义在 Unsafe 类中的三个 “比较并交换”原子方法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@param o 包含要修改的字段的对象</span><br><span class="hljs-comment">@param offset 字段在对象内的偏移量</span><br><span class="hljs-comment">@param expected 期望值（旧的值）</span><br><span class="hljs-comment">@param update 更新值（新的值）</span><br><span class="hljs-comment">@return true 更新成功 | false 更新失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object expected, Object update)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">( Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> update)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">( Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">long</span> expected, <span class="hljs-keyword">long</span> update)</span></span>;<br></code></pre></td></tr></table></figure><br>Unsafe 提供的 CAS 方法包含四个入参： 包含要修改的字段对象、字段内存位置、预期原值及新值。<br>在执行 Unsafe 的 CAS 方法的时候，这些方法首先将内存位置的值与预期值（旧的值）比较，如果相匹配，那么处理器会自动将该内存位置的值更新为新值，并返回 true ；如果不相匹配，处理器不做任何操作，并返回 false 。<br><img src="/img/CAS/1.png" alt="github"><br>CAS操作由处理器提供支持，是一种原语。原语是操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。如 Intel 处理器，比较并交换通过指令的 cmpxchg 系列实现。</p><h3 id="3-6-2-获取属性偏移量"><a href="#3-6-2-获取属性偏移量" class="headerlink" title="3.6.2 获取属性偏移量"></a>3.6.2 获取属性偏移量</h3><p>Unsafe 提供的获取字段（属性）偏移量的相关操作，主要如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> o 需要操作属性的反射 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 属性的偏移量 </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">staticFieldOffset</span><span class="hljs-params">(Field field)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field field)</span></span>;<br></code></pre></td></tr></table></figure></p><ul><li>staticFieldOffset 方法用于获取静态属性 Field 在 Class 对象中的偏移量，在 CAS 操作静态属性时，会用到这个偏移量。</li><li>objectFieldOffset 方法用于获取非静态 Field （非静态属性）在 Object 实例中的偏移量，在 CAS 操作对象的非静态属性时，会用到这个偏移量。</li></ul><h3 id="3-6-3-根据属性的偏移量获取属性的最新值"><a href="#3-6-3-根据属性的偏移量获取属性的最新值" class="headerlink" title="3.6.3 根据属性的偏移量获取属性的最新值:"></a>3.6.3 根据属性的偏移量获取属性的最新值:</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> o 字段所属于的对象实例</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> fieldOffset 字段的偏移量 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 字段的最新值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> fieldOffset)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="四、CAS的缺点"><a href="#四、CAS的缺点" class="headerlink" title="四、CAS的缺点"></a>四、CAS的缺点</h2><h2 id="4-1-ABA问题"><a href="#4-1-ABA问题" class="headerlink" title="4.1  ABA问题"></a>4.1  ABA问题</h2><p>一个线程先读取共享内存数据值A，随后因某种原因，线程暂时挂起，同时另一个线程临时将共享内存数据值先改为B，随后又改回为A。随后挂起线程恢复，并通过CAS比较，最终比较结果将会无变化。这样会通过检查，这就是ABA问题。<br>JDK 提供了两个类 AtomicStampedReference、AtomicMarkableReference 来解决 ABA 问题。</p><h2 id="4-2-只能保证一个共享变量的原子操作"><a href="#4-2-只能保证一个共享变量的原子操作" class="headerlink" title="4.2 只能保证一个共享变量的原子操作"></a>4.2 只能保证一个共享变量的原子操作</h2><p>一个比较简单的规避方法为：把多个共享变量合并成一个共享变量来操作。 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，可以把多个变量放在一个 AtomicReference 实例后再进行 CAS 操作。比如有两个共享变量 i＝1、j=2，可以将二者合并成一个对象，然后用 CAS 来操作该合并对象的 AtomicReference 引用。</p><h2 id="4-3-循环时间长开销大"><a href="#4-3-循环时间长开销大" class="headerlink" title="4.3 循环时间长开销大"></a>4.3 循环时间长开销大</h2><p>高并发下N多线程同时去操作一个变量，会造成大量线程CAS失败，然后处于自旋状态，导致严重浪费CPU资源，降低了并发性。</p><h4 id="解决-CAS-恶性空自旋的较为常见的方案为："><a href="#解决-CAS-恶性空自旋的较为常见的方案为：" class="headerlink" title="解决 CAS 恶性空自旋的较为常见的方案为："></a>解决 CAS 恶性空自旋的较为常见的方案为：</h4><ul><li>分散操作热点，使用 LongAdder 替代基础原子类 AtomicLong。</li><li>使用队列削峰，将发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度。JUC 中非常重要的基础类 AQS（抽象队列同步器）就是这么做的。</li></ul><h2 id="五、以空间换时间：LongAdder"><a href="#五、以空间换时间：LongAdder" class="headerlink" title="五、以空间换时间：LongAdder  "></a>五、以空间换时间：LongAdder  </h2><h2 id="5-1-LongAdder-DoubleAdder-的原理"><a href="#5-1-LongAdder-DoubleAdder-的原理" class="headerlink" title="5.1 LongAdder(DoubleAdder) 的原理"></a>5.1 LongAdder(DoubleAdder) 的原理</h2><p>LongAdder 的基本思路就是分散热点， 如果有竞争的话，内部维护了多个Cell变量，每个Cell里面有一个初始值为0的long型变量， 不同线程会命中到数组的不同Cell （槽 ）中，各个线程只对自己Cell（槽） 中的那个值进行 CAS 操作。这样热点就被分散了，冲突的概率就小很多。<br>在没有竞争的情况下，要累加的数通过 CAS 累加到 base 上。<br>如果要获得完整的 LongAdder 存储的值，只要将各个槽中的变量值累加，后的值即可。<br><img src="/img/CAS/0.png" alt="github"></p><h2 id="5-2-longAddr内部结构"><a href="#5-2-longAddr内部结构" class="headerlink" title="5.2 longAddr内部结构"></a>5.2 longAddr内部结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">|-----------|<br>| Striped64 |       |------------|<br>|___________|       |Serializable|<br>      ^             |____________|<br>      |                    ^<br>      |                    |<br>|-----------|              |<br>| LongAdder |--------------|<br>|___________|<br></code></pre></td></tr></table></figure><h3 id="5-2-1-Striped64类的重要成员属性"><a href="#5-2-1-Striped64类的重要成员属性" class="headerlink" title="5.2.1 Striped64类的重要成员属性"></a>5.2.1 Striped64类的重要成员属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cell表，当非空时，大小是2的幂。  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基础值，主要在没有争用时使用</span><br><span class="hljs-comment"> * 在没有争用时使用CAS更新这个值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自旋锁(通过CAS锁定) 在调整大小和或创建cell时使用,</span><br><span class="hljs-comment"> * 为 0 表示 cells 数组没有处于创建、扩容阶段,反之为1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p>内部包含一个 base 和一个 Cell[] 类型的 cells 数组 。 在没有竞争的情况下，要累加的数通过 CAS 累加到 base 上；如果有竞争的话，会将要累加的数累加到 Cells 数组中的某个 cell 元素里面。所以 Striped64 的整体值 value 为 base+ ∑ [0~n]cells 。</p><h3 id="5-2-2-LongAdder的整体值-value-的获取源码"><a href="#5-2-2-LongAdder的整体值-value-的获取源码" class="headerlink" title="5.2.2 LongAdder的整体值 value 的获取源码"></a>5.2.2 LongAdder的整体值 value 的获取源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">longValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sum();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Striped64.Cell[] as = cells;<br>    Striped64.Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>triped64 的设计核心思路就是通过内部的分散计算来避免竞争，以空间换时间。 LongAdder<br>的 base 类似于 AtomicInteger 里面的 value ，在没有竞争的情况，cells 数组为 null ，这时只使用 base 做累加；而一旦发生竞争，cells 数组就上场了。<br>cells 数组第一次初始化长度为 2 ，以后每次扩容都是变为原来的两倍，一直到 cells 数组的长<br>度大于等于当前服务器 CPU 的核数。为什么呢？同一时刻，能持有 CPU 时间片而去并发操作同<br>一个内存地址的最大线程数，最多也就是 CPU 的核数。<br>在存在线程争用的时候，每个线程被映射到 cells[threadLocalRandomProbe &amp; cells.length] 位置的 Cell 元素，该线程对 value 所做的累加操作，就执行在对应的 Cell 元素的值上，最终相当于将线程绑定到了 cells 中的某个 cell 对象上。</p><h2 id="5-3-LongAdder-类的-add-方法"><a href="#5-3-LongAdder-类的-add-方法" class="headerlink" title="5.3 LongAdder 类的 add 方法"></a>5.3 LongAdder 类的 add 方法</h2><h3 id="5-3-1-自增"><a href="#5-3-1-自增" class="headerlink" title="5.3.1 自增"></a>5.3.1 自增</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-自减"><a href="#5-3-2-自减" class="headerlink" title="5.3.2 自减"></a>5.3.2 自减</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>    add(-<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-add方法"><a href="#5-3-3-add方法" class="headerlink" title="5.3.3 add方法"></a>5.3.3 add方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//as: 表示cells引用</span><br>    <span class="hljs-comment">//b: base值</span><br>    <span class="hljs-comment">//v: 表示当前线程命中的cell的期望值</span><br>    <span class="hljs-comment">//m: 表示cells数组长度</span><br>    <span class="hljs-comment">//a: 表示当前线程命中的cell</span><br>    Striped64.Cell[] as;<br>    <span class="hljs-keyword">long</span> b, v;<br>    <span class="hljs-keyword">int</span> m;<br>    Striped64.Cell a;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    stop 1：true -&gt; 说明存在竞争，并且cells数组已经初始化了，当前线程需要将数据写入到对应的cell中</span><br><span class="hljs-comment">           false -&gt; 表示cells未初始化，当前所有线程应该将数据写到base中</span><br><span class="hljs-comment">    stop 2：true -&gt; 表示发生竞争了，可能需要重试或者扩容</span><br><span class="hljs-comment">           false -&gt; 表示当前线程cas替换数据成功</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (<br>            (as = cells) != <span class="hljs-keyword">null</span>  <span class="hljs-comment">//stop 1</span><br>            ||<br>            !casBase(b = base, b + x) <span class="hljs-comment">//stop 2</span><br>    ) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        进入的条件：</span><br><span class="hljs-comment">        1.cells数组已经初始化了，当前线程需要将数据写入到对应的cell中</span><br><span class="hljs-comment">        2.表示发生竞争了，可能需要重试或者扩容</span><br><span class="hljs-comment">        */</span><br> <br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">        是否有竞争：true -&gt; 没有竞争</span><br><span class="hljs-comment">                   false -&gt; 有竞争*/</span><br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        stop 3：as == null || (m = as.length - 1)&lt;0 代表 cells 没有初始化</span><br><span class="hljs-comment">        stop 4：表示当前线程命中的cell为空，意思是还没有其他线程在同一个位置做过累加操作。</span><br><span class="hljs-comment">        stop 5：表示当前线程命中的cell不为空， 然后在该Cell对象上进行CAS设置其值为v+x（x为该 Cell 需要累加的值），如果CAS操作失败，表示存在争用。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> || <span class="hljs-comment">//stop 3</span><br>                (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> || <span class="hljs-comment">//stop 4</span><br>                !(uncontended = a.cas(v = a.value, v + x))) <span class="hljs-comment">//stop 5</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            进入的条件：</span><br><span class="hljs-comment">            1.cells 未初始化</span><br><span class="hljs-comment">            2.当前线程对应下标的cell为空</span><br><span class="hljs-comment">            3.当前线程对应的cell有竞争并且cas失败</span><br><span class="hljs-comment">            */</span><br>            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CAS/2.png" alt="github"></p><h3 id="5-3-4-longAccumulate方法"><a href="#5-3-4-longAccumulate方法" class="headerlink" title="5.3.4 longAccumulate方法"></a>5.3.4 longAccumulate方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//条件成立: 说明当前线程还未分配hash值</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1.给当前线程分配hash值</span><br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        <span class="hljs-comment">//2.提取当前线程的hash值</span><br>        h = getProbe();<br>        <span class="hljs-comment">//3.因为上一步提取了重新分配的新的hash值，所以会重新分配cells数组的位置给当前线程写入，先假设它能找到一个元素不冲突的数组下标。</span><br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//扩容意向，collide=true 可以扩容，collide=false 不可扩容</span><br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-comment">//自旋，一直到操作成功</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//as: 表示cells引用</span><br>        <span class="hljs-comment">//a: 当前线程命中的cell</span><br>        <span class="hljs-comment">//n: cells数组长度</span><br>        <span class="hljs-comment">//a: 表示当前线程命中的cell的期望值</span><br>        Striped64.Cell[] as; Striped64.Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//CASE1: cells数组已经初始化了，当前线程将数据写入到对应的cell中</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//CASE1.1: true 表示下标位置的 cell 为 null，需要创建 new Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// cells 数组没有处于创建、扩容阶段</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    Striped64.Cell r = <span class="hljs-keyword">new</span> Striped64.Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-comment">// cas去加锁</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Striped64.Cell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">// 再次判断cells不为空 &amp; 槽位为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                    (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                    rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                rs[j] = r;<br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<span class="hljs-comment">//创建、扩容成功，退出自旋</span><br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// CASE1.2：当前线程竞争修改cell失败</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">// CASE 1.3：当前线程 rehash 过 hash 值,CAS 更新 Cell</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                    fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// CASE1.4:判断是否可以扩容</span><br>            <span class="hljs-comment">//  CASE1.4.1：n &gt;= NCPU</span><br>            <span class="hljs-comment">//      true -&gt; cells数组长度已经 &gt;= cpu核数，不可进行扩容，把扩容意向改为false</span><br>            <span class="hljs-comment">//      false -&gt; 可扩容</span><br>            <span class="hljs-comment">//  CASE1.4.2：cells != as</span><br>            <span class="hljs-comment">//      true -&gt; 其它线程已经扩容过了，当前线程rehash之后重试即可</span><br>            <span class="hljs-comment">//      false -&gt; 未有线程对cells进行修改</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 把扩容意向改为false</span><br>            <span class="hljs-comment">// CASE 1.5:设置扩容意向为 true，但是不一定真的发生扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//CASE1.6:真正扩容的逻辑</span><br>            <span class="hljs-comment">//  CASE1.6.1：cellsBusy == 0</span><br>            <span class="hljs-comment">//      true -&gt; 表示cells没有被其它线程占用，当前线程可以去竞争锁</span><br>            <span class="hljs-comment">//      false -&gt; 表示有其它线程正在操作cells</span><br>            <span class="hljs-comment">//  CASE1.6.2：casCellsBusy()</span><br>            <span class="hljs-comment">//      true -&gt; 表示当前线程获取锁成功，可以进行扩容操作</span><br>            <span class="hljs-comment">//      false -&gt; 表示当前线程获取锁失败，当前时刻有其它线程在做扩容相关的操作</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//重复判断一下当前线程的临时cells数组是否与原cells数组一致(防止有其它线程提前修改了cells数组，因为cells是volatile的全局变量)</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        <span class="hljs-comment">//n &lt;&lt; 1 表示数组长度翻一倍</span><br>                        Striped64.Cell[] rs = <span class="hljs-keyword">new</span> Striped64.Cell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//扩容后，将扩容意向置为false</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            <span class="hljs-comment">//重置当前线程hash值</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//CASE2：cells 还未初始化（as 为 null）,并且 cellsBusy 加锁成功</span><br>        <span class="hljs-comment">//  CASE2.1：判断锁是否被占用</span><br>        <span class="hljs-comment">//         true -&gt; 表示当前未加锁</span><br>        <span class="hljs-comment">//         false -&gt; 表示当前已加锁</span><br>        <span class="hljs-comment">//  CASE2.2：因为其它线程可能会在当前线程给as赋值之后修改了cells</span><br>        <span class="hljs-comment">//         true -&gt; cells没有被其它线程修改</span><br>        <span class="hljs-comment">//         false -&gt; cells已经被其它线程修改</span><br>        <span class="hljs-comment">// CASE2.3：获取锁</span><br>        <span class="hljs-comment">//         true -&gt; 获取锁成功 会把cellsBusy = 1</span><br>        <span class="hljs-comment">//         false -&gt; 表示其它线程正在持有这把锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//双重检查，防止其它线程已经初始化，当前线程再次初始化，会导致数据丢失</span><br>                <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    Striped64.Cell[] rs = <span class="hljs-keyword">new</span> Striped64.Cell[<span class="hljs-number">2</span>];<br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Striped64.Cell(x);<br>                    cells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//CASE3：当前线程 cellsBusy 加锁失败，表示其他线程正在初始化 cells</span><br>        <span class="hljs-comment">//所以当前线程将值累加到 base，注意 add(…)方法调用此方法时 fn 为 null</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CAS/3.png" alt="github"></p><h3 id="5-3-5-LongAdder-类的-casCellsBusy-方法"><a href="#5-3-5-LongAdder-类的-casCellsBusy-方法" class="headerlink" title="5.3.5 LongAdder 类的 casCellsBusy 方法"></a>5.3.5 LongAdder 类的 casCellsBusy 方法</h3><p>casCellsBusy 方法的代码很简单，就是将 cellsBusy 成员的值改为 1 ，表示目前的 cells 数组在初始化或扩容中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">casCellsBusy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="5-3-6-求和"><a href="#5-3-6-求和" class="headerlink" title="5.3.6 求和"></a>5.3.6 求和</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sum()方法很简单，就是将base值及所有cell值进行累加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、使用-AtomicStampedReference-解决-ABA-问题"><a href="#六、使用-AtomicStampedReference-解决-ABA-问题" class="headerlink" title="六、使用 AtomicStampedReference 解决 ABA 问题"></a>六、使用 AtomicStampedReference 解决 ABA 问题</h2><p>JDK 的提供了一个类似 AtomicStampedReference 类来解决 ABA 问题。<br>AtomicStampReference 在 CAS 的基础上增加了一个 Stamp 整型 印戳（或标记），使用这个印戳可以来觉察数据是否发生变化，给数据带上了一种实效性的检验。<br>AtomicStampReference 的 compareAndSet 方法首先检查当前的对象引用值是否等于预期引用，<br>并且当前印戳（ Stamp ）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳<br>（ Stamp ）标志的值更新为给定的更新值。</p><h2 id="6-1-AtomicStampReference-的构造器"><a href="#6-1-AtomicStampReference-的构造器" class="headerlink" title="6.1 AtomicStampReference 的构造器"></a>6.1 AtomicStampReference 的构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> initialRef初始引用  </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> initialStamp初始戳记  </span><br><span class="hljs-comment">*/</span><br>AtomicStampedReference(V initialRef, <span class="hljs-keyword">int</span> initialStamp)<br></code></pre></td></tr></table></figure><h2 id="6-2-AtomicStampReference-的常用的几个方法"><a href="#6-2-AtomicStampReference-的常用的几个方法" class="headerlink" title="6.2 AtomicStampReference 的常用的几个方法"></a>6.2 AtomicStampReference 的常用的几个方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>介绍                 </th></tr></thead><tbody><tr><td>public V getRerference()</td><td>引用的当前值</td></tr><tr><td>public int getStamp()</td><td>返回当前的”戳记”</td></tr><tr><td>public boolean weakCompareAndSet(V expectedReference,V newReference,int expectedStamp,int newStamp)</td><td>expectedReference 引用的旧值;newReference 引用的新值;expectedStamp 旧的戳记;newStamp 新的戳记  </td></tr></tbody></table></div><h2 id="6-3-例子"><a href="#6-3-例子" class="headerlink" title="6.3 例子"></a>6.3 例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>    AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();<br>    success = atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;success:&quot;</span> + success + <span class="hljs-string">&quot;;reference:&quot;</span> + <span class="hljs-string">&quot;&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;;stamp:&quot;</span> + atomicStampedReference.getStamp());<br>    <span class="hljs-comment">//修改印戳，更新失败</span><br>    stamp = <span class="hljs-number">0</span>;<br>    success = atomicStampedReference.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;success:&quot;</span> + success + <span class="hljs-string">&quot;;reference:&quot;</span> + <span class="hljs-string">&quot;&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;;stamp:&quot;</span> + atomicStampedReference.getStamp());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">java中的CAS操作</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型模式的讨论</title>
    <link href="http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/"/>
    <id>http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/</id>
    <published>2023-03-13T22:14:00.000Z</published>
    <updated>2023-03-14T10:43:18.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>封装变化是很多行为模式的主题。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式依据这个对象 来命名。例如，</p><ul><li>一个 Strategy 对象封装一个算法。</li><li>一个 State 对象封装一个与状态相关的行为。</li><li>一个 Mediator对象封装对象间的协议。</li><li>一个 Iterator 对象封装访问和遍历一个聚集对象中的各个构件的方法。</li></ul><p>这些模式描述了程序中很可能会改变的方面。大多数模式有两种对象:封装该方面特征的新对象，和使用这些新的对象的已有对象。如果不使用这些模式的话，通常这些新对象的功能就会变成这些已有对象的难以分割的一部分。例如，一个 Strategy 的代码可能会被嵌入到其Context类中，而一个State的代码可能会在该状态的Context类中直接实现。<br>但不是所有的对象行为模式都象这样分割功能 。 例如 ， ChainofResponsibility 可以处理任意数目的对象(即一个链)，而所有这些对象可能已经存在于系统中了。<br>职责链说明了行为模式间的另一个不同点:并非所有的行为模式都定义类之间的静态通信关系。职责链提供在数目可变的对象间进行通信的机制。其他模式涉及到一些作为参数传递的对象。</p><h2 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h2><p>一些模式引入总是被用作参数的对象。例如 Visitor。一个Visitor对象是一个多态的Accept操作的参数 ， 这个操作作用于该Visitor对象访问的对象 。 虽然以前通常代替Visitor模式的方法是将Visitor代码分布在一些对象结构的类中，但visitor从来都不是它所访问的对象的一部分。<br>其他模式定义一些可作为令牌到处传递的对象，这些对象将在稍后被调用。Command和Memento都属于这一类。在Command中，令牌代表一个请求;而在Memento中，它代表在一个对象在某个特定时刻的内部状态。在这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会意识到这一点。但这里还有一些区别:在Command模式中多态很重要，因为执行Command对象是一个多态的操作。相反，Memento接口非常小，以至于备忘录只能作为一个值传递。因此它很可能根本不给它的客户提供任何多态操作。</p><h2 id="通信应该被封装还是被分布"><a href="#通信应该被封装还是被分布" class="headerlink" title="通信应该被封装还是被分布"></a>通信应该被封装还是被分布</h2><p>Mediator和Observer是相互竞争的模式。它们之间的差别是，Observer通过引入Observer和Subject对象来分布通信，而Mediator对象则封装了其他对象间的通信 。<br>在Observer模式中，不存在封装一个约束的单个对象，而必须是由Observer和Subject对象相互协作来维护这个约束。通信模式由观察者和目标连接的方式决定:一个目标通常有多个观察者，并且有时一个目标的观察者也是另一个观察者的目标。Mediator模式的目的是集中而不是分布。它将维护一个约束的职责直接放在一个中介者中。<br>我们发现生成可复用的Observer和Subject比生成可复用的Mediator容易一些。Observer模式有利于Observer和Subject间的分割和松耦合，同时这将产生粒度更细,从而更易于复用的类。<br>另一方面，相对于Observer，Mediator中的通信流更容易理解。观察者和目标通常在它们被创建后很快即被连接起来，并且很难看出此后它们在程序中是如何连接的。如果你了解Observer模式，你将知道观察者和目标间连接的方式是很重要的，并且你也知道寻找哪些连接。然而，Observer模式引入的间接性仍然会使得一个系统难以理解。<br>Smalltalk中的Observer可以用消息进行参数化以访问Subject的状态，因此与在C++中的Observer相比，它们具有更大的可复用性。这使得Smalltalk中Observer比Mediator更具吸引力。 因此一个Smalltalk程序员通常会使用Observer而一个C++程序员则会使用Mediator。</p><h2 id="对发送者和接收者解耦"><a href="#对发送者和接收者解耦" class="headerlink" title="对发送者和接收者解耦"></a>对发送者和接收者解耦</h2><p>当合作的对象直接互相引用时，它们变得互相依赖，这可能会对一个系统的分层和重用性产生负面影响。命令、观察者、中介者，和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。<br>命令模式使用一个Command对象来定义一个发送者和一个接收者之间的绑定关系，从而支持解耦，如下图所示。<br><img src="/img/DesignPatterns/26.png" alt="github"><br>Command对象提供了一个提交请求的简单接口(即Execute操作)。 将发送者和接收者之间的连接定义在一个单独的对象使得该发送者可以与不同的接收者一起工作。这就将发送者与接收者解耦，使发送者更易于复用。此外，可以复用Command对象，用不同的发送者参数化一个接收者。虽然Command模式描述了避免使用生成子类的实现技术，名义上每一个发送者-接收者连接都需要一个子类。<br>观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者(目标)与接收 者(观察者)解耦。 O b s e r v e r 定义了一个比 C o m m a n d 更 松 的 发 送 者 - 接 收 者 绑 定 ， 因 为 一 个 目标可能有多个观察者，并且其数目可以在运行时变化，如下图所示。<br><img src="/img/DesignPatterns/26_1.png" alt="github"><br>观察者模式中的Subject和Observer接口是为了处理Subject的变化而设计的，因此当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。<br>中介者模式让对象通过一个Mediator对象间接的互相引用，从而对它们解耦，如下图所示。<br><img src="/img/DesignPatterns/26_2.png" alt="github"><br>一个Mediator对象为各Colleague对象间的请求提供路由并集中它们的通信 。 因此各Colleague对象仅能通过Mediator接口相互交谈。因为这个接口是固定的，为增加灵活性Mediator可能不得不实现它自己的分发策略。可以用一定方式对请求编码并打包参数，使得Colleague对象可以请求的操作数目不限。<br>中介者模式可以减少一个系统中的子类生成，因为它将通信行为集中到一个类中而不是 将其分布在各个子类中。然而，特别的分发策略通常会降低类型安全性。<br>最后，职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦，如下图所示。<br><img src="/img/DesignPatterns/26_3.png" alt="github"><br>因为发送者和接收者之间的接口是固定的，职责链可能也需要一个定制的分发策略。因此它与Mediator一样存在类型安全的问题 。 如果职责链已经是系统结构的一部分，同时在链上的多个对象中总有一个可以处理请求，那么职责链将是一个很好的将发送者和接收者解耦的方法。此外，因为链可以被简单的改变和扩展，从而该模式提供了更大的灵活性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了少数例外情况，各个行为设计模式之间是相互补充和相互加强的关系。例如，一个职责链中的类可能包括至少一个Template Method的应用。该模板方法可使用原语操作 确定该对象是否应处理该请求并选择应转发的对象。职责链可以使用Command模式将请求表示为对象。Interpreter可以使用State模式定义语法分析上下文 。 迭代器可以遍历一个聚合 ， 而访问者可以对它的每一个元素进行一个操作。行为模式也与能其他模式很好地协同工作。例如，一个使用Composite模 式 的 系 统 可以使用一个访问者对该复合的各成分进行一些操作。它可以使用职责链使得各成分可以通过它们的父类访问某些全局属性。它也可以使用Decorater对该复合的某些部分的这些属性进行改写。它可以使用Observer模式将一个对象结构与另一个对象结构联系起来，可以使用State模式使得一个构件在状态改变时可以改变自身的行为。复合本身可以使用构建者中的方法创建，并且它可以被系统中的其他部分当作一个原型模式。 设计良好的面向对象式系统通常有多个模式镶嵌在其中，但其设计者却未必使用这些术语进行思考。然而，在模式级别而不是在类或对象级别上的进行系统组装可以使我们更方便地获取同等的协同性。</p>]]></content>
    
    
    <summary type="html">行为型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式的讨论</title>
    <link href="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/"/>
    <id>http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/</id>
    <published>2023-02-27T07:43:01.000Z</published>
    <updated>2023-03-13T10:03:20.937Z</updated>
    
    <content type="html"><![CDATA[<p>结构型模式依赖于同一个很小的语言机制集合构造代码和对象：单继承和多重继承机制用于基于类的模式，而对象组合机制用于对象式模式。但是这些相似性掩盖了这些模式的不同意图。</p><h2 id="适配器-与-桥接"><a href="#适配器-与-桥接" class="headerlink" title="适配器 与 桥接"></a>适配器 与 桥接</h2><p>具有一些共同的特征。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。</p><p>这些模式的不同之处主要在于它们各自的用途。<br>适配器模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。 这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。<br>另一方面， 桥接模式则对抽象接口与它的(可能是多个)实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。 桥接模式也会在系统演化时适应新的实现。</p><p>由于这些不同点，适配器和桥接模式通常被用于软件生命周期的不同阶段。当你发现两个不兼容的类必须同时工作时，就有必要使用适配器模式，其目的一般是为了避免代码重复。此处耦合不可预见。相反，桥接的使用者必须事先知道:一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的。适配器模式在类已经设计好后实施;而桥接模式在设计类之前实施。这并不意味着适配器模式不如桥接模式，只是因为它们针对了不同的问题。<br>外观模式定义一个新的接口吗，而适配器则复用一个原有的接口。记住，适配器使两个已有的接口协同工作，而不是定义一个全新的接口。</p><h2 id="组装、装饰者-与-代理"><a href="#组装、装饰者-与-代理" class="headerlink" title="组装、装饰者 与 代理"></a>组装、装饰者 与 代理</h2><p>组装模式和装饰者模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。这一共同点可能会使你认为， 装饰者对象是一个退化的组装 ， 但这一观点没有领会装饰者模式要点。相似点仅止于递归组合，同样，这是因为这两个模式的目的不同。<br>装饰者旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。 组装则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰， 而在于表示。<br>尽管它们的目的截然不同，但却具有互补性。因此组装和装饰者模式通常协同使用。在使用这两种模式进行设计时，我们无需定义新的类，仅需将一些对象插接在一起即可构建应用 。 这时系统中将会有一个抽象类 ，它有一些组装子类和装饰者子类 ， 还有一些实现系统的基本构建模块。此时， 组装和装饰者将拥有共同的接口。从装饰者模式的角度看， 组装是一个ConcreteComponent 。而从组装模式的角度看，装饰者则是一个Leaf。当然，他们不一定要同时使用，正如我们所见，它们的目的有很大的差别。<br>另一种与装饰者模式结构相似的模式是代理 。 这两种模式都描述了怎样为对象提供一定程度上的间接引用，代理和装饰者对象的实现部分都保留了指向另一个对象的指针 ， 它们向这个对象发送请求。然而同样，它们具有不同的设计目的。<br>像装饰者模式一样， 代理模式构成一个对象并为用户提供一致的接口。但与装饰者模式不同的是， 代理模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如，实体在远程设备上，访问受到限制或者实体是持久存储的。<br>在代理模式中，实体定义了关键功能，而代理提供(或拒绝)对它的访问。在装饰者模式中，组件仅提供了部分功能，而一个或多个装饰者负责完成其他功能。装饰者模式适用于编译时不能(至少不方便)确定对象的全部功能的情况。这种开放性使递归组合成为装饰者模式中一个必不可少的部分。而在代理模式中则不是这样，因为代理模式强调一种关系(代理与它的实体之间的关系)，这种关系可以静态的表达。<br>模式间的这些差异非常重要，因为它们针对了面向对象设计过程中一些特定的经常发生 问题的解决方法。但这并不意味着这些模式不能结合使用。可以设想有一个代理 - 装饰者 ， 它可以给代理添加功能，或是一个装饰者 - 代理用来修饰一个远程对象 。 尽管这种混合可能有用(我们手边还没有现成的例子)，但它们可以分割成一些有用的模式。</p>]]></content>
    
    
    <summary type="html">结构型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型模式的讨论</title>
    <link href="http://example.com/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/"/>
    <id>http://example.com/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/</id>
    <published>2023-02-25T17:01:24.000Z</published>
    <updated>2023-03-10T07:34:56.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建型模式的讨论"><a href="#创建型模式的讨论" class="headerlink" title="创建型模式的讨论"></a>创建型模式的讨论</h2><p>用一个系统创建的那些对象的类对系统进行参数化有两种常用方法。一种是生成创建对象的类的子类，这对应于使用工厂方法模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。<br>另一种对系统进行参数化的方法更多的依赖于对象复合:定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是抽象工厂、 构建者和原形模式的关键特征。这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”。</p><ul><li>抽象工厂由这个工厂对象产生多个类的对象。 </li><li>构建者由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。</li><li>原型由该工厂对象通过拷贝原型对象来创建产品对象。</li></ul>]]></content>
    
    
    <summary type="html">创建型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-目录</title>
    <link href="http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/"/>
    <id>http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/</id>
    <published>2023-02-18T15:04:05.000Z</published>
    <updated>2023-03-14T09:30:08.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我在看<strong>小鹏哥</strong>写的<strong>设计模式</strong>中一句话让我很有感触：<br><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">讲道理没有ifelse解决不了的逻辑，不⾏就在加⼀⾏!<br></code></pre></td></tr></table></figure><br>这个现象太真实了。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>模式在构造复杂系统时的重要性早已在其他领域中被认可。软件领域中的设计模式为开发人员提供了一种 使用专家设计经验的有效途径。在使用设计模式前，最好需要熟悉“类型”和“多态”，或“接口”继承与“实现”继承的关系。</p><p>设计模式捕获了随时间进化与发展 的问题的求解方法，因此它们并不是人们从一开始就采用的设计方案。它们反映了不为人知的 重新设计和重新编码的成果，而这些都来自软件开发者为了设计出灵活可复用的软件而长时间 进行的艰苦努力。设计模式捕获了这些解决方案，并用简洁易用的方式表达出来。</p><h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><h3 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2. 里氏代换原则"></a>2. 里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3. 依赖倒转原则"></a>3. 依赖倒转原则</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5-迪米特法则，又称最少知道原则"><a href="#5-迪米特法则，又称最少知道原则" class="headerlink" title="5. 迪米特法则，又称最少知道原则"></a>5. 迪米特法则，又称最少知道原则</h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6. 合成复用原则"></a>6. 合成复用原则</h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="23个设计模式"><a href="#23个设计模式" class="headerlink" title="23个设计模式"></a>23个设计模式</h1><p>下面介绍了各个模式的类型及大致范围</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">创建型</th><th style="text-align:center">结构型</th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center">范围</td><td style="text-align:center">类</td><td style="text-align:center">工厂函数</td><td style="text-align:center">适配器(类)</td><td style="text-align:center">模版方法、解释器</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">对象</td><td style="text-align:center">抽象工厂、构建者、原型模式、单例模式</td><td style="text-align:center">适配器(对象)、桥接模式、组成模式、装饰者、外观模式、享元模式、代理模式</td><td style="text-align:center">责任链、命令模式、迭代器、中介者、备忘录、观察者、状态模式、策略模式、访问者</td></tr></tbody></table></div><p>大致分类的方式：</p><ol><li>完成什么工作：创建型模式与对象的创建有关;结构型模式处理类或对象的组合;行为型 模式对类或对象怎样交互和怎样分配职责进行描述。</li><li>用于类还是用于对象：类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了；对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。</li></ol><p>下图中也描述了这些模式之间的关系<br><img src="/img/DesignPatterns/00.png" alt="github"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p><a href="https://yangandmore.github.io/2023/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/">工厂方法</a><br><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/">抽象工厂</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/">构建者</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/">原型模式</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5/">单例模式</a><br><a href="https://yangandmore.github.io/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/">总结</a></p><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">适配器(对象)</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/">桥接模式</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/">组成模式</a><br><a href="https://yangandmore.github.io/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/">装饰者</a><br><a href="https://yangandmore.github.io/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/">外观模式</a><br><a href="https://yangandmore.github.io/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">享元模式</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/">代理模式</a><br><a href="https://yangandmore.github.io/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/">总结</a></p><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/">责任链</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/">命令模式</a><br><a href="https://yangandmore.github.io/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/">迭代器</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/">中介者</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/">备忘录</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/">观察者</a><br><a href="https://yangandmore.github.io/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/">状态模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/">策略模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/">访问者</a><br><a href="https://yangandmore.github.io/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/">总结</a></p>]]></content>
    
    
    <summary type="html">设计模式-目录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-14T09:54:01.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>提供一个接口来完成计算方式。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来，就创建需要对比的类型，并创建对应的对比起就可以了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">Number</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Number n1, Number n2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n1.a &gt; n2.a &amp;&amp; n1.b &gt; b2.b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后并使用这个对比工具即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Number n1 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        Number n2 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        <br>        Comparator com = <span class="hljs-keyword">new</span> NumberComparator();<br>        <span class="hljs-keyword">int</span> res = com.compara(n1, n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>如果需要修改算法，我们只需要增加对比器的实现即可。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一<br>个类的方法。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的<br>算法。当这些变体实现为一个算法的类层次时 [ H O 8 7 ] ,可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数<br>据结构。</li><li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。<br>将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/21.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Strategy 和 Context 相互作用以实现选定的算法。当算法被调用时, Context 可以将该算法 所需要的所有数据都传递给该 Strategy 。或者， Context 可以将自身作为一个参数传递给Strategy操作。这就让 Strategy在需要时可以回调 Context 。</li><li>Context 将它的客户的请求转发给它的 Strategy 。客户通常创建并传递一个 ContextStrategy对象给该 Context ;这样 , 客户仅与 Context 交互。通常有一系列的 ContextStrategy 类可供客户从中选择。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Strategy 模式有下面的一些优点和缺点 :</p><ol><li>相关算法系列<br> Strategy类层次为Context定义了一系列的可供重用的算法或行为 。 继承有助于析取出这些算法中的公共功能。</li><li>一个替代继承的方法<br> 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类 ， 从而给它以不同的行为 。 但这会将行为硬行编制到Context中，而将 算法的实现与Context的实现混合起来 , 从而使Context难以理解 、 难以维护和难以扩展 ， 而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、 易于理解、易于扩展。</li><li>消除了一些条件语句<br> Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 , 很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句 。<br> 例如 , 不用Strategy, 正文换行的代码可能是象下面这样 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(type) &#123;<br>    <span class="hljs-keyword">case</span>: <br>    <span class="hljs-keyword">case</span><br>&#125;<br></code></pre></td></tr></table></figure> Strategy模式将换行的任务委托给一个Strategy对象从而消除了这些 case 语句 : <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">compositor.compose();<br></code></pre></td></tr></table></figure> 含有许多条件语句的代码通常意味着需要使用Strategy模式。</li><li>实现的选择<br> Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间/空间权衡取舍要求从不同策略中进行选择。</li><li>客户必须了解不同的Strategy<br> 本模式有一个潜在的缺点 ， 就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同 。 此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。</li><li>Strategy和Context之 间 的 通 信 开 销<br> 无论各个ContextStrategy实现的算法是简单还是复杂 , 它们都共享Strategy定义的接口。因此很可能某些ContextStrategy不会都用到所有通过这个接口传递给它们的信息;简单的ContextStrategy可能不使用其中的任何信息!这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。</li><li>增加了对象的数目<br> Strategy增加了一个应用中的对象的数目。有时你可以将Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的Strategy不应在各次调用之间维护状态。 </li></ol>]]></content>
    
    
    <summary type="html">策略模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模版模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:21:35.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>准备算法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>        water();<br>        eat();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>final表示无法重写，因此该方法只能使用，无法覆盖，该顺序已经被固定成一个模板。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowerTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>控制子类扩展。模板方法只在特定点调用“许在这些点进行扩展。hook”操作， 这样就只允许在这些点进行扩展。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/22.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>ConcreteClass 靠 AbstractClass 来实现算法中不变的步骤。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。 模板方法导致一种反向的控制结构，这种结构有时被称为“好莱坞法则”，即“别找我们，我们找你” [ S w e 8 5 ] 。 这指的是一个父类调用一个子类的操作，而不是相反 。 模板方法调用下列类型的操作:</p><ul><li>具体的操作(ConcreteClass或对客户类的操作)。</li><li>具体的AbstractClass的操作(即，通常对子类有用的操作)。</li><li>原语操作(即，抽象操作)。</li><li>FactoryMethod。</li><li>钩子操作(hook operations)，它提供了缺省的行为，子类可以在必要时进行扩展。一个钩子操作在缺省操作通常是一个空操作。</li></ul><p>很重要的一点是模板方法应该指明哪些操作是钩子操作(可以被重定义)以及哪些是抽象操作(必须被重定义)。要有效地重用一个抽象类，子类编写者必须明确了解哪些操作是设计为有待重定义的。<br>子类可以通过重定义父类的操作来扩展该操作的行为，其间可显式地调用父类操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DerivedClass::Operation() &#123;<br>    ParentClass::Operation();<br>&#125;<br></code></pre></td></tr></table></figure><br>不幸的是，人们很容易忘记去调用被继承的行为。我们可以将这样一个操作转换为一个模板方法，以使得父类可以对子类的扩展方式进行控制。也就是，在父类的模板方法中调用钩子操作。子类可以重定义这个钩子操作:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParentClass::Operation() &#123;<br>    HookOperation();<br>&#125;<br></code></pre></td></tr></table></figure><br>ParentClass本身的HookOperation什么也不做 :<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParentClass::HookOperation() &#123;&#125;<br></code></pre></td></tr></table></figure><br>子类重定义HookOperation以扩展它的行为:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DerivedClass::HookOperation &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">模版模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:29:51.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>专家在评审项目时，不同专家针对不同项目进行评审</p><p>首先项目部分<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Project</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>创建两个项目类型<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> FoodProject extends Project&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> safe;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FoodProject</span><span class="hljs-params">(String name, String safe)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.safe = safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToolProject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> quality;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToolProject</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> quality)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.quality = quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>针对项目，建立了食评项目和工具项目两个类型，针对他们的数据分别为食品安全等级和工具效率等级。</p><p>接下来就是不同的专家分别评审两者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject foodProject)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject toolProject)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后针对不同专家，处理两者的方式也不同<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVisitor</span> <span class="hljs-title">implement</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;食评项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,安全等级:&quot;</span>+project.getSafe());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;工具项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,质量等级:&quot;</span>+project.getQuality());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样大致完成基本功能</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 访问者使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/23.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>一个使用 Visitor模式的客户必须创建一个ConcreteVisitor对象 ， 然后遍历该对象结构 ，并用该访问者访问每一个元素。</li><li>当一个元素被访问时，它调用对应于它的类的 Visitor操作 。 如果必要 ，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。<br>下面的交互框图说明了一个对象结构、一个访问者和两个元素之间的协作。<br><img src="/img/DesignPatterns/23_1.png" alt="github"></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>下面是访问者模式的一些优缺点:</p><ol><li>访问者模式使得易于增加新的操作<br> 访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反， 如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。</li><li>访问者集中相关的操作而分离无关的操作<br> 相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。</li><li>增加新的ConcreteElement类很困难<br> Visitor模式使得难以增加新的 Element 的子类。每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个ConcretVisitor类中实现相应的操作。有时可以在 Visitor中提供一个缺省的实现，这一实现可 以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。<br> 所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化，是作用于对象结构上的算法呢还是构成该结构的各个对象的类。如果老是有新的ConcretElement 类加入进来的话，Vistor类层次将变得难以维护 。 在这种情况下 ，直接在构成该结构的类中定义这些操作可能更容易一些。如果Element类层次是稳定的 ，而你不断地增加操作获修改算法 ，访问者模式可以帮助你管理这些改动。</li><li>通过类层次进行访问<br> 个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构，同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作。</li><li>累积状态<br> 当访问者访问对象结构中的每一个元素时，它可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局变量。</li><li>破坏封装<br> 访问者方法假定ConcreteElement接口的功能足够强 ， 足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。</li></ol>]]></content>
    
    
    <summary type="html">访问者模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Spire包处理文档</title>
    <link href="http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-02-16T06:49:03.842Z</updated>
    
    
    <summary type="html">使用Spire包处理文档</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"/>
    <id>http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-03-13T13:36:52.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先创建状态机，或者说上下文。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        state.start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        state.close(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>再看看状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来建立对应的两个状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.close(<span class="hljs-keyword">new</span> CloseState());<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.start(<span class="hljs-keyword">new</span> StartState());<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>准备好后就可以使用了。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        <br>        context.setState(<span class="hljs-keyword">new</span> StartState());<br>        context.close();<br>        context.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/20.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。</li><li>Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context 。</li><li>Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context ，一旦一个Context配置完毕 , 它的客户不再需要直接与状态对象打交道。</li><li>Context 或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>State 模式有下面一些效果 :</p><ol><li>它将与特定状态相关的行为局部化 ， 并且将不同状态的行为分割开来<br> State 模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某 一个 State 子类中 ,所以通过定义新的子类可以很容易的增加新的状态和转换 。<br> 另一个方法是使用数据值定义内部状态并且让 Context 操 作 来 显 式 地 检 查 这 些 数 据 。 但 这 样将会使整个Context的实现中遍布看起来很相似的条件语句或case语句 。 增加一个新的状态可能需要改变若干个操作 , 这就使得维护变得复杂了。<br> State 模式避免了这个问题 , 但可能会引入另一个问题 , 因为该模式将不同状态的行为分布在多个State子类中 。 这就增加了子类的数目，相对于单个类的实现来说不够紧凑 。 但是如果有许多状态时这样的分布实际上更好一些 , 否则需要使用巨大的条件语句。<br> 正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码 。 决定状态转移的逻辑不在单块的 if 或 switch 语句中 , 而是分布在 State 子类之间。 将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。 这将使代码结构化并使其意图更加清晰。</li><li>它使得状态转换显式化<br> 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且,State对象可保证Context不会发生内部状态不一致的情况 ， 因为从Context的角度看 ， 状态转换是原子的—只需重新绑定一个变量 ( 即 Context 的 State对象变量 ) ， 而无需为多个变量赋值</li><li>State对象可被共享<br> 如果State对象没有实例变量 — 即它们表示的状态完全以它们的类型来编码 — 那么各 Context 对象可以共享一个 State 对象。当状态以这种方式被共享时 , 它们必然是没有内部状态 , 只有行为的轻量级对象</li></ol>]]></content>
    
    
    <summary type="html">状态模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:12:42.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先是中介者接口定义，接口中的提供了功能定义了赢的人是谁，输的人有谁，以及赢了多少<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及实现该接口的对象，主要对用户进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mediator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span> </span>&#123;<br>        winer.add(data);<br>        foreach(Colleage c : losers) &#123;<br>            c.subtraction(data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是用户的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后我们针对用户进行实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data += data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data -= data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>主要通过中介者来对同事的数据进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Mediator mediator = <span class="hljs-keyword">new</span> ConcreteMediator();<br>        <br>        Colleague c1 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">100</span>);<br>        Colleague c2 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">800</span>);<br>        Colleague c3 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">400</span>);<br>        <br>        mediator.win(c1, <span class="hljs-number">10</span>, c2, c3);<br>        mediator.win(c3, <span class="hljs-number">100</span>, c1);<br>        mediator.win(c2, -<span class="hljs-number">10</span>, c3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/17.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>中介者模式有以下优点和缺点 :</p><ol><li>减少了子类生成<br> Mediator 将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成 Mediator 的子类即可。这样各个 Colleague 类可被重用。</li><li>它将各 Colleague 解耦<br> Mediator 有利于各 Colleague 间的松耦合 . 你可以独立的改变和复用各 Colleague 类和 Mediator 类。</li><li>它简化了对象协议<br> 用 Mediator 和各 Colleague 间的一对多的交互来代替多对多的交互 。一对多的关系更易于理解、维护和扩展。</li><li>它对对象如何协作进行了抽象<br> 将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。</li><li>它使控制集中化<br> 中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议 , 它可能变得比任一个 Colleague 都复杂。 这可能使得中介者自身成为一个难于维护的庞然大物。</li></ol>]]></content>
    
    
    <summary type="html">中介者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:25:26.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先定义观察接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后创建多个观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user:&quot;</span>+arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是被观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; obs;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Observable</span><span class="hljs-params">()</span> </span>&#123;<br>        obs = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">if</span> (!obs.contains(o)) &#123;<br>            obs.addElement(o);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        obs.removeElement(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        notifyObservers(<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * a temporary array buffer, used as a snapshot of the state of</span><br><span class="hljs-comment">         * current Observers.</span><br><span class="hljs-comment">         */</span><br>        Object[] arrLocal;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!changed)<br>                <span class="hljs-keyword">return</span>;<br>            arrLocal = obs.toArray();<br>            clearChanged();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arrLocal.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>            ((Observer)arrLocal[i]).update(<span class="hljs-keyword">this</span>, arg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        obs.removeAllElements();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> changed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> obs.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后继承该类，创建被观察者。这里会发送一条消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setChanged();<br>        notifyObservers(msg);<br>        <span class="hljs-keyword">this</span>.clearChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Observer u1 = <span class="hljs-keyword">new</span> UserObserver();<br>        Observer u2 = <span class="hljs-keyword">new</span> UserObserver();<br>        Subject subject = <span class="hljs-keyword">new</span> Subject();<br>        subject.addObserver(u1);<br>        subject.addObserver(u2);<br>        <br>        subject.setMessage(<span class="hljs-string">&quot;消息1&quot;</span>);<br>        subject.setMessage(<span class="hljs-string">&quot;消息2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象是紧密耦合的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/19.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>当 ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。</li><li>在得到一个具体目标的改变通知后 , ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。</li></ul><p>下面的交互图说明了一个目标对象和两个观察者之间的协作 :<br><img src="/img/DesignPatterns/19_1.png" alt="github"></p><p>注意发出改变请求的 Observer对象并不立即更新 , 而是将其推迟到它从目标得到一个通知之后。 Notify不总是由目标对象调用。它也可被一个观察者或其它对象调用 。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Observer模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者, 反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。<br>下面是观察者模式其它一些优缺点 :</p><ol><li>目标和观察者间的抽象耦合<br> 一个目标所知道的仅仅是它有一系列观察者 , 每个都符合抽象的Observer类的简单接口 。 目标不知道任何一个观察者属于哪一个具体的类 。 这样目标和观察者之间的耦合是抽象的和最小的。<br> 因为目标和观察者不是紧密耦合的 , 它们可以属于一个系统中的不同抽象层次。一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它 , 这样就保持了系统层次的完整。如果目标和观察者混在一块 , 那么得到的对象要么横贯两个层次 (违反了层次性 ), 要么必须放在这两层的某一层中 (这可能会损害层次抽象 )。</li><li>支持广播通信<br> 不像通常的请求, 目标发送的通知不需指定它的接收者。通知被自动广播给所有已向该目标对象登记的有关对象。目标对象并不关心到底有多少对象对自己感兴趣 ; 它唯一的责任就是通知它的各观察者。这给了你在任何时刻增加和删除观察者的自由。处理还是忽略一个通知取决于观察者。</li><li>意外的更新<br> 因为一个观察者并不知道其它观察者的存在 , 它可能对改变目标的最终代价一无所知。在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外 , 如果依赖准则的定义或维护不当，常常会引起错误的更新 , 这种错误通常很难捕捉。<br> 简单的更新协议不提供具体细节说明目标中什么被改变了 , 这就使得上述问题更加严重。 如果没有其他协议帮助观察者发现什么发生了改变，它们可能会被迫尽力减少改变。</li></ol>]]></content>
    
    
    <summary type="html">观察者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:19:19.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mement <span class="hljs-title">saveCurrentStateToMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(state);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = m.getState();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面建立了原发器的状态字段，以及提供对当前状态的保存以及恢复功能，使用了另一个类来存储当前状态。但是他并不会保存这些状态，只是用这些记录来恢复。</p><p>针对每一次记录都使用下面的对象来单独保存。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后使用一个备忘录管理类来管理这些备忘录<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CareTaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Memento&gt; datas = <span class="hljs-keyword">new</span> ArrayList&lt;Memento&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        datas.add(m)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> datas.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Originator originator = <span class="hljs-keyword">new</span> Originator();<br>        CareTaker careTaker = <span class="hljs-keyword">new</span> CareTaker();<br>        originator.setState(<span class="hljs-string">&quot;状态1&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态2&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态3&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        <br>        originator.restore(careTaker.get(<span class="hljs-number">0</span>));<br>        originator.restore(careTaker.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>必须保存一个对象在某一个时刻的 (部分)状态, 这样以后需要时它才能恢复到先前的状态。</li><li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/18.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>管理器向原发器请求一个备忘录 , 保留一段时间后 ,将其送回给原发器 , 如下面的交互图所示。有时管理者不会将备忘录返回给原发器 , 因为原发器可能根本不需要退到先前的状态。</li><li>备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。<br><img src="/img/DesignPatterns/18_1.png" alt="github"></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>备忘录模式有以下一些效果 :</p><ol><li>保持封装边界<br> 使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发 器之外的信息。该模式把可能很复杂的 Originator 内部信息对其他对象屏蔽起来 , 从而保持了封装边界。</li><li>它简化了原发器<br> 在其他的保持封装性的设计中 , Originator负责保持客户请求过的内部 状态版本。这就把所有存储管理的重任交给了 Originator 。 让客户管理它们请求的状态将会简化 Originator, 并且使得客户工作结束时无需通知原发器 。</li><li>使用备忘录可能代价很高<br> 如果原发器在生成备忘录时必须拷贝并存储大量的信息 , 或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。除非封装和恢复 Originator 状态的开销不大 ,否则该模式可能并不合适。</li><li>定义窄接口和宽接口<br> 在一些语言中可能难以保证只有原发器可访问备忘录的状态。</li><li>维护备忘录的潜在代价<br> 管理器负责删除它所维护的备忘录。然而 , 管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。</li></ol>]]></content>
    
    
    <summary type="html">备忘录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
