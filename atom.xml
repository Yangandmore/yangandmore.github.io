<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小杨的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-30T13:33:39.849Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql学习</title>
    <link href="http://example.com/2023/08/18/Mysql%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/08/18/Mysql%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-08-18T20:31:00.000Z</published>
    <updated>2023-08-30T13:33:39.849Z</updated>
    
    <content type="html"><![CDATA[<p>1、了解MySQL架构<br>关系型数据库，结构化查询语句。<br>关系型数据库基于表去维护的，格式是一致的，可以统一用sql语言去操作，没有kv结构灵活，性能也没有那么高。</p><p>系统库<br>mysql，系统信息表。如权限、插件、主题、帮助。<br>information_schema，日志、innodb等数据、线程。<br>performance_schema,</p><p>2、一条sql执行要需要什么？</p><ol><li>跟服务器建立连接<ol><li>变量来管理连接<br> Threads_cached 缓存线程数<br> Threads_created 打开线程数(show full processlist , 删除链接kill xxxx)</li><li>配置(set @@GLOBAL.max_connections=10;)<br> max_connections 服务最大的开启数（默认151）<br> wait_timeout 等待时间，超过则关闭（默认8小时）。</li></ol></li><li>解析器：词法+语法解析器</li><li>预处理：提供该功能，但可以控制是否使用<br> (prepare pre_product from ‘select * from product where name=?’;)<br> (set @name=’OR 1=1 —‘)<br> (execute pre_product using @name)<ol><li>可以提升性能：预处理了sql语句，只需要配置参数即可</li><li>防止sql注入：因为参数化执行，不是拼接参数</li></ol></li><li>优化器：基于服务最快方式执行语句，基于内存、cpu消化等情况<ol><li>可配置<code>--optimizer_switch</code><br>(select @@optimizer_switch)</li></ol></li><li>执行器<br> 存储成：用来真正存执行、储数据，基于不同存储引擎来做不同的操作（相当于插件）。<br> (select @@datadir)</li></ol><p>3、innoDB储存引擎<br>会保存到磁盘，并且每个表都会有一个ibd文件。<br>表空间：数据如何存储到磁盘的。</p><p>独立表空间：每个表都有一个独立的ibd数据文件（默认开启select @@innodb_file_per_table）<br>系统表空间：所有的表数据都在一个文件或多个指定文件，ibdata文件(innodb_data_file_path)<br>通用表空间：可以自己指定哪个表到哪个文件（create tablespace huihui_namespace datafile add ‘/path/path.ibd’ engine=innodb）</p><p>文件如何保存的？<br>最底层、原子单位为行、row。不是通过row直接保存文件的。<br>page页，class结构，里面保存的是行数据，page是保存到文件里面的。页的大小数是可以设置的(innodb_page_size,默认16k)。一个page页能保存的行数据也是有大小的，行为4k，这一页保存4行数据<br>extent区 会有很多的page页，默认64个page页<br>segement段，分为数据段、索引段、目录段等</p><p>bufferpool 内存区间，防止每次实时的跟磁盘进行交互。<br>假如：select where id=5的数据<br>之前，每次查询都需要与磁盘进行IO<br>之后，先判断bufferpool有木有这个数据，如果有直接返回，如果没有才需要到磁盘进行交互，并且保存到bufferpool。保存的数据所在的page页。</p><p>bufferpool与磁盘的交互最小单位是整个page页，默认是128M。(innodb_bufferpool_size)</p><p><strong>内存和磁盘的一致性问题</strong><br>改数据就会有先后顺序问题。</p><ol><li>只更改内存，然后异步的方式去同步到磁盘，改了内存的数据，如果还没有同步到磁盘，那么这个页叫做脏页（数据和磁盘不一致的页）。(刷脏 innodb_page_cleaners)<br> 刷脏逻辑：<ol><li>自适应，根据脏页产生的频率来修改刷脏的频率，这里也有很多配置</li><li>redolog自适应，如果快满了则会刷脏</li><li>空闲的时候会去刷脏，每次刷脏的百分比</li><li>服务正常关闭，肯定会保证脏页能够保存到磁盘</li><li>如果内存没有同步到磁盘数据，则会根据redolog日志恢复，redolog只要去保存内存跟内存磁盘不一致的数据就可以了，redolog是同步的。redolog保证了数据修改。</li><li>结构 type | spaceId | page number | 修改数据</li><li>redolog只保存在磁盘中，(innodb_red_log_capacity文件大小)，拆分成不同文件保存不同的位置默认32个。如果过多则会覆盖。</li><li>redolog数据为顺序io，因此速度较快。另外page页太大，因此数据交互量大</li><li>根据redolog，提供redolog buffer，先保存到内存里面。提供了选择(select @@innodb_flush_log_at_trx_commit; 1必须刷新到磁盘才能成功 0每秒刷新一次 2交给操作系统刷新)</li></ol></li></ol><p>1、何为索引，解决了什么问题？<br>提升性能<br>能够根据特定的列（多个）来提高查询的性能</p><p>查询索引<br>hash(k-v)：memory 根据单条去查询是不是非常快，但是不支持范围查询<br>B+：innodb，myisam</p><p>索引原理<br>这个页的数据是排序好的，并且每行数据是一个单链链表，能够在某个页里面快速找到数据<br>二分法。 有序</p><p>page，是内存和磁盘交互的最小单元，因此需要跟磁盘交互非常大的次数，导致磁盘io开销大，影响了性能。<br>索引的作用能够快速根据字段来查询，空间换时间。<br>遍历的页数，只跟这个数的层级有关，并且层级越低io次数越少，因此为什么不用二叉树，因为层数过高导致次数过多。<br>B+树 比较稳定，都需要较小的次数完成<br>B树 同样的层级，放的数据越少，同样的数据量我的树的层级越高<br>但是不一定比B+树慢，但是整体慢。</p><p>B+树默认是需要排序的。因为主键id是一定有 序的，唯一的，因此都会基于主键id创建一个这样的索引书，主键、聚集、聚簇索引树，并且这个树下的叶子节点会有我们完整的数据。即使没有主键，也会默认的row_id来创建索引。<br>二级索引，<br>单列二级索引：除了主键索引都是二级索引，但是没有这行数据完整数据row，只包含主键id。可以重复<br>联合二级索引：先根据第一个字段排，相等则根据第二个排。</p><p>索引失效<br>回表</p><p>覆盖索引</p><p>2、从设计者角度来理解索引为何用B+树</p><p>3、二级索引、覆盖索引、主键索引、回表概念一网打尽</p><p>4、通过面试题来举一反三</p><p>MySQL 8.0 版本以后，一条 SQL 的执行流程大致如下所示：</p><ol><li>解析器（Parser）：该阶段将客户端发送的 SQL 查询文本进行解析，将其转换为内部数据结构。解析器会验证语法的正确性，并生成语法树或其他数据结构。</li><li>预处理器（Preprocessor）：在这个阶段，MySQL 会进行一些前处理工作，如展开视图、执行宏替换等。这是为了准备查询进入优化器阶段。</li><li>优化器（Optimizer）：这是查询执行过程中的关键阶段。优化器会基于查询的内部表示，考虑多个执行计划，选择最优的执行计划。这个阶段会决定查询如何访问表、使用索引、连接表以及执行其他操作。</li><li>执行计划生成（Execution Plan Generation）：在优化器选择了最优执行计划后，会生成执行计划。执行计划是一个指令序列，描述了查询的具体执行步骤，包括表的访问顺序、连接方法、索引使用等。</li><li>执行器（Executor）：执行器根据优化器生成的执行计划，实际执行查询操作。它从存储引擎中获取数据，并进行必要的操作，如排序、过滤等。</li><li>存储引擎（Storage Engine）：存储引擎负责底层数据的存储和检索。在执行器的指导下，存储引擎执行实际的数据操作，如表扫描、索引搜索等。</li><li>磁盘访问（Disk Access）：存储引擎可能需要从磁盘读取数据或写入数据。这包括了从磁盘加载表数据、索引，以及将修改写回磁盘等操作。</li></ol><p>需要注意的是，MySQL 8.0 版本以后，优化器、执行计划生成和存储引擎之间的交互更加紧密，优化器可以通过存储引擎提供的统计信息和特性来做出更准确的决策。此外，MySQL 8.0 也引入了一些新的优化和特性，以提高查询性能和可靠性。上述流程中的每个阶段都可以涉及许多复杂的内部操作和优化，以便更高效地执行查询。</p>]]></content>
    
    
    <summary type="html">带锁的Map</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>算法复杂度学习</title>
    <link href="http://example.com/2023/08/18/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/08/18/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-08-18T20:31:00.000Z</published>
    <updated>2023-08-31T09:51:29.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间-空间复杂度"><a href="#时间-空间复杂度" class="headerlink" title="时间/空间复杂度"></a>时间/空间复杂度</h2><p>时间复杂度是用来表示某一特定算法的所需时间的一种方法，它所代表的是算法中需要进行的基本计算的步骤的多少，但为什么要搞的那么复杂？为什么不直接使用时间来度量呢？<br>如果我们直接使用时间来度量算法之间的快慢，会发现相同的算法在不同的硬件环境下，所使用的时间并不相同，正如人力计算和机器计算的区别，拿一个深度学习的算法让人力进行计算，很可能需要几百年，几万年甚至更高，但一台超级计算机则可以在几天，甚至几分钟的时间内得到结果，这就是硬件环境带来的差异，但实际上计算量是相同的。<br>于是就提出了时间复杂度的概念，直接将算法中的基本运算的多少进行统计，用以表示一个算法的复杂程度。<br>所谓基本运算，比如加法，就是一个基本运算，对应的还有减法，乘法，除法，判断等。</p><ul><li>执行时间：时间复杂度</li><li>内存消耗：空间复杂度</li></ul><p><strong>时间复杂度</strong>与<strong>空间复杂度</strong>的前面还有一个词，叫<strong>渐进</strong>，它表示的是：算法在输入数据的规模成倍增长的时候，相应的时间消耗多增长了多少。</p><h2 id="渐进表示法"><a href="#渐进表示法" class="headerlink" title="渐进表示法"></a>渐进表示法</h2><p>我们通常使用渐进符号来描述一个算法的复杂度。</p><h2 id="大-Θ-符号"><a href="#大-Θ-符号" class="headerlink" title="大 Θ 符号"></a>大 Θ 符号</h2><p>对于给定的一个函数$g(n)$，$f(n) = Θ(g(n))$，使得$c1 g(n) &lt;= f(n) &lt;= c2 g(n)$。<br>也就是说，存在的两个参数让$f(n)$保持在$c1 g(n)$与$c2 g(n)$之间。他给了我们一个上下界。</p><h2 id="大-O-符号"><a href="#大-O-符号" class="headerlink" title="大 O 符号"></a>大 O 符号</h2><p>如果我们只有一个函数的渐进上界的时候，我们使用 大O 符号。即$0 &lt;= f(n) &lt;= c g(n)；f(n) = O(g(n))$<br>研究时间复杂度时通常会使用 大O 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。</p><h2 id="大-Ω-符号"><a href="#大-Ω-符号" class="headerlink" title="大 Ω 符号"></a>大 Ω 符号</h2><p>使用 Ω 符号来描述一个函数的渐进下界。即$0 &lt;= c g(n) &lt;= f(n)；f(n) = Ω(g(n))$。</p><h2 id="小-o-符号"><a href="#小-o-符号" class="headerlink" title="小 o 符号"></a>小 o 符号</h2><p>如果说 大O 符号相当于小于等于号，那么 o oo 符号就相当于小于号。即$0 &lt;= f(n) &lt; c g(n)；f(n) = o(g(n))$。</p><h2 id="小-ω-符号"><a href="#小-ω-符号" class="headerlink" title="小 ω 符号"></a>小 ω 符号</h2><p>如果说 Ω 符号相当于大于等于号，那么 ω 符号就相当于大于号。即$0 &lt;= f(n) &lt; c g(n)；f(n) = ω(g(n))$。</p><h2 id="举个例子就可以很快的理解这一概念："><a href="#举个例子就可以很快的理解这一概念：" class="headerlink" title="举个例子就可以很快的理解这一概念："></a>举个例子就可以很快的理解这一概念：</h2><p>比如某个算法的时间复杂度是：</p><script type="math/tex; mode=display">3n^3 + 2n^2 + 99n + 1</script><p>其中n代表数据量。<br>发现高次项随着数据量的少幅度改变就会让时间复杂度发生大幅度的改变，比如数据量n从1000提高到1001，那么高次项就增加了$1001^3 - 1000^3 = 30013001$，而二次项则是$1001^2 - 1000^2 = 2001$，一次项为$1001 - 1000 = 1$，常数项不改变。</p><p>在这种情况下，我们说高次项对时间复杂度的影响更大，而低次项则可以被忽略，于是，我们可以将上述时间复杂度变成：</p><script type="math/tex; mode=display">3n^3</script><p>现在，我们发现高次项前面的系数并不特别影响时间复杂度所在的数量级，于是就将系数也省去，最后时间复杂度变为：</p><script type="math/tex; mode=display">n^3</script><p>但是怎么知道这个是代表时间复杂度呢？那就在前面加个大O吧，于是就有了大O表示法：</p><script type="math/tex; mode=display">O(n^3)</script><p>这样，我们就得到了这个算法的时间复杂度了。</p><h2 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h2><p>时间复杂度实际上还分为最优时间复杂度，最坏时间复杂度，平均时间复杂度。</p><ul><li>最优时间复杂度：算法完成工作最少需要多少基本操作。</li><li>平均时间复杂度：算法完成工作平均需要多少基本操作。</li><li>最坏时间复杂度：算法完成工作最多需要多少基本作。</li></ul><p>最坏时间复杂度提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。因此，我们主要关注算法的最坏情况，一般在说到时间复杂度时，我们说的都是最坏时间复杂度。</p><h2 id="时间复杂度的几条基本计算规则"><a href="#时间复杂度的几条基本计算规则" class="headerlink" title="时间复杂度的几条基本计算规则"></a>时间复杂度的几条基本计算规则</h2><ul><li>基本操作，即只有常数项，认为其时间复杂度为$O(1)$</li><li>顺序结构，时间复杂度按加法进行计算。比如一个算法复杂度为$O(n)$的结构和一个算法复杂度为$O(n^2)$的结构相加，即$O(n^2 + n)$，简化为$O(n^2)$</li><li>循环结构，时间复杂度按乘法进行计算，比如外层循环为进行n次，内层为从0加到100，那么内层的时间复杂度为$O(100)$，外层要进行n次，则总体的时间复杂度为$O(100n)$，简化为$O(n)$。</li><li>分支结构，时间复杂度取最大值</li></ul><h2 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h2><p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</strong></p><p><img src="/img/AlgorithmComplexity/0.jpg" alt="github"></p><h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><p>在时间复杂度的计算中，有一类问题的计算比较困难，这种问题就是递归问题，比如对于归并排序（Merge Sort）来说，每一层的复杂度为：</p><script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2}) + n</script><p>其中T(n)代表了当前层的时间复杂度，代表了将当前层的数据进行分解和将返回当前层的数据进行合并所需要的时间复杂度。</p><p>在递归问题中，时间复杂度计算的难点在于，如果要计算当前层，就需要首先得到下一层的时间复杂度，而为了计算下一层，又要计算下下层的时间复杂度，这就造成了计算困难。</p><p>为了能够快速得到递归算法的时间复杂度，可以使用主定理：</p><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b}) + f(n^d)</script><p>其中，</p><ul><li>n是问题规模大小，</li><li>a是原问题的子问题个数，</li><li>n/b是每个子问题的大小，这里假设每个子问题有相同的规模大小，</li><li>f(n^d)是将原问题分解成子问题和将子问题的解合并成原问题的解的时间。</li></ul><p>根据主公式定理，我们可以得到如下的结果：</p><script type="math/tex; mode=display">T(n) = \begin{cases}O(n^d),\,\,d > log_b a\\O(n^d \log n),\,\,d = log_b a\\O(n^\log_{b}{a}),\,\,d < logb a\end{cases}</script><p>上式的意思如下：我们可以将d看做代表了主公式中的第二项，即将原问题分解成子问题和将子问题的解合并成原问题的解的时间。<br>将$log_b a$看做代表了主公式中的第一项，即解决当前层问题所需要的时间复杂度。</p><p>如果$d &gt; log_b a$，可以认为是解决当前层的时间复杂度的次数低于将原问题分解成子问题和将子问题的解合并成原问题的解的时间，于是我们可以直接使用第二项作为我们的时间复杂度。<br>如果$d = log_b a$，可以认为两者相等，则需要将两者都考虑进去。<br>如果$d &lt; log_b a$，可以认为解决当前层的时间复杂度的次数更高，则直接使用第一项作为我们的时间复杂度。</p><h2 id="摊还分析"><a href="#摊还分析" class="headerlink" title="摊还分析"></a>摊还分析</h2>]]></content>
    
    
    <summary type="html">算法复杂度学习</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>带锁的Map</title>
    <link href="http://example.com/2023/08/18/SafeMap/"/>
    <id>http://example.com/2023/08/18/SafeMap/</id>
    <published>2023-08-18T20:31:00.000Z</published>
    <updated>2023-08-29T10:32:22.046Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。</p><p>synchronizedMap与ConcurrentHashMap:两者由于实现原理稍有不同，因此在读与写的性能上也会有所差异。接下来通过编写测试程序对两者的读写性能分别做比较。</p><h2 id="synchronizedMap"><a href="#synchronizedMap" class="headerlink" title="synchronizedMap"></a>synchronizedMap</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; objectObjectMap = Collections.<span class="hljs-built_in">synchronizedMap</span>(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br><br>        objectObjectMap.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        objectObjectMap.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">SynchronizedMap(Map&lt;K,V&gt; <span class="hljs-params">m</span>)</span> &#123;<br>    this.m = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">m</span>)</span>;<br>    mutex = this;<br>&#125;<br></code></pre></td></tr></table></figure><p>该Map主要在里面使用了一个锁来完成同步。将map的每个方法都加了同步。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.put(<span class="hljs-built_in">key</span>, value);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>SynchronizedMap的put封装了HashMap的put方法，并加上互斥锁保证了安全性。</p><p>但是看代码可以看出，锁在使用时的颗粒度非常大，会导致阻塞性大大提高，从而导致性能降低。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 于 Java 7 的，和8有区别,在8中 CHM 摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。</p><h2 id="HashMap-线程不安全的典型表现"><a href="#HashMap-线程不安全的典型表现" class="headerlink" title="HashMap 线程不安全的典型表现"></a>HashMap 线程不安全的典型表现</h2><p>HashMap是一个数组链表，当一个key/Value对被加入时，首先会通过Hash算法定位出这个键值对要被放入的桶，然后就把它插到相应桶中。如果这个桶中已经有元素了，那么发生了碰撞，这样会在这个桶中形成一个链表。一般来说，当有数据要插入HashMap时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大HashMap的尺寸，但是这样一来，就需要对整个HashMap里的节点进行重哈希操作。在重哈希的过程中，就会出现HashMap线程不安全的典型表现 —— 死循环。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transfers all entries from current table to newTable.</span><br><span class="hljs-comment"> */</span><br>void transfer(Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>) &#123;<br><br>    <span class="hljs-comment">// 将原数组 table 赋给数组 src</span><br>    Entry[] src = table;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>.length;<br><br>    <span class="hljs-comment">// 将数组 src 中的每条链重新添加到 newTable 中</span><br>    <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;<br>        Entry&lt;K,V&gt; e = src[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            src[j] = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// src 回收</span><br><br>            <span class="hljs-comment">// 将每条链的每个元素依次添加到 newTable 中相应的桶中</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br><br>                <span class="hljs-comment">// e.hash指的是 hash(key.hashCode())的返回值;</span><br>                <span class="hljs-comment">// 计算在newTable中的位置，注意原来在同一条子链上的元素可能被分配到不同的桶中</span><br>                int i = indexFor(e.hash, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);   <br>                e.next = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i];<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i] = e;<br>                e = next;<br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="原理（JDK7）"><a href="#原理（JDK7）" class="headerlink" title="原理（JDK7）"></a>原理（JDK7）</h2><p>在 JDK7 中，ConcurrentHashMap 使用“分段锁”机制实现线程安全，数据结构可以看成是”Segment数组+HashEntry数组+链表”，一个 ConcurrentHashMap 实例中包含若干个 Segment 实例组成的数组，每个 Segment 实例又包含由若干个桶，每个桶中都是由若干个 HashEntry 对象链接起来的链表。<br><img src="/img/SafeMap/0.png" alt="github"><br>因为Segment 类继承 ReentrantLock 类，所以能充当锁的角色，通过 segment 段将 ConcurrentHashMap 划分为不同的部分，就可以使用不同的锁来控制对哈希表不同部分的修改，从而允许多个写操作并发进行，默认支持 16 个线程执行并发写操作，及任意数量线程的读操作。</p><ul><li>通过锁分段技术保证并发环境下的写操作；</li><li>通过HashEntry的不变形、volatile变量的内存可见性和加锁重读机制 保证高效、安全的读操作；</li><li>通过不加锁和加锁 两种方案控制跨段操作的安全性。</li></ul><p>在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。</p><h2 id="原理（JDK8）"><a href="#原理（JDK8）" class="headerlink" title="原理（JDK8）"></a>原理（JDK8）</h2><p>在 JDK8 及以上的版本中，ConcurrentHashMap 的底层数据结构依然采用“数组+链表+红黑树”，但是在实现线程安全性方面，抛弃了 JDK7 版本的 Segment分段锁的概念，而是采用了 volatile + synchronized + CAS 算法来保证线程安全。在ConcurrentHashMap中，大量使用 Unsafe.compareAndSwapXXX 的方法，这类方法是利用一个CAS算法实现无锁化的修改值操作，可以大大减少使用加锁造成的性能消耗。这个算法的基本思想就是不断比较当前内存中的变量值和你预期变量值是否相等，如果相等，则接受修改的值，否则拒绝你的而操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 装有Node元素的数组，他的大小是2的整数次幂</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">// hash表初始化或扩容时的一个控制位标识量。</span><br><span class="hljs-comment">// 负数代表正在进行初始化或扩容操作</span><br><span class="hljs-comment">// -1代表正在初始化</span><br><span class="hljs-comment">// -N 表示有N-1个线程正在进行扩容操作</span><br><span class="hljs-comment">// 正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<br><br><span class="hljs-comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> RESIZE_STAMP_BITS = <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RESIZE_STAMP_SHIFT = <span class="hljs-number">32</span> - RESIZE_STAMP_BITS;<br><br><span class="hljs-comment">// 表示这是一个forwardNode节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOVED     = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 表示这时一个TreeBin节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEBIN   = <span class="hljs-number">-2</span>;<br></code></pre></td></tr></table></figure><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h6 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h6><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash;<br>    <span class="hljs-keyword">final</span> K <span class="hljs-built_in">key</span>;<br>    <span class="hljs-keyword">volatile</span> V val;<span class="hljs-comment">//带有同步锁的value</span><br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<span class="hljs-comment">//带有同步锁的next指针</span><br><br>    Node(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">key</span> = <span class="hljs-built_in">key</span>;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K getKey()       &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">key</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V getValue()     &#123; <span class="hljs-keyword">return</span> val; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hashCode()   &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">key</span>.hashCode() ^ val.hashCode(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> toString()&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">key</span> + <span class="hljs-string">&quot;=&quot;</span> + val; &#125;<br>    <br>    <span class="hljs-comment">//不允许直接改变value的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V setValue(V value) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">boolean</span> equals(<span class="hljs-keyword">Object</span> o) &#123;<br>        <span class="hljs-keyword">Object</span> k, v, u; Map.Entry&lt;?,?&gt; e;<br>        <span class="hljs-keyword">return</span> ((o <span class="hljs-keyword">instanceof</span> Map.Entry) &amp;&amp;<br>                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                (v = e.getValue()) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                (k == <span class="hljs-built_in">key</span> || k.equals(<span class="hljs-built_in">key</span>)) &amp;&amp;<br>                (v == (u = val) || v.equals(u)));<br>    &#125;<br>    <br>    Node&lt;K,V&gt; find(<span class="hljs-built_in">int</span> h, <span class="hljs-keyword">Object</span> k) &#123;<br>        Node&lt;K,V&gt; e = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">if</span> (k != <span class="hljs-keyword">null</span>) &#123;<br>            do &#123;<br>                K ek;<br>                <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                    ((ek = e.<span class="hljs-built_in">key</span>) == k || (ek != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(ek))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个Node内部类与HashMap中定义的Node类很相似，但是有一些差别</p><ul><li>它对value和next属性设置了volatile同步锁</li><li>它不允许调用setValue方法直接改变Node的value域</li><li>它增加了find方法辅助map.get()方法</li></ul><h6 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h6><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry<K,V>类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TreeNode</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Node</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; &#123;<br>        TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>        TreeNode&lt;K,V&gt; left;<br>        TreeNode&lt;K,V&gt; right;<br>        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        <span class="hljs-built_in">bool</span>ean red;<br><br>        TreeNode(<span class="hljs-built_in">int</span> hash, K key, V val, Node&lt;K,V&gt; next,<br>                 TreeNode&lt;K,V&gt; parent) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, val, next);<br>            <span class="hljs-keyword">this</span>.parent = parent;<br>        &#125;<br><br>        Node&lt;K,V&gt; find(<span class="hljs-built_in">int</span> h, Object k) &#123;<br>            <span class="hljs-keyword">return</span> findTreeNode(h, k, <span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns the TreeNode (or null if not found) for the given key</span><br><span class="hljs-comment">         * starting at given root.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; findTreeNode(<span class="hljs-built_in">int</span> h, Object k, Class&lt;?&gt; kc) &#123;...&#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h6 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h6><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。<br><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">TreeBin(TreeNode&lt;K,V&gt; b) &#123;<br>    super(TREEBIN, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    this.<span class="hljs-attr">first</span> = b;<br>    TreeNode&lt;K,V&gt; <span class="hljs-attr">r</span> = <span class="hljs-literal">null</span>;<br>    for (TreeNode&lt;K,V&gt; <span class="hljs-attr">x</span> = b, next; x != <span class="hljs-literal">null</span>; <span class="hljs-attr">x</span> = next) &#123;<br>        <span class="hljs-attr">next</span> = (TreeNode&lt;K,V&gt;)x.next;<br>        x.<span class="hljs-attr">left</span> = x.<span class="hljs-attr">right</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-attr">r</span> == <span class="hljs-literal">null</span>) &#123;<br>            x.<span class="hljs-attr">parent</span> = <span class="hljs-literal">null</span>;<br>            x.<span class="hljs-attr">red</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-attr">r</span> = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            K <span class="hljs-attr">k</span> = x.key;<br>            int <span class="hljs-attr">h</span> = x.hash;<br>            Class&lt;?&gt; <span class="hljs-attr">kc</span> = <span class="hljs-literal">null</span>;<br>            for (TreeNode&lt;K,V&gt; <span class="hljs-attr">p</span> = r;;) &#123;<br>                int dir, ph;<br>                K <span class="hljs-attr">pk</span> = p.key;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-attr">ph</span> = p.hash) &gt; h)<br>                    <span class="hljs-attr">dir</span> = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    <span class="hljs-attr">dir</span> = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-attr">kc</span> == <span class="hljs-literal">null</span> &amp;&amp;<br>                          (<span class="hljs-attr">kc</span> = comparableClassFor(k)) == <span class="hljs-literal">null</span>) ||<br>                         (<span class="hljs-attr">dir</span> = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>                    <span class="hljs-attr">dir</span> = tieBreakOrder(k, pk);<br>                    TreeNode&lt;K,V&gt; <span class="hljs-attr">xp</span> = p;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-attr">p</span> = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-literal">null</span>) &#123;<br>                    x.<span class="hljs-attr">parent</span> = xp;<br>                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                        xp.<span class="hljs-attr">left</span> = x;<br>                    <span class="hljs-keyword">else</span><br>                        xp.<span class="hljs-attr">right</span> = x;<br>                    <span class="hljs-attr">r</span> = balanceInsertion(r, x);<br>                    break;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    this.<span class="hljs-attr">root</span> = r;<br>    <span class="hljs-keyword">assert</span> checkInvariants(root);<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看到在构造TreeBin节点时，仅仅指定了它的hash值为TREEBIN常量，这也就是个标识为。同时也看到我们熟悉的红黑树构造方法。</p><h6 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h6><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ForwardingNode</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Node</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;<br>    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-keyword">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">this</span>.nextTable = tab;<br>    &#125;<br><br>    Node&lt;K,V&gt; find(<span class="hljs-built_in">int</span> h, Object k) &#123;<br>        <span class="hljs-comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span><br>        outer: <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;<br>            Node&lt;K,V&gt; e; <span class="hljs-built_in">int</span> n;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> || tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span> ||<br>                (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-built_in">int</span> eh; K ek;<br>                <span class="hljs-keyword">if</span> ((eh = e.hash) == h &amp;&amp;<br>                    ((ek = e.key) == k || (ek != <span class="hljs-literal">null</span> &amp;&amp; k.equals(ek))))<br>                    <span class="hljs-keyword">return</span> e;<br>                <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (e instanceof ForwardingNode) &#123;<br>                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;<br>                        <span class="hljs-keyword">continue</span> outer;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">return</span> e.find(h, k);<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="Unsafe与CAS"><a href="#Unsafe与CAS" class="headerlink" title="Unsafe与CAS"></a>Unsafe与CAS</h4><p>在ConcurrentHashMap中，随处可以看到U, 大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。配合volatile组合完成锁的功能。</p><h6 id="unsafe静态块"><a href="#unsafe静态块" class="headerlink" title="unsafe静态块"></a>unsafe静态块</h6><p>unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。  在这一版本的concurrentHashMap中，大量应用来的CAS方法进行变量、属性的修改工作。  利用CAS进行无锁操作，可以大大提高性能。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static final sun.misc.Unsafe U;<br><span class="hljs-keyword">private</span> static final long SIZECTL;<br><span class="hljs-keyword">private</span> static final long TRANSFERINDEX;<br><span class="hljs-keyword">private</span> static final long BASECOUNT;<br><span class="hljs-keyword">private</span> static final long CELLSBUSY;<br><span class="hljs-keyword">private</span> static final long CELLVALUE;<br><span class="hljs-keyword">private</span> static final long ABASE;<br><span class="hljs-keyword">private</span> static final <span class="hljs-built_in">int</span> ASHIFT;<br><br>static &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        U = sun.misc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Unsafe</span>.</span></span>get<span class="hljs-constructor">Unsafe()</span>;<br>        Class&lt;?&gt; k = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConcurrentHashMap</span>.</span></span><span class="hljs-keyword">class</span>;<br>        SIZECTL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>objectFieldOffset<br>            (k.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;sizeCtl&quot;</span>)</span>);<br>        TRANSFERINDEX = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>objectFieldOffset<br>            (k.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;transferIndex&quot;</span>)</span>);<br>        BASECOUNT = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>objectFieldOffset<br>            (k.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;baseCount&quot;</span>)</span>);<br>        CELLSBUSY = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>objectFieldOffset<br>            (k.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;cellsBusy&quot;</span>)</span>);<br>        Class&lt;?&gt; ck = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CounterCell</span>.</span></span><span class="hljs-keyword">class</span>;<br>        CELLVALUE = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>objectFieldOffset<br>            (ck.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>);<br>        Class&lt;?&gt; ak = Node<span class="hljs-literal">[]</span>.<span class="hljs-keyword">class</span>;<br>        ABASE = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span><span class="hljs-built_in">array</span><span class="hljs-constructor">BaseOffset(<span class="hljs-params">ak</span>)</span>;<br>        <span class="hljs-built_in">int</span> scale = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span><span class="hljs-built_in">array</span><span class="hljs-constructor">IndexScale(<span class="hljs-params">ak</span>)</span>;<br>        <span class="hljs-keyword">if</span> ((scale &amp; (scale - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;data type scale not a power of two&quot;</span>)</span>;<br>        ASHIFT = <span class="hljs-number">31</span> - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>number<span class="hljs-constructor">OfLeadingZeros(<span class="hljs-params">scale</span>)</span>;<br>    &#125; catch (Exception e) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-params">e</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="三个核心方法"><a href="#三个核心方法" class="headerlink" title="三个核心方法"></a>三个核心方法</h6><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">@SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>//获得在i位置上的<span class="hljs-keyword">Node</span><span class="hljs-title">节点</span><br><span class="hljs-title">static</span> final <span class="hljs-tag">&lt;K,V&gt;</span> <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; tabAt(<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;[] tab, int i) &#123;<br>    return (<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="hljs-tag">&lt;&lt; ASHIFT) + ABASE);</span><br><span class="hljs-tag">&#125;</span><br><span class="hljs-tag">//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少</span><br><span class="hljs-tag">//在CAS算法中，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改</span><br><span class="hljs-tag">//因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果</span><br><span class="hljs-tag">static final &lt;K,V&gt;</span> boolean casTabAt(<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;[] tab, int i,<br>                                    <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; c, <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; v) &#123;<br>    return U.compareAndSwapObject(tab, ((long)i <span class="hljs-tag">&lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="hljs-tag">&#125;</span><br><span class="hljs-tag">//利用volatile方法设置节点位置的值</span><br><span class="hljs-tag">static final &lt;K,V&gt;</span> void setTabAt(<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;[] tab, int i, <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; v) &#123;<br>    U.putObjectVolatile(tab, ((long)i <span class="hljs-tag">&lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="hljs-tag">&#125;</span><br></code></pre></td></tr></table></figure></p><h4 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h4><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。<br>初始化方法主要应用了关键属性sizeCtl 如果这个值<code>&lt;0</code>，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。<br><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">private final Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-keyword">tab</span>; int <span class="hljs-keyword">sc</span>;<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">tab</span> = <span class="hljs-keyword">table</span>) == null || <span class="hljs-keyword">tab</span>.length == 0) &#123;<br>        <span class="hljs-comment">// sizeCtl&lt;0表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">sc</span> = sizeCtl) &lt; 0)<br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="hljs-keyword">sc</span>, -1)) &#123; <span class="hljs-comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span><br>            try &#123;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">tab</span> = <span class="hljs-keyword">table</span>) == null || <span class="hljs-keyword">tab</span>.length == 0) &#123;<br>                    int <span class="hljs-keyword">n</span> = (<span class="hljs-keyword">sc</span> &gt; 0) ? <span class="hljs-keyword">sc</span> : DEFAULT_CAPACITY;<br>                    @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="hljs-keyword">n</span>];<br>                    <span class="hljs-keyword">table</span> = <span class="hljs-keyword">tab</span> = nt;<br>                    <span class="hljs-comment">//相当于0.75*n 设置一个扩容的阈值</span><br>                    <span class="hljs-keyword">sc</span> = <span class="hljs-keyword">n</span> - (<span class="hljs-keyword">n</span> &gt;&gt;&gt; 2);<br>                &#125;<br>            &#125; finally &#123;<br>                sizeCtl = <span class="hljs-keyword">sc</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。<br>这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。因为在扩容的时候，总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，如果这个操作能够并发进行，那真真是极好的了。</p><p>整个扩容操作分为两个部分</p><ul><li>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过<code>RESIZE_STAMP_SHIFT</code>这个常量经过一次运算来保证的，这个地方在后面会有提到</li><li>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作</li></ul><p><strong>先来看一下单线程是如何完成的</strong><br>大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ul><li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点</li><li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上;</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上;</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</li></ul><p><strong>再看一下多线程是如何完成的</strong><br>代码有一个判断，如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个过渡的table表  只有在扩容的时候才会使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> transient volatile Node&lt;K,V&gt;<span class="hljs-literal">[]</span> nextTable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Moves and/or copies the nodes in each bin to new table. See</span><br><span class="hljs-comment"> * above for explanation.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> final void transfer(Node&lt;K,V&gt;<span class="hljs-literal">[]</span> tab, Node&lt;K,V&gt;<span class="hljs-literal">[]</span> nextTab) &#123;<br>    <span class="hljs-built_in">int</span> n = tab.length, stride;<br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>)<span class="hljs-operator"> / </span>NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br>    <span class="hljs-keyword">if</span> (nextTab<span class="hljs-operator"> == </span>null) &#123;            <span class="hljs-comment">// initiating</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)</span><br>            Node&lt;K,V&gt;<span class="hljs-literal">[]</span> nt = (Node&lt;K,V&gt;<span class="hljs-literal">[]</span>)<span class="hljs-keyword">new</span> Node&lt;?,?&gt;<span class="hljs-literal">[<span class="hljs-identifier">n</span> &lt;&lt; <span class="hljs-number">1</span>]</span>;<span class="hljs-comment">//构造一个nextTable对象 它的容量是原来的两倍</span><br>            nextTab = nt;<br>        &#125; catch (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            return;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-built_in">int</span> nextn = nextTab.length;<br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);<span class="hljs-comment">//构造一个连节点指针 用于标志位</span><br>    boolean advance = <span class="hljs-literal">true</span>;<span class="hljs-comment">//并发扩容的关键属性 如果等于true 说明这个节点已经处理过</span><br>    boolean finishing = <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-built_in">int</span> fh;<br>        <span class="hljs-comment">//这个while循环体的作用就是在控制i--  通过i--可以依次遍历原hash表中的节点</span><br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-built_in">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound<span class="hljs-operator"> || </span>finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>compareAndSwapInt<br>                     (this, TRANSFERINDEX, nextIndex,<br>                      nextBound = (nextIndex &gt; stride ?<br>                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>i &gt;= n<span class="hljs-operator"> || </span>i + n &gt;= nextn) &#123;<br>            <span class="hljs-built_in">int</span> sc;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>            <span class="hljs-comment">//如果所有的节点都已经完成复制工作  就把nextTable赋值给table 清空临时对象nextTable</span><br>                nextTable = null;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//扩容阈值设置为原来容量的1.5倍  依然相当于现在容量的0.75倍</span><br>                return;<br>            &#125;<br>            <span class="hljs-comment">//利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">U</span>.</span></span>compare<span class="hljs-constructor">AndSwapInt(<span class="hljs-params">this</span>, SIZECTL, <span class="hljs-params">sc</span> = <span class="hljs-params">sizeCtl</span>, <span class="hljs-params">sc</span> - 1)</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resize<span class="hljs-constructor">Stamp(<span class="hljs-params">n</span>)</span> &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    return;<br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果遍历到的节点为空 则放入ForwardingNode指针</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tab<span class="hljs-constructor">At(<span class="hljs-params">tab</span>, <span class="hljs-params">i</span>)</span>)<span class="hljs-operator"> == </span>null)<br>            advance = cas<span class="hljs-constructor">TabAt(<span class="hljs-params">tab</span>, <span class="hljs-params">i</span>, <span class="hljs-params">null</span>, <span class="hljs-params">fwd</span>)</span>;<br>        <span class="hljs-comment">//如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash)<span class="hljs-operator"> == </span>MOVED)<br>            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//节点上锁</span><br>            synchronized (f) &#123;<br>                <span class="hljs-keyword">if</span> (tab<span class="hljs-constructor">At(<span class="hljs-params">tab</span>, <span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">//如果fh&gt;=0 证明这是一个Node节点</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">int</span> runBit = fh &amp; n;<br>                        <span class="hljs-comment">//以下的部分在完成的工作是构造两个链表  一个是原链表  另一个是原链表的反序排列</span><br>                        Node&lt;K,V&gt; lastRun = f;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;<br>                            <span class="hljs-built_in">int</span> b = p.hash &amp; n;<br>                            <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>                                runBit = b;<br>                                lastRun = p;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (runBit<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>                            ln = lastRun;<br>                            hn = null;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            hn = lastRun;<br>                            ln = null;<br>                        &#125;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>                            <span class="hljs-built_in">int</span> ph = p.hash; K pk = p.key; V pv = p.<span class="hljs-keyword">val</span>;<br>                            <span class="hljs-keyword">if</span> ((ph &amp; n)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>                                ln = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);<br>                            <span class="hljs-keyword">else</span><br>                                hn = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);<br>                        &#125;<br>                        <span class="hljs-comment">//在nextTable的i位置上插入一个链表</span><br>                        set<span class="hljs-constructor">TabAt(<span class="hljs-params">nextTab</span>, <span class="hljs-params">i</span>, <span class="hljs-params">ln</span>)</span>;<br>                        <span class="hljs-comment">//在nextTable的i+n的位置上插入另一个链表</span><br>                        set<span class="hljs-constructor">TabAt(<span class="hljs-params">nextTab</span>, <span class="hljs-params">i</span> + <span class="hljs-params">n</span>, <span class="hljs-params">hn</span>)</span>;<br>                        <span class="hljs-comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br>                        set<span class="hljs-constructor">TabAt(<span class="hljs-params">tab</span>, <span class="hljs-params">i</span>, <span class="hljs-params">fwd</span>)</span>;<br>                        <span class="hljs-comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span><br>                        advance = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//对TreeBin对象进行处理  与上面的过程类似</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f instanceof TreeBin) &#123;<br>                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;<br>                        TreeNode&lt;K,V&gt; lo = null, loTail = null;<br>                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;<br>                        <span class="hljs-built_in">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>                        <span class="hljs-comment">//构造正序和反序两个链表</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;<br>                            <span class="hljs-built_in">int</span> h = e.hash;<br>                            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;<br>                                (h, e.key, e.<span class="hljs-keyword">val</span>, null, null);<br>                            <span class="hljs-keyword">if</span> ((h &amp; n)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> ((p.prev = loTail)<span class="hljs-operator"> == </span>null)<br>                                    lo = p;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = p;<br>                                loTail = p;<br>                                ++lc;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> ((p.prev = hiTail)<span class="hljs-operator"> == </span>null)<br>                                    hi = p;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = p;<br>                                hiTail = p;<br>                                ++hc;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">//如果扩容后已经不再需要tree的结构 反向转换为链表结构</span><br>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                            (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;<br>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                            (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;<br>                        <span class="hljs-comment">//在nextTable的i位置上插入一个链表    </span><br>                        set<span class="hljs-constructor">TabAt(<span class="hljs-params">nextTab</span>, <span class="hljs-params">i</span>, <span class="hljs-params">ln</span>)</span>;<br>                        <span class="hljs-comment">//在nextTable的i+n的位置上插入另一个链表</span><br>                        set<span class="hljs-constructor">TabAt(<span class="hljs-params">nextTab</span>, <span class="hljs-params">i</span> + <span class="hljs-params">n</span>, <span class="hljs-params">hn</span>)</span>;<br>                        <span class="hljs-comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br>                        set<span class="hljs-constructor">TabAt(<span class="hljs-params">tab</span>, <span class="hljs-params">i</span>, <span class="hljs-params">fwd</span>)</span>;<br>                        <span class="hljs-comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span><br>                        advance = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="put-尾插法"><a href="#put-尾插法" class="headerlink" title="put 尾插法"></a>put 尾插法</h4><p>前面的所有的介绍其实都为这个方法做铺垫。ConcurrentHashMap最常用的就是put和get两个方法。现在来介绍put方法，这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。<br>ConcurrentHashMap中依然沿用这个思想，<strong>有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。</strong>另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况。</p><ul><li>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</li><li>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。</li></ul><p>整体流程就是首先定义不允许key或value为null的情况放入，对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p><ul><li>如果这个位置是空的，那么直接放入，而且不需要加锁操作。</li><li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。  如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-keyword">return</span> putVal(<span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V putVal(K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent) &#123;<br><span class="hljs-comment">//不允许 key或value为null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">//计算hash值</span><br>    <span class="hljs-built_in">int</span> hash = spread(<span class="hljs-built_in">key</span>.hashCode());<br>    <span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//死循环 何时插入成功 何时跳出</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-built_in">int</span> n, i, fh;<br>        <span class="hljs-comment">//如果table为空的话，初始化table</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">//根据hash值计算出在table里面的位置 </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//如果这个位置没有值 ，直接放进去，不需要加锁</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">//当遇到表连接点时，需要进行整合表的操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//fh〉0 说明这个节点是一个链表的节点 不是树的节点</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">//在这里遍历链表所有的结点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">//如果hash值和key值相同  则修改对应结点的value值</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> ||<br>                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">//如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, <span class="hljs-built_in">key</span>,<br>                                                          value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//如果这个节点是树节点，就按照树的方式插入值</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="hljs-built_in">key</span>,<br>                                                       value)) != <span class="hljs-keyword">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将当前ConcurrentHashMap的元素数量+1</span><br>    addCount(<span class="hljs-number">1</span>L, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer"></a>helpTransfer</h6><p>这是一个协助扩容的方法。这个方法被调用的时候，当前ConcurrentHashMap一定已经有了nextTable对象，首先拿到这个nextTable对象，调用transfer方法。回看上面的transfer方法可以看到，当本线程进入扩容方法的时候会直接进入复制阶段。<br><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Helps transfer if a resize is in progress.</span><br><span class="hljs-comment"> */</span><br>final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] <span class="hljs-keyword">tab</span>, Node&lt;K,V&gt; f) &#123;<br>    Node&lt;K,V&gt;[] nextTab; int <span class="hljs-keyword">sc</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">tab</span> != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;<br>        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;<br>        int rs = resizeStamp(<span class="hljs-keyword">tab</span>.length);<span class="hljs-comment">//计算一个操作校验码</span><br>        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; <span class="hljs-keyword">table</span> == <span class="hljs-keyword">tab</span> &amp;&amp;<br>               (<span class="hljs-keyword">sc</span> = sizeCtl) &lt; 0) &#123;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">sc</span> &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || <span class="hljs-keyword">sc</span> == rs + 1 ||<br>                <span class="hljs-keyword">sc</span> == rs + MAX_RESIZERS || transferIndex &lt;= 0)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="hljs-keyword">sc</span>, <span class="hljs-keyword">sc</span> + 1)) &#123;<br>                transfer(<span class="hljs-keyword">tab</span>, nextTab);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nextTab;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">table</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h6><p>这个方法用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，如果容量没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才链表的结构抓换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> final void treeify<span class="hljs-constructor">Bin(Node&lt;K,V&gt;[] <span class="hljs-params">tab</span>, <span class="hljs-params">int</span> <span class="hljs-params">index</span>)</span> &#123;<br>    Node&lt;K,V&gt; b; <span class="hljs-built_in">int</span> n, sc;<br>    <span class="hljs-keyword">if</span> (tab != null) &#123;<br>        <span class="hljs-keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<span class="hljs-comment">//如果table.length&lt;64 就扩大一倍 返回</span><br>            <span class="hljs-keyword">try</span><span class="hljs-constructor">Presize(<span class="hljs-params">n</span> &lt;&lt; 1)</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((b = tab<span class="hljs-constructor">At(<span class="hljs-params">tab</span>, <span class="hljs-params">index</span>)</span>) != null<span class="hljs-operator"> &amp;&amp; </span>b.hash &gt;= <span class="hljs-number">0</span>) &#123;<br>            synchronized (b) &#123;<br>                <span class="hljs-keyword">if</span> (tab<span class="hljs-constructor">At(<span class="hljs-params">tab</span>, <span class="hljs-params">index</span>)</span><span class="hljs-operator"> == </span>b) &#123;<br>                    TreeNode&lt;K,V&gt; hd = null, tl = null;<br>                    <span class="hljs-comment">//构造了一个TreeBin对象 把所有Node节点包装成TreeNode放进去</span><br>                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;<br>                        TreeNode&lt;K,V&gt; p =<br>                            <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.<span class="hljs-keyword">val</span>,<br>                                              null, null);<span class="hljs-comment">//这里只是利用了TreeNode封装 而没有利用TreeNode的next域和parent域</span><br>                        <span class="hljs-keyword">if</span> ((p.prev = tl)<span class="hljs-operator"> == </span>null)<br>                            hd = p;<br>                        <span class="hljs-keyword">else</span><br>                            tl.next = p;<br>                        tl = p;<br>                    &#125;<br>                    <span class="hljs-comment">//在原来index的位置 用TreeBin替换掉原来的Node对象</span><br>                    set<span class="hljs-constructor">TabAt(<span class="hljs-params">tab</span>, <span class="hljs-params">index</span>, <span class="hljs-params">new</span> TreeBin&lt;K,V&gt;(<span class="hljs-params">hd</span>)</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件  key相同  hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-built_in">int</span> n, eh; K ek;<br>    <span class="hljs-comment">//计算hash值</span><br>    <span class="hljs-built_in">int</span> h = spread(<span class="hljs-built_in">key</span>.hashCode());<br>    <span class="hljs-comment">//根据hash值确定节点位置</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (ek != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-comment">//如果eh&lt;0 说明这个节点在树上 直接寻找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, <span class="hljs-built_in">key</span>)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;<br>         <span class="hljs-comment">//否则遍历链表 找到对应的值并返回</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (ek != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="Size相关的方法"><a href="#Size相关的方法" class="headerlink" title="Size相关的方法"></a>Size相关的方法</h4><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。</p><h6 id="辅助定义"><a href="#辅助定义" class="headerlink" title="辅助定义"></a>辅助定义</h6><p>为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类。<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span><br><span class="hljs-comment"> * and Striped64.  See their internal docs for explanation.</span><br><span class="hljs-comment"> */</span><br>@sun.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> CounterCell &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>    CounterCell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br>&#125;<br><br><span class="hljs-comment">/******************************************/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span><br><span class="hljs-comment"> * 但它并不用返回当前hashmap的元素个数 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> baseCount;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;<br></code></pre></td></tr></table></figure></p><h6 id="mappingCount与Size方法"><a href="#mappingCount与Size方法" class="headerlink" title="mappingCount与Size方法"></a>mappingCount与Size方法</h6><p>mappingCount与size方法的类似  从Java工程师给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。<br><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> size() &#123;<br>    <span class="hljs-built_in">long</span> n = sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0</span>L) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-built_in">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-built_in">int</span>)n);<br>&#125;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the number of mappings. This method should be used</span><br><span class="hljs-comment"> * instead of &#123;@link #size&#125; because a ConcurrentHashMap may</span><br><span class="hljs-comment"> * contain more mappings than can be represented as an int. The</span><br><span class="hljs-comment"> * value returned is an estimate; the actual count may differ if</span><br><span class="hljs-comment"> * there are concurrent insertions or removals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return the number of mappings</span><br><span class="hljs-comment"> * @since 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> mappingCount() &#123;<br>    <span class="hljs-built_in">long</span> n = sumCount();<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>L) ? <span class="hljs-number">0</span>L : n; <span class="hljs-comment">// ignore transient negative values</span><br>&#125;<br><br> <span class="hljs-keyword">final</span> <span class="hljs-built_in">long</span> sumCount() &#123;<br>    CounterCell[] <span class="hljs-keyword">as</span> = counterCells; CounterCell a;<br>    <span class="hljs-built_in">long</span> <span class="hljs-keyword">sum</span> = baseCount;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">as</span> != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">as</span>.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = <span class="hljs-keyword">as</span>[i]) != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">sum</span> += a.value;<span class="hljs-comment">//所有counter的值求和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h6><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。<br><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> addCount(<span class="hljs-built_in">long</span> x, <span class="hljs-built_in">int</span> check) &#123;<br>    CounterCell[] <span class="hljs-keyword">as</span>; <span class="hljs-built_in">long</span> b, s;<br>    <span class="hljs-comment">//利用CAS方法更新baseCount的值 </span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">as</span> = counterCells) != <span class="hljs-literal">null</span> ||<br>        !U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>        CounterCell a; <span class="hljs-built_in">long</span> v; <span class="hljs-built_in">int</span> m;<br>        <span class="hljs-built_in">boolean</span> uncontended = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">as</span> == <span class="hljs-literal">null</span> || (m = <span class="hljs-keyword">as</span>.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = <span class="hljs-keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended =<br>              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        s = sumCount();<br>    &#125;<br>    <span class="hljs-comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span><br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-built_in">int</span> n, sc;<br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-built_in">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-built_in">int</span> rs = resizeStamp(n);<br>            <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-comment">//如果已经有其他线程在执行扩容操作</span><br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-literal">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="ConcurrentHashMap-在-JDK7-和-JDK8的区别？"><a href="#ConcurrentHashMap-在-JDK7-和-JDK8的区别？" class="headerlink" title="ConcurrentHashMap 在 JDK7 和 JDK8的区别？"></a>ConcurrentHashMap 在 JDK7 和 JDK8的区别？</h2><ol><li>数据结构：JDK7 的数据结构是 Segment数组 + HashEntry数组 + 链表，JDK8 的数据结构是 HashEntry数组 + 链表 + 红黑树，当链表的长度超过8时，链表就会转换成红黑树，从而降低时间复杂度（由O(n) 变成了 O(logN)），提高了效率</li><li>锁的实现：JDK7的锁是segment，是基于ReentronLock实现的，包含多个HashEntry；而JDK8 降低了锁的粒度，采用 table 数组元素作为锁，从而实现对每行数据进行加锁，进一步减少并发冲突的概率，并使用 synchronized 来代替 ReentrantLock，因为在低粒度的加锁方式中，synchronized 并不比 ReentrantLock 差，在粗粒度加锁中ReentrantLock 可以通过 Condition 来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了。</li><li>统计集合中元素个数 size 的方式：JDK7 是先尝试 2次通过不锁住 segment 的方式来统计各个 segment 大小，如果统计的过程中，容器的 count 发生了变化，则再采用加锁的方式来统计所有Segment的大小；在 JDK8 中，对于size的计算，在扩容和 addCount() 方法中就已经有处理了，等到调用 size() 时直接返回元素的个数</li></ol>]]></content>
    
    
    <summary type="html">带锁的Map</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>强引用 弱引用 软引用 虚引用</title>
    <link href="http://example.com/2023/08/15/Reference/"/>
    <id>http://example.com/2023/08/15/Reference/</id>
    <published>2023-08-15T15:11:32.000Z</published>
    <updated>2023-08-17T02:19:42.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h2><p>我们使用的大部分的引用都是强引用，这是使用最普遍的引用。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。<strong>只要还有强引用指向一个对象，垃圾收集器就不会回收这个对象。</strong></p><h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。只有在内存不足的时候JVM才会回收该对象。这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span> o = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>();<br>SoftReference&lt;<span class="hljs-keyword">Object</span>&gt; so = <span class="hljs-built_in">new</span> SoftReference&lt;&gt;(o);<br>o = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">System</span>.gc();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(so.<span class="hljs-keyword">get</span>());<br></code></pre></td></tr></table></figure><br>当我们设置了本地jvm内存后，通过下面代码就可以看到在内存不足时，软引用就会删除内存数据：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; q = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br>SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; so2 = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">13</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>], q);<br>System.out.<span class="hljs-built_in">println</span>(so2.<span class="hljs-built_in">get</span>());<br>System.<span class="hljs-built_in">gc</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">500</span>);<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>    e.<span class="hljs-built_in">printStackTrace</span>();<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] bytes = so2.<span class="hljs-built_in">get</span>();<br>System.out.<span class="hljs-built_in">println</span>(so2.<span class="hljs-built_in">get</span>());<br><br><span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">13</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>System.out.<span class="hljs-built_in">println</span>(so2.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure></p><h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。所以被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">WeakReference&lt;<span class="hljs-keyword">String</span>&gt; sr = <span class="hljs-keyword">new</span> WeakReference&lt;<span class="hljs-keyword">String</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>      System.out.<span class="hljs-built_in">println</span>(sr.<span class="hljs-built_in">get</span>());<br>      System.<span class="hljs-built_in">gc</span>();                <span class="hljs-comment">//通知JVM的gc进行垃圾回收</span><br>      System.out.<span class="hljs-built_in">println</span>(sr.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure></p><p>一个很好的例子是ThreadLocal中的子类ThreadLocalMap下的Entry对象，他是一个弱引用，而value则是传入的数据。<br>当传入的value是强引用，而entry回收后key为null，value未被回收，这导致内存一直被占用，造成内存泄漏。<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br><br>    static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;<br>        <br>        <span class="hljs-type">Object</span> value;<br><br>        <span class="hljs-type">Entry</span>(<span class="hljs-type">ThreadLocal</span>&lt;?&gt; k, <span class="hljs-type">Object</span> v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">Entry</span>[] table;<br></code></pre></td></tr></table></figure></p><h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动。</p><p>虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>弱引用可以使用ReferenceQueue,虚引用必须配合ReferenceQueue使用。jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外,所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。</p><p>DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。</p><h2 id="Reference-、ReferenceQueue"><a href="#Reference-、ReferenceQueue" class="headerlink" title="Reference 、ReferenceQueue"></a>Reference 、ReferenceQueue</h2><h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p>引用队列，在检测到适当的可到达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。</p><p>实现了一个队列的入队(enqueue)和出队(poll还有remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。</p><p>ReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>volatile Reference&lt;? extends T&gt; head = null;</code><br>始终保存当前队列中最新要被处理的节点，可以认为queue为一个后进先出的队列。当新的节点进入时，采取以下的逻辑：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">Reference&lt;? <span class="hljs-keyword">extends</span> T&gt; r</span>)</span> &#123;<br>    ...<br>    r.next = (head == <span class="hljs-literal">null</span>) ? r : head;<br>    head = r;<br>    ...<br></code></pre></td></tr></table></figure><br>在获取时：<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">private</span> Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; reallyPoll() &#123;       <span class="hljs-comment">/* Must hold lock */</span><br>    Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; r = head;<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>        Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; rn = r.next;<br>        head = (rn == r) ? <span class="hljs-literal">null</span> : rn;<br>        r.queue = <span class="hljs-literal">NULL</span>;<br>        r.next = r;<br>        ...<br></code></pre></td></tr></table></figure></p><p><code>long queueLength = 0;</code>队列长度</p><p><code>Lock lock = new Lock()</code>专用于作为锁对象使用以保证Reference（引用）类对象不会出现线程安全问题</p><p><code>static ReferenceQueue&lt;Object&gt; NULL = new Null&lt;&gt;()</code>“空”引用队列<br>如果一个Reference（引用）类对象没有注册ReferenceQueue（引用队列）类对象或已经从中出队，则会将其queue（引用队列）字段设置为NULL（“空”引用队列），因此可以通过判断Reference（引用）类对象的queue（引用队列）字段是否为NULL（“空”引用队列）来判断其是否注册及出队。</p><p><code>static ReferenceQueue&lt;Object&gt; ENQUEUED = new Null&lt;&gt;()</code>“入队”引用队列<br>被作为标记值使用。如果一个Reference（引用）类对象已经入队，则其queue（引用队列）字段设置为ENQUEUED（“入队”引用队列），因此可以通过判断Reference（引用）类对象的queue（引用队列）字段是否为ENQUEUED（“入队”引用队列）来判断其是否入队。<code>Null</code>对象保证无法使用入栈功能。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>enqueue()</code>入队（false：失败，true：成功）<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="hljs-comment">/* Called only by Reference class */</span><br>    <span class="hljs-comment">// 同步</span><br>    <span class="hljs-built_in">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 获取引用对象所注册的引用队列（快照），并判断引用队列（快照）是否合法。</span><br>        ReferenceQueue&lt;?&gt; queue = r.queue;<br>        <span class="hljs-keyword">if</span> ((queue == <span class="hljs-literal">NULL</span>) || (queue == ENQUEUED)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 断言引用队列（快照）与当前引用队列对象相等。</span><br>        assert queue == <span class="hljs-keyword">this</span>;<br>        <span class="hljs-comment">// 设置引用对象所注册的引用队列为&quot;入队&quot;引用队列，表示当前对象已经被加入引用队列。之所以要替换掉引用对象注册的引用队列有两</span><br>        <span class="hljs-comment">// 个方面的原因：一是引用对象只允许入队/出队一次，在入队操作完成后替换为&quot;入队&quot;引用队列可以避免二次入队；二是可以通过判断当前</span><br>        <span class="hljs-comment">// 引用对象是否处于引用队列中。</span><br>        r.queue = ENQUEUED;<br>        <span class="hljs-comment">// 将该节点加入到header，并将之前的header设置为next</span><br>        r.next = (head == null) ? r : head;<br>        head = r;<br>        queueLength++;<br>        <span class="hljs-comment">// 如果是最终引用类型，递增终引用的计数。</span><br>        <span class="hljs-keyword">if</span> (r instanceof FinalReference) &#123;<br>            sun.misc.VM.<span class="hljs-built_in">addFinalRefCount</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 唤醒所有处于等待状态中的线程</span><br>        lock.<span class="hljs-built_in">notifyAll</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>调用此方法可将Reference（引用）类对象加入队列中。该方法受synchronized关键字保护，因为ReferenceQueue（引用队列）类对象可能会在多线程的环境下使用，因此需要相应的同步手段确保来确保ReferenceQueue（引用队列）类对象中的数据不会出现错误。需要提及的是，enqueue()采用的是头插法，也就是说新入队的Reference（引用）类对象会成为新的头Reference（引用）类对象</p><p><code>poll()</code>出队<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; poll() &#123;<br>    <span class="hljs-comment">// 判断是否为空，此处不仅仅只做一次，在同步环境的reallyPoll中也做了一次检查，双重检查判断是否为空。</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    synchronized (lock) &#123;<br>        <span class="hljs-keyword">return</span> reallyPoll();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; reallyPoll() &#123;       <span class="hljs-comment">/* Must hold lock */</span><br>    <span class="hljs-comment">// 获取头引用（快照）。</span><br>    Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; r = head;<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>        @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>        <br>        <span class="hljs-comment">// 获取头引用对象（快照）的下个引用对象（快照）。</span><br>        Reference<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; rn = r.next;<br>        <span class="hljs-comment">// 如果是最后一个与下一个相同，则表示最后一个，否则设置为下一个。</span><br>        head = (rn == r) ? <span class="hljs-literal">null</span> : rn;<br>        <span class="hljs-comment">// 设置头引用对象（快照）的注册引用队列为&quot;空&quot;引用队列，因为该引用对象已经完成了入队/出队操作，引用队列对其已经不在有意义</span><br>        r.queue = <span class="hljs-literal">NULL</span>;<br>        r.next = r;<br>        queueLength--;<br>        <span class="hljs-comment">// 如果是最终引用类型，递减终引用的计数。</span><br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> FinalReference) &#123;<br>            sun.misc.VM.addFinalRefCount(-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 返回出队的头引用对象（快照）。</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>调用此方法可将ReferenceQueue（引用队列）类对象的头Reference（引用）类对象弹出，当存在头Reference（引用）类对象时返回头Reference（引用）类对象，否则返回null。poll()采用的是头出法，即后继ReferenceQueue（引用队列）类对象会成为新的头ReferenceQueue（引用队列）类对象。通过观察enqueue/poll()方法的运行机制可知，ReferenceQueue（引用队列）类并不是真正的队列，因为队列必须需要保证FIFO（先入先出），而ReferenceQueue（引用队列）类是FILO（先入后出）的运行方式，因此其本质实际是一个栈。</p><p><code>remove(long timeout)/remove()</code>限时移除/无限时移除<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> Reference&lt;? <span class="hljs-keyword">extends</span> T&gt; remove(<span class="hljs-keyword">long</span> timeout)<br>    <span class="hljs-keyword">throws</span> IllegalArgumentException, InterruptedException<br>&#123;<br>    <span class="hljs-comment">// 判断限时是否合法</span><br>    <span class="hljs-keyword">if</span> (timeout &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Negative timeout value&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在同步保护下执行</span><br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 获取被出队的引用对象（前头引用对象），如果不为空，则直接返回，表示移除了该引用对象。</span><br>        Reference&lt;? <span class="hljs-keyword">extends</span> T&gt; r = reallyPoll();<br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> r;<br>        <span class="hljs-comment">// 如果引用队列为空，则在限时中等待新的引用对象入队后将之移除。</span><br>        <span class="hljs-keyword">long</span> start = (timeout == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : System.nanoTime();<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 令当前线程陷入阻塞（本质是加入Monitor对象的WaitSet中），直至被执行enqueue()的线程唤醒。</span><br>            lock.wait(timeout);<br>            <span class="hljs-comment">// 出队操作，此时可能返回null，因为入队唤醒的是所有阻塞线程，入队的引用对象可能已经被其它线程出队。</span><br>            r = reallyPoll();<br>            <span class="hljs-comment">// 如果成功弹出，则返回，表示成功移除。</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> r;<br>            <span class="hljs-comment">// 如果限时不为0，判断限时时间是否到达（限时为0时表示无限尝试直至成功为止）。</span><br>            <span class="hljs-keyword">if</span> (timeout != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">long</span> end = System.nanoTime();<br>                timeout -= (end - start) / <span class="hljs-number">1000</span>_000;<br>                <span class="hljs-keyword">if</span> (timeout &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                start = end;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the next reference object in this queue, blocking until one</span><br><span class="hljs-comment"> * becomes available.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> A reference object, blocking until one becomes available</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  InterruptedException  If the wait is interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Reference&lt;? <span class="hljs-keyword">extends</span> T&gt; remove() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>remove()方法的作用与poll()方法相同，都是将ReferenceQueue（引用队列）类对象的头Reference（引用）类对象弹出并返回，实际上remove()方法底层就是调用poll()方法实现的。两者的区别在于，如果头Reference（引用）类对象不存在，poll()方法会直接返回null，而remove()方法则是会进入阻塞状态，直至有Reference（引用）类对象入队后被唤醒并将之弹出。remove()方法有两个重载，但实际上可以看作一个，因为其中一个是通过调用另一个实现的。</p><p><img src="/img/Reference/0.png" alt="github"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>java.lang.ref.Reference 为 软（soft）引用、弱（weak）引用、虚（phantom）引用的父类。</p><p>因为Reference对象和垃圾回收密切配合实现，该类可能不能被直接子类化。<br>可以理解为Reference的直接子类都是由jvm定制化处理的,因此在代码中直接继承于Reference类型没有任何作用。但可以继承jvm定制的Reference的子类。<br>例如：Cleaner 继承了 PhantomReference<br><code>public class Cleaner extends PhantomReference&lt;Object&gt;</code></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>其内部提供2个构造函数，一个带queue，一个不带queue。其中queue的意义在于，增加注册的queue。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">Reference(T <span class="hljs-built_in">ref</span>erent) &#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-built_in">ref</span>erent, <span class="hljs-literal">null</span>);<br>&#125;<br><br>Reference(T <span class="hljs-built_in">ref</span>erent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue) &#123;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-built_in">ref</span>erent = <span class="hljs-built_in">ref</span>erent;<br>    <span class="hljs-keyword">this</span>.queue = (queue == <span class="hljs-literal">null</span>) ? ReferenceQueue.NULL : queue;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><code>T referent;</code>应用存储的对象。</p><p><code>volatile Reference next;</code>作为queue的节点，此处指向下一个引用对象。</p><p><code>transient private Reference&lt;T&gt; discovered;</code>被VM使用。</p><ul><li>当处于active状态时：discoverd reference的下一个元素是由GC操纵的( 如果是最后一个了则为this )；</li><li>当处于pending状态：discovered为pending集合中的下一个元素( 如果是最后一个了则为null )；</li><li>其他状态：discovered为null</li></ul><p><code>private static Lock lock = new Lock();</code>锁，与ReferenceQueue中类似。</p><p><code>static Reference&lt;Object&gt; pending = null;</code>等待被入队的引用列表。收集器会添加引用到这个列表，直到Reference-handler线程移除了它们。这个列表被上面的lock对象保护。这个列表使用discovered字段来连接它自己的元素( 即pending的下一个元素就是discovered对象 )。<br>jvm在gc时会将要处理的对象放到这个静态字段上面。同时，另一个字段discovered：表示要处理的对象的下一个对象。即可以理解要处理的对象也是一个链表，通过discovered进行排队，这边只需要不停地拿到pending，然后再通过discovered不断地拿到下一个对象赋值给pending即可，直到取到了最有一个。因为这个pending对象，两个线程都可能访问,因此需要加锁处理。</p><p><code>volatile ReferenceQueue&lt;? super T&gt; queue;</code>是对象即将被回收时所要通知的队列。<br>这里的queue( 即，ReferenceQueue对象 )名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。<br>Reference有4种状态，不同状态的reference其queue也不同：</p><ul><li>Active：新创建的引用对象都是这个状态，在 GC 检测到引用对象已经到达合适的reachability时，GC 会根据引用对象是否在创建时制定ReferenceQueue参数进行状态转移，如果指定了，那么转移到Pending，如果没指定，转移到Inactive。</li><li>Pending：pending-Reference列表中的引用都是这个状态，它们等着被内部线程ReferenceHandler处理入队（会调用ReferenceQueue.enqueue方法）。没有注册的实例不会进入这个状态。</li><li>Enqueued：相应的对象已经为待回收，并且相应的引用对象已经放到queue当中了。准备由外部线程来询问queue获取相应的数据。调用ReferenceQueue.enqueued方法后的Reference处于这个状态中。当Reference实例从它的ReferenceQueue移除后，它将成为Inactive。没有注册的实例不会进入这个状态。</li><li>Inactive：即此对象已经由外部从queue中获取到，并且已经处理掉了。即意味着此引用对象可以被回收，并且对内部封装的对象也可以被回收掉了( 实际的回收运行取决于clear动作是否被调用 )。可以理解为进入到此状态的肯定是应该被回收掉的。一旦一个Reference实例变为了Inactive，它的状态将不会再改变。</li></ul><p>jvm并不需要定义状态值来判断相应引用的状态处于哪个状态，只需要通过计算next和queue即可进行判断。</p><ul><li>Active：queue为创建一个Reference对象时传入的ReferenceQueue对象；如果ReferenceQueue对象为空或者没有传入ReferenceQueue对象，则为ReferenceQueue.NULL；next==null；</li><li>Pending：queue为初始化时传入ReferenceQueue对象；next==this(由jvm设置)；</li><li>Enqueue：当queue!=null &amp;&amp; queue != ENQUEUED 时；设置queue为ENQUEUED；next为下一个要处理的reference对象，或者若为最后一个了next==this；</li><li>Inactive：queue = ReferenceQueue.NULL; next = this.</li></ul><p>那么针对不同的子类，会得到不同的实现：</p><ul><li>WeakReference对象进入到queue之后,相应的referent为null。</li><li>SoftReference对象，如果对象在内存足够时，不会进入到queue，自然相应的referent不会为null。如果需要被处理( 内存不够或其它策略 )，则置相应的referent为null，然后进入到queue。通过debug发现，SoftReference是pending状态时，referent就已经是null了，说明此事referent已经被GC回收了。</li><li>FinalReference对象，因为需要调用其finalize对象，因此其reference即使入queue，其referent也不会为null，即不会clear掉。</li><li>PhantomReference对象，因为本身get实现为返回null。因此clear的作用不是很大。因为不管enqueue还是没有，都不会清除掉。</li></ul><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><code>T get()</code>获取<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> T <span class="hljs-keyword">get</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.referent;<br>&#125;<br></code></pre></td></tr></table></figure><br>获取当前引用的所指对象，当所指对象不存在时返回null。所指对象初始是必然存在的，但可以在后期被清除。</p><p><code>clear()</code>清除<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.referent = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>清除当前引用的所指对象（即断开两者的引用关系），并不会将当前引用加入到注册引用队列中。该方法专为开发者提供，GC线程不会调用该方法断开当前引用与其所指对象的关联。</p><p><code>boolean isEnqueued()</code>是否入队<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnqueued</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.queue == ReferenceQueue.ENQUEUED);<br>&#125;<br></code></pre></td></tr></table></figure><br>判断当前引用是否已加入注册引用队列，是则返回true；否则返回false。引用加入注册引用队列时会将自身注册的引用队列替换为“入队”引用队列，这是一个在引用队列类内部创建的全局静态引用队列，被作为引用加入注册引用队列的标志位来使用。因此判断当前引用是否加入注册引用队列无需遍历注册引用队列，直接判断注册引用队列是否是“入队”引用队列即可。</p><p><code>boolean enqueue()</code>入队<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue.<span class="hljs-built_in">enqueue</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>将当前引用加入注册引用队列中，成功返回true；否则返回false。该方法底层调用引用队列类的enqueue(Reference&lt;? extends T&gt; r) 方法实现。该方法专为开发者提供，“引用处理器”线程不会调用该方法将当前引用加入注册引用队列。</p><h2 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h2><p><code>active ——&gt; pending</code> ：<code>Reference#tryHandlePending</code><br><code>pending ——&gt; enqueue</code> ：<code>ReferenceQueue#enqueue</code><br><code>enqueue ——&gt; inactive</code> ：<code>Reference#clear</code><br><img src="/img/Reference/1.png" alt="github"></p><h2 id="重要功能"><a href="#重要功能" class="headerlink" title="重要功能"></a>重要功能</h2><h2 id="ReferenceHandler线程"><a href="#ReferenceHandler线程" class="headerlink" title="ReferenceHandler线程"></a>ReferenceHandler线程</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> ReferenceHandler extends Thread &#123;<br><br>    <span class="hljs-keyword">private</span> static void ensure<span class="hljs-constructor">ClassInitialized(Class&lt;?&gt; <span class="hljs-params">clazz</span>)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">clazz</span>.<span class="hljs-params">getName</span>()</span>, <span class="hljs-literal">true</span>, clazz.get<span class="hljs-constructor">ClassLoader()</span>);<br>        &#125; catch (ClassNotFoundException e) &#123;<br>            throw (Error) <span class="hljs-keyword">new</span> <span class="hljs-constructor">NoClassDefFoundError(<span class="hljs-params">e</span>.<span class="hljs-params">getMessage</span>()</span>).init<span class="hljs-constructor">Cause(<span class="hljs-params">e</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    static &#123;<br>        <span class="hljs-comment">// pre-load and initialize InterruptedException and Cleaner classes</span><br>        <span class="hljs-comment">// so that we don&#x27;t get into trouble later in the run loop if there&#x27;s</span><br>        <span class="hljs-comment">// memory shortage while loading/initializing them lazily.</span><br>        ensure<span class="hljs-constructor">ClassInitialized(InterruptedException.<span class="hljs-params">class</span>)</span>;<br>        ensure<span class="hljs-constructor">ClassInitialized(Cleaner.<span class="hljs-params">class</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-constructor">ReferenceHandler(ThreadGroup <span class="hljs-params">g</span>, String <span class="hljs-params">name</span>)</span> &#123;<br>        super(g, name);<br>    &#125;<br><br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span><span class="hljs-constructor">HandlePending(<span class="hljs-params">true</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处会预加载并初始化 InterruptedException 和 Cleaner 类，来避免出现在循环运行过程中时由于内存不足而无法加载它们。然后run方法中使用了while死循环运行tryHandlerPending方法。这个方法通过名字就能大概判断，应该是来处理pending链表的。</p><h2 id="tryHandlePending"><a href="#tryHandlePending" class="headerlink" title="tryHandlePending()"></a>tryHandlePending()</h2><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">boolean</span> tryHandlePending(<span class="hljs-keyword">boolean</span> waitForNotify) &#123;<br>    Reference&lt;<span class="hljs-keyword">Object</span>&gt; r;<br>    Cleaner c;<br>    <span class="hljs-keyword">try</span> &#123;<br>        synchronized (lock) &#123;<br>            <span class="hljs-comment">// 如果pending链表不为null，则开始进行处理</span><br>            <span class="hljs-keyword">if</span> (pending != <span class="hljs-literal">null</span>) &#123;<br>                r = pending;<br>                <span class="hljs-comment">// 使用 &#x27;instanceof&#x27; 有时会导致OOM</span><br>                <span class="hljs-comment">// 所以在将r从链表中摘除时先进行这个操作</span><br>                c = r <span class="hljs-keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 移除头结点，将pending指向其后一个节点</span><br>                pending = r.discovered;<br>                <span class="hljs-comment">// 此时r为原来pending链表的头结点，已经从链表中脱离出来</span><br>                r.discovered = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 在锁上等待可能会造成OOM，因为它会试图分配exception对象</span><br>                <span class="hljs-keyword">if</span> (waitForNotify) &#123;<br>                    lock.wait();<br>                &#125;<br>                <span class="hljs-comment">// 重试</span><br>                <span class="hljs-keyword">return</span> waitForNotify;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Thread.<span class="hljs-keyword">yield</span>();<br>        <span class="hljs-comment">// 重试</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>        <span class="hljs-comment">// 重试</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// F如果摘除的元素是Cleaner类型，则执行其clean方法</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>        c.clean();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ReferenceQueue<span class="hljs-meta">&lt;?</span> super <span class="hljs-keyword">Object</span>&gt; q = r.queue;<br>    <span class="hljs-comment">// 最后，如果其引用队列不为空，则将该元素入队</span><br>    <span class="hljs-keyword">if</span> (q != ReferenceQueue.<span class="hljs-literal">NULL</span>) q.enqueue(r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里整个过程就是摘取pending链表的头结点，如果是Cleaner，则执行clean操作，否则进行入队处理。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">static &#123;<br>    ThreadGroup tg = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">ThreadGroup()</span>;<br>    <span class="hljs-keyword">for</span> (ThreadGroup tgn = tg;<br>         tgn != null;<br>         tg = tgn, tgn = tg.get<span class="hljs-constructor">Parent()</span>);<br>    Thread handler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReferenceHandler(<span class="hljs-params">tg</span>, <span class="hljs-string">&quot;Reference Handler&quot;</span>)</span>;<br>    <span class="hljs-comment">/* If there were a special system-only priority greater than</span><br><span class="hljs-comment">     * MAX_PRIORITY, it would be used here</span><br><span class="hljs-comment">     */</span><br>    handler.set<span class="hljs-constructor">Priority(Thread.MAX_PRIORITY)</span>;<br>    handler.set<span class="hljs-constructor">Daemon(<span class="hljs-params">true</span>)</span>;<br>    handler.start<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// provide access in SharedSecrets</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedSecrets</span>.</span></span>set<span class="hljs-constructor">JavaLangRefAccess(<span class="hljs-params">new</span> JavaLangRefAccess()</span> &#123;<br>        @Override<br>        public boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">HandlePendingReference()</span> &#123;<br>            return <span class="hljs-keyword">try</span><span class="hljs-constructor">HandlePending(<span class="hljs-params">false</span>)</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>Reference Handler线程会注册到根线程组并设置最高优先级，守护线程并运行线程。最后覆盖了JVM中对pending的默认处理方式。</p><p><img src="/img/Reference/2.png" alt="github"></p><ul><li>待定列表：待定列表时全局静态变量的方式存在引用类中。其并非实际的列表对象而是逻辑列表。引用类只保存待定列表的头节点，并通过节点之间的引用里访问整个列表。引用加入引用队列之前会暂时与待定列表。</li><li>引用队列：用于追踪所指对象的GC状态，当所指对象被GC回收时，其对应引用会被安排加入其注册的引用队列中，由此引用是否处于引用队列可作为其所指对象是否被GC回收的判断依据，并可以此为契机执行某些自定义操作。与待定列表不同，引用队列并不唯一，并且是实际的队列对象。</li></ul><h2 id="FinalReference-Finalizer"><a href="#FinalReference-Finalizer" class="headerlink" title="FinalReference/Finalizer"></a>FinalReference/Finalizer</h2><p>FinalReference（终引用）类是Reference（引用）抽象类的四大子类之一，被作用于实现Java的Finalization（终结）机制。相比其他三个子类而言终引用类相对鲜为人知，因为本身的封闭性令其无法被开发者直接使用，毕竟其在设计上就是为了后台运行而服务的。<br><strong>终引用类必须搭配引用队列使用，该特性与PhantomReference（虚引用）类一致。</strong></p><p>终引用类最大的特点在于其所指对象的回收时机与其它子类不同。<br>对于引用抽象类的其它子类，当其所指对象被GC判定为可回收后便会被顺势回收，与此同时引用机制还会将其加入注册引用队列中。换而言之，就是加入到引用队列中的引用的所指对象都可以被视作已GC回收。终引用类与此不同，虽说其在所指对象的可回收判定中并不会造成影响，但即使终引用已经被加入了引用队列，其所指对象也不会被GC回收，而是会等到所指对象的finalize()方法被执行完毕后断开与终引用的关联关系才会被回收。</p><p><strong>终引用类的存在是为了实现终结机制而提供对对象生命周期的干预机制，即影响对象的回收时机，而实际真正实现该机制的是其子类Finalizer（终结者），Java终结机制正是通过终结者类与底层逻辑相互配合实现的。</strong></p><p>Finalizer（终结者）类是FinalReference（终引用）类的子类，其访问权限为DEFAULT，即只有同一个包下的类才能够进行调用，且其被final关键字修饰，因此可知其无法再被其它子类继承。<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Finalizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FinalReference&lt;Object&gt;</span> </span>&#123;<br></code></pre></td></tr></table></figure></p><p>Finalizer（终结者）类对象会在何时加入未终结链表中呢？F类对象创建时，JVM将之作为所指对象调用Finalizer（终结者）类的register()方法创建一个Finalizer（终结者）类对象并加入到未终结链表中。实际上关于Finalizer（终结者）类对象的加入时间还能有更加精确的描述及调整。众所周知Java对象的创建并不是一个原子操作，其大致可以分为两个部分：实例化（分配内存）与初始化（执行构造方法）。通过对JVM参数-XX:+RegisterFinalizersAtInit的设置（默认为+），可以令Finalizer（终结者）类对象在F类实例化后、初始化前的时间段创建加入（-XX:-RegisterFinalizersAtInit），也可以令其在F类初始化后创建加入（-XX:+RegisterFinalizersAtInit）。<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> Heap::AddFinalizerReference(Thread* <span class="hljs-built_in">self</span>, ObjPtr&lt;mirror::Object&gt;* <span class="hljs-keyword">object</span>) &#123;<br>    ScopedObjectAccess soa(<span class="hljs-built_in">self</span>);<br>    ScopedLocalRef&lt;jobject&gt; arg(<span class="hljs-built_in">self</span>-&gt;GetJniEnv(), soa.AddLocalReference&lt;jobject&gt;(*<span class="hljs-keyword">object</span>));<br>    jvalue args[<span class="hljs-number">1</span>];<br>    args[<span class="hljs-number">0</span>].l = arg.get();<br>    <span class="hljs-comment">// 调用 Java 层静态方法 FinalizerReference#add</span><br>    InvokeWithJValues(soa, nullptr, WellKnownClasses::java_lang_ref_FinalizerReference_add, args);<br>    *<span class="hljs-keyword">object</span> = soa.Decode&lt;mirror::Object&gt;(arg.get());<br>&#125;<br></code></pre></td></tr></table></figure><br>JVM是如何做到在指定的时间里调用Finalizer（终结者）类的register()方法的呢？这个就要根据不同的情况判断。针对在实例化后、初始化前调用的F类对象，由于内存分配是统一由内存管理系统负责的，因此可以由其负责处理；而对于在初始化后的F类对象则相对负责，难道要在所有的构造方法尾部都进行处理吗？当然是不可能。实际上JVM使用了一个很灵活的方式，在Java中，子类的构造方法会调用父类的构造方法，因此最终都会执行Object（对象）类的构造方法。JVM将Object（对象）类的构造方法里的return指令替换为_return_register_finalizer指令，从而在侵入性很小的情况下完成了方法调用。</p><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p><code>static ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</code>引用队列<br>该字段是一个静态字段，其默认了一个ReferenceQueue（引用队列）类的实例，被作为Finalizer（终结者）类对象注册引用队列使用，因此可知所有的Finalizer（终结者）类对象注册的都是同一个引用队列。即，f-queue。</p><p><code>static Finalizer unfinalized = null;</code>未终结的对象<br>该字段是一个静态字段，被用于保存未终结链表的头Finalizer（终结者）类对象，在整个JVM中只存在一个未终结链表。未终结链表的作用是为了保证Finalizer（终结者）类对象不会被GC回收，如果没有未终结链表会导致Finalizer（终结者）类对象加入引用队列之前不可达（即不存在GC Roots关联的链路），这会使其被GC回收。</p><p><code>static final Object lock = new Object()</code>锁<br>用于在操作未终结链表时作为synchronized关键字的锁对象使用。该字段是一个静态字段，因此可知是一个类锁。</p><p><code>private Finalizer next = null, prev = null;</code>前驱终结者/后驱终结者<br>用于持有当前Finalizer（终结者）类对象在未终结链表中后继/前驱Finalizer（终结者）类对象的引用，因此可知未终结链表是一个双向链表。当Finalizer（终结者）类对象从未终结链表中移除时，会将两者都指向自身，因此可以由此判断一个Finalizer（终结者）类对象是否移除。</p><h2 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">static &#123;<br>    <span class="hljs-comment">// 获取线程组信息</span><br>    ThreadGroup tg = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">ThreadGroup()</span>;<br>    <span class="hljs-keyword">for</span> (ThreadGroup tgn = tg;<br>         tgn != null;<br>         tg = tgn, tgn = tg.get<span class="hljs-constructor">Parent()</span>);<br>         <br>    <span class="hljs-comment">// 实例化的终结者线程，设置其优先级为8（相对其他守护线程会低一些）且为守护线程，并执行。</span><br>    Thread finalizer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FinalizerThread(<span class="hljs-params">tg</span>)</span>;<br>    finalizer.set<span class="hljs-constructor">Priority(Thread.MAX_PRIORITY - 2)</span>;<br>    finalizer.set<span class="hljs-constructor">Daemon(<span class="hljs-params">true</span>)</span>;<br>    finalizer.start<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态块中创建了一个FinalizerThread（终结者线程）类对象，也就是所谓的终结者线程，因此可知终结者线程会在Finalizer（终结者）类的类加载过程的初始化步骤完成创建。终结者线程专用于对f-queue中的Finalizer（终结者）类对象进行处理，即执行其所指对象/F类对象的finalize方法。终结者线程是一个守护线程，其优先级为8。</p><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><p>Finalizer（终结者）类只有一个构造方法，通过调用父类FinalReference（终引用）类的构造方法实现。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Finalizer</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> finalizee</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(finalizee, queue);<br>    <span class="hljs-comment">// 将终结者对象加入未终结链表中。</span><br>    add();<br>&#125;<br></code></pre></td></tr></table></figure><br>其将queue（引用队列）字段的默认ReferenceQueue（引用队列）类对象作为Finalizer（终结者）类对象的注册引用队列，因此可知所有的Finalizer（终结者）类对象注册的都是同一个引用队列。与此同时该构造方法还会将Finalizer（终结者）类对象加入到未终结链表中。该构造方法是私有的，因此可知Finalizer（终结者）类对象无法直接在类的外部使用new创建。</p><p>注册<br><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> finalizee</span>)</span> &#123;<br>    <span class="hljs-keyword">new</span> Finalizer(finalizee);<br>&#125;<br></code></pre></td></tr></table></figure><br>即实例化一个Finalizer（终结者）类对象并将之加入注册队列中，是直接调用构造方法实现的。register()是供JVM使用的，因此除非使用反射，否则开发者无法调用该方法。JVM会在F类创建时调用这个方法。</p><p>是否终结（false：否，true：是）<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">hasBeenFinalized</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (next == <span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>判断当前Finalizer（终结者）类对象是否已经从未终结链表中移除。终结者对象从终结者链表中移除时，会将前驱终结者/后继终结者设置为自身，因此只需判断是否为自身即可。</p><p>新增<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-keyword">if</span> (unfinalized != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.next = unfinalized;<br>            unfinalized.prev = <span class="hljs-keyword">this</span>;<br>        &#125;<br>        unfinalized = <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>将当前Finalizer（终结者）类对象添加进未终结链表中。该方法采用的是头插法，即新加入的Finalizer（终结者）类对象会成为头Finalizer（终结者）类对象，而原Finalizer（终结者）类对象则会成为其后继Finalizer（终结者）类对象。</p><p>移除<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> void remove() &#123;<br>    synchronized (lock) &#123;<br>        <span class="hljs-keyword">if</span> (unfinalized == <span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.next != <span class="hljs-literal">null</span>) &#123;<br>                unfinalized = <span class="hljs-keyword">this</span>.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                unfinalized = <span class="hljs-keyword">this</span>.prev;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.next.prev = <span class="hljs-keyword">this</span>.prev;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.prev != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.prev.next = <span class="hljs-keyword">this</span>.next;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">this</span>;   <span class="hljs-comment">/* Indicates that this has been finalized */</span><br>        <span class="hljs-keyword">this</span>.prev = <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>将当前Finalizer（终结者）类对象从未终结链表中移除。将Finalizer（终结者）类对象从未终结链表中移除并不需要遍历，因为其保存了前驱/后继Finalizer（终结者）类对象的引用，因此只需将前驱/后继Finalizer（终结者）类对象重新建立关联后将自身弹出即可。弹出的同时，需要将next（后继终结者）/prev（前驱终结者）字段指向自身，作为Finalizer（终结者）类对象已经移除的标志。</p><p>执行终结者<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> runFinalizer(JavaLangAccess jla) &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">//  判断当前终结者对象是否已经终结，即判断其是否已从未终结链表中移除。是则直接返回，否则移除。</span><br>        <span class="hljs-keyword">if</span> (hasBeenFinalized()) <span class="hljs-keyword">return</span>;<br>        remove();<br>    &#125;<br>    <span class="hljs-comment">// 在catch块中执行终结者对象的所指对象的finalize()方法，目的是确保执行异常时不会中断终结者线程。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">Object</span> finalizee = <span class="hljs-keyword">this</span>.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">if</span> (finalizee != <span class="hljs-keyword">null</span> &amp;&amp; !(finalizee <span class="hljs-keyword">instanceof</span> java.lang.Enum)) &#123;<br>            <span class="hljs-comment">// 调用所指对象的finalize()方法。</span><br>            jla.invokeFinalize(finalizee);<br>            <span class="hljs-comment">// 清除引用，以确保不会被GC错误的遗留。</span><br>            finalizee = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123; &#125;<br>    <span class="hljs-comment">// 清除所指对象与终引用对象（终结者对象）之间的关系，以确保所指对象顺利GC，而在此之前，所指对象不会被回收。</span><br>    <span class="hljs-keyword">super</span>.<span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><br>该方法用于将Finalizer（终结者）类对象从未终结链表中移除，同时还负责执行其所指对象的finalize()方法，并在finalize()方法执行结束后断开与Finalizer（终结者）类对象的连接以令其可被GC回收。关于上述流程存在以下几个主要注意的点：</p><ul><li>finalization（终结）机制只保证finalize()方法一定会调用，但不保证会等待其执行结束。这是目前的主流说法，包括《深入理解Java虚拟机》一书中也是这么描述的。虽然从代码上看，似乎会执行完finalize()方法才会断开所指对象与Finalizer（终结者）类对象之间的关联时期被GC回收。但如果主流说法是正确的话，那关于finalize()方法的具体执行一定还有其它的影响条件。</li><li>finalize()方法只能被执行一次。一个F类对象之所以只能执行一次finalize()方法，是因为其在执行完finalize()方法后会断开其与Finalizer（终结者）类对象的关联。因此，即使在finalize()方法中将F类对象成功复活（即与GC Roots建立上关联），其也不再有Finalizer（终结者）类对象持有它了。一个没有Finalizer（终结者）类对象的F类对象自然是无法执行finalize()方法的。</li><li>F类对象至少要两次GC才能被真正回收。第一次GC将F类对象判定为可回收并执行finalization（终结）机制机制；第二次GC则会将执行完finalize()方法并断开与Finalizer（终结者）类对象关联的F类对象正式回收。而在这两次GC之间也可能存在有多次的GC，因此是至少两次。</li></ul><p>分叉二级终结者<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> forkSecondaryFinalizer(<span class="hljs-keyword">final</span> Runnable proc) &#123;<br>    <span class="hljs-comment">// 建一个二级终结者线程执行自定义操作，并等待其完成。</span><br>    AccessController.doPrivileged(<br>        <span class="hljs-keyword">new</span> PrivilegedAction&lt;<span class="hljs-keyword">Void</span>&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">Void</span> run() &#123;<br>                ThreadGroup tg = Thread.currentThread().getThreadGroup();<br>                <span class="hljs-keyword">for</span> (ThreadGroup tgn = tg;<br>                     tgn != <span class="hljs-keyword">null</span>;<br>                     tg = tgn, tgn = tg.getParent());<br>                <span class="hljs-comment">// 可以看到这是一个常规的线程，因此所谓的二级终结者线程只是名义上的，并不是真正的终结者线程。</span><br>                Thread sft = <span class="hljs-keyword">new</span> Thread(tg, proc, <span class="hljs-string">&quot;Secondary finalizer&quot;</span>);<br>                sft.start();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    阻塞主线程。<br>                    sft.<span class="hljs-keyword">join</span>();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><br>该方法用于创建一个名义上二级终结者线程来执行自定义操作，并等待其完成操作。之所以说是名义上的二级终结者线程，是因为其使用的是常规的Thread（线程）类，而不是Finalizer（终结者）类中定义的FinalizerThread（终结者线程类）类。该方法在类中有两处调用：runFinalization()及runAllFinalizers()。前者的执行操作与正常流程相同，相当于新开了一个线程来进行辅助加速；而后者的执行操作则是上文中提及的直接跳过正常流程中引用队列的步骤从未终结链表中获取Finalizer（终结者）类对象并向下执行。</p><p>执行终结<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runFinalization</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!VM.<span class="hljs-built_in">isBooted</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    forkSecondaryFinalizer(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> running;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>            <span class="hljs-comment">// in case of recursive call to run()</span><br>            <span class="hljs-keyword">if</span> (running)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">final</span> JavaLangAccess jla = SharedSecrets.<span class="hljs-built_in">getJavaLangAccess</span>();<br>            running = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 从引用队列（f-queue）中取出终结者对象，如果引用队列中不存在终结者对象，则直接结束循环并退出线程。因此</span><br>            <span class="hljs-comment">// 可知该方法可有助于加速引用队列及未终结链表中终结者的处理流程。</span><br>                Finalizer f = (Finalizer)queue.<span class="hljs-built_in">poll</span>();<br>                <span class="hljs-comment">// 执行终结者对象的所指对象的finalize()方法。</span><br>                <span class="hljs-keyword">if</span> (f == null) <span class="hljs-keyword">break</span>;<br>                f.<span class="hljs-built_in">runFinalizer</span>(jla);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><br>该方法的代码逻辑与正常流程相同，且会调用forkSecondaryFinalizer()方法创建一个二级终结者线程执行。该方法在Runtime（运行）类中存在调用，而该类与程序运行息息相关，因此猜测该方法应该是程序在某些情况下（例如空间内存不足等）用于加速finalization（终结）机制所用，毕竟…两个线程处理肯定会比一个线程快一些。</p><p>运行全终结者<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runAllFinalizers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!VM.<span class="hljs-built_in">isBooted</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    forkSecondaryFinalizer(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> running;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>            <span class="hljs-comment">// in case of recursive call to run()</span><br>            <span class="hljs-keyword">if</span> (running)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">final</span> JavaLangAccess jla = SharedSecrets.<span class="hljs-built_in">getJavaLangAccess</span>();<br>            running = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-comment">// 直接从未终结链表中获取终结者对象，并将之从未终结链表中移除并执行其所指对象的finalize()方法。当未终结链表</span><br>                <span class="hljs-comment">// 为空时退出循环。该操作不会影响主流程，当主流程从引用队列中获取到终结者对象后，会先判断该终结者对象是否已</span><br>                <span class="hljs-comment">// 经从未终结链表中移除，因此不会导致所指对象的finalize()方法重复调用。</span><br>                Finalizer f;<br>                <span class="hljs-built_in">synchronized</span> (lock) &#123;<br>                    f = unfinalized;<br>                    <span class="hljs-keyword">if</span> (f == null) <span class="hljs-keyword">break</span>;<br>                    unfinalized = f.next;<br>                &#125;<br>                f.<span class="hljs-built_in">runFinalizer</span>(jla);<br>            &#125;&#125;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><br>该方法会跳过正常流程中引用队列的步骤从未终结链表中获取Finalizer（终结者）类对象，且会调用forkSecondaryFinalizer()方法创建一个二级终结者线程执行。该方法在Shutdown（关闭）类中存在调用，而从该类的类名猜测，该方法应该是程序关闭前用于紧急处理剩余Finalizer（终结者）类对象所用，毕竟按照正常流程还需要等待GC判定回收F类回收。而如果在程序关闭前没有处理掉所有的Finalizer（终结者）类对象的话，就有可能导致资源泄露的危险（finalization（终结）机制一般都会用来保证资源回收/释放上）。</p><h2 id="FinalizerThread"><a href="#FinalizerThread" class="headerlink" title="FinalizerThread"></a>FinalizerThread</h2><p>FinalizerThread（终结者线程类）类是Finalizer（终结者）类的一个私有静态内部类，其继承自Thread（线程）类，因此可知其对象为一个线程。</p><p>running（是否运行） —— 该字段用于判断finalization（终结）机制是否已经运行，以避免在递归的情况下重复执行…但从源码中似乎没有发现有递归调用的地方。<br><code>volatile boolean running;</code></p><p>该方法继承自Thread（线程）类，用于定义线程执行的任务。该方法中定义了finalization（终结）机制的正常流程。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果正在运行，则直接返回，这是为了避免在递归的情况下重复执行。</span><br>    <span class="hljs-keyword">if</span> (running)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 终结者线程先于System.initializeSystemClass被调用。等待直到JavaLangAccess可以访问</span><br>    <span class="hljs-keyword">while</span> (!VM.<span class="hljs-built_in">isBooted</span>()) &#123;<br>        <span class="hljs-comment">// delay until VM completes initialization</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            VM.<span class="hljs-built_in">awaitBooted</span>();<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException x) &#123;<br>            <span class="hljs-comment">// ignore and continue</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> JavaLangAccess jla = SharedSecrets.<span class="hljs-built_in">getJavaLangAccess</span>();<br>    <span class="hljs-comment">// 将运行状态设置为true，表示已经开始终结工作。</span><br>    running = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从引用队列中获取终结者对象（remove方法是一个阻塞方法，会一直阻塞到能获取到对象为止）。</span><br>            Finalizer f = (Finalizer)queue.<span class="hljs-built_in">remove</span>();<br>            <span class="hljs-comment">// 执行终结者对象的runFinalizer()方法。</span><br>            f.<span class="hljs-built_in">runFinalizer</span>(jla);<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException x) &#123;<br>            <span class="hljs-comment">// ignore and continue</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当F类对象被创建时，JVM会自动将之作为所指对象创建终结者。终结者类对开发者直接屏蔽，即开发者无法直接创建终结者，JVM会在F类对象创建时自动为之创建终结者以进行终结机制。所谓F类，是指finalize()方法被重写且方法体不为空的类，因此虽然所有的类都存在finalize()方法（因为所有的类都继承自Object（对象）类），但JVM并不会为所有的对象创建终结者，同理也并非所有对象的finalize()方法都会被执行。<br><img src="/img/Reference/5.png" alt="github"><br>实际上，讲述终结者类的使用其实并没有太大意义，因为终结者类不是公共类，无法被其本身所在包外的类访问，故而开发者并无法使用终结者类。</p><h4 id="f-queue"><a href="#f-queue" class="headerlink" title="f-queue"></a>f-queue</h4><p>f-queue的直接作用是承载所有的终结者。终结者类与PhantomReference（虚引用）类一样都必须搭配引用对象使用，而终结者创建时都会固定将f-queue作为其注册引用队列，因此最终所有的终结者都会因为Reference（引用）机制加入f-queue中。f-queue的根本作用有二：一是追踪所指对象/F类对象的GC状态，即判断所指对象/F类对象是否已/会被GC回收，这是引用队列的基本功能，此处不在赘述；二是作为JVM执行终结机制的起点，即JVM会从f-queue中取出终结者以执行其所指对象/F类对象的finalize()方法。</p><h4 id="未终结链表"><a href="#未终结链表" class="headerlink" title="未终结链表"></a>未终结链表</h4><p>未终结链表的作用是建立终结者与GC ROOTS的关联，以确保终结者不会在终结机制期间被GC回收，这与Cleaner（清洁工）类中持有的清洁工链表作用相同。由于终结者由JVM创建，因此初始情况下，如果没有未终结链表，则终结者处于未与GC ROOTS建立直接/间接关联的状态，这就可能出现终结者的所指对象/F类对象尚未执行finalize()方法（更准确的说是终结者加入待定列表前，因为待定链表也是全局静态变量，属于GC ROOTS的范畴，但发现列表不是）就被GC回收的情况，导致部分终结者无法终结。因此为了避免这一点，JVM必须建立所有终结者与GC ROOTS的直接/间接关联，而未终结链表起的就是这个作用。</p><p>终结者会在其创建时默认加入未终结链表，因此所有的终结者初始时都存在于未终结链表中。关于上述内容粗略的说法是：当F类对象创建时，JVM会自动将之作为所指对象调用终结者类的register()方法创建终结者并加入未终结链表中。但实际上，关于终结者的加入时间还能有更精确的描述/调整。众所周知Java对象的创建并非原子操作，大致可以分为实例化（内存分配）与初始化（构造方法执行）两个部分。通过对JVM参数-XX:+RegisterFinalizersAtInit的调整 ，可以设置终结者在F类对象实例化后、初始化前加入，也可以设置其在F类对象初始化后加入。<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> Heap::AddFinalizerReference(Thread* <span class="hljs-built_in">self</span>, ObjPtr&lt;mirror::Object&gt;* <span class="hljs-keyword">object</span>) &#123;<br>    ScopedObjectAccess soa(<span class="hljs-built_in">self</span>);<br>    ScopedLocalRef&lt;jobject&gt; arg(<span class="hljs-built_in">self</span>-&gt;GetJniEnv(), soa.AddLocalReference&lt;jobject&gt;(*<span class="hljs-keyword">object</span>));<br>    jvalue args[<span class="hljs-number">1</span>];<br>    args[<span class="hljs-number">0</span>].l = arg.get();<br>    <span class="hljs-comment">// 调用 Java 层静态方法 FinalizerReference#add</span><br>    InvokeWithJValues(soa, nullptr, WellKnownClasses::java_lang_ref_FinalizerReference_add, args);<br>    *<span class="hljs-keyword">object</span> = soa.Decode&lt;mirror::Object&gt;(arg.get());<br>&#125;<br></code></pre></td></tr></table></figure><br>JVM是如何做到在指定的时间段里调用终结者类的register()方法的呢？这个就要根据不同的情况判断。针对在实例化后、初始化前调用的F类对象，由于内存分配是统一由内存管理系统负责的，因此可以由其负责处理；而对于在初始化后的F类对象则相对复杂，难道要在所有的构造方法尾部都进行处理吗？当然是不可能。实际上JVM使用了一个很灵活的方式，在Java中，子类的构造方法会调用父类的构造方法，因此最终都会执行Object（对象）类的构造方法。JVM将对象类构造方法里的return指令替换为_return_register_finalizer指令，从而在侵入性很小的情况下完成了方法调用。</p><p>将终结者从未终结链表中移除无需遍历。由于未终结链表是双向链表，因此将终结者从未终结链表中移除并不需要遍历，因为终结者自身组合了字段用于保存其在未终结链表中的前驱/后继终结者/节点，因此直接在类锁的保护下将前驱/后继终结者/节点重新链接即可。终结者被移除后，其前驱/后继引用会指向自身，即自引用，作为其已从未终结链表中移除的标志。之所以不使用null作为标志是因为null已经被作为了头/尾终结者/节点的标志，因此可通过判断终结者是否自引用来判断终结者是否已被移除。由于终结者只会在其所指对象/F类对象的finalize()方法执行后才会被JVM从未终结链表中移除，因此其也可以变相作为终结者是否终结的判断依据，而事实上终结者类也确实是这么做的。</p><h4 id="终结者线程"><a href="#终结者线程" class="headerlink" title="终结者线程"></a>终结者线程</h4><p>终结者线程是终结者类自实现内部类FinalizerThread（终结者线程）类的唯一实例，专用于执行终结机制。终结者线程类是Thread（线程）类的子类，因此其实例同样也是一个线程。终结者线程在终结者类的静态块中创建，是一个优先级为8的守护线程，因此整个JVM中只有一条终结者线程。很多资料都会很简略的介绍说终结机制的执行线程的优先级很低，容易造成终结者/F类对象堆积而导致OOM，但实际上这种说法并不准确，因为相对于大量优先级为5的用户线程来说，优先级为8的终结者线程优先级并不算低。导致OOM的原因更多是因为终结者线程只有一条，难以与数量众多的用户线程竞争CPU资源。</p><p>终结者线程用于执行终结机制，简单的说就是不断的将终结者从f-queue及未终结链表中获取/移除终结者，并执行其所指对象/F类对象的finalize()方法，最后断开两者间的引用，以加速两者被GC回收。</p><h4 id="终结机制"><a href="#终结机制" class="headerlink" title="终结机制"></a>终结机制</h4><p>虽然终结机制确实提供了一套关于某些问题的处理方案，但并不推荐去使用它，因为其是非常不稳定的。正是因为终结机制如此的不靠谱，因此其只能在必要的情况下作为保底机制使用，而不能作为处理问题的常规方案。终结机制可能存在的问题如下：</p><ul><li>终结线程的优先级相对较低，finalize()方法的执行速度可能小于终结者/F类对象新增的速度，使得终结者/F类对象累积而导致新生代频繁GC -&gt; 老年代频繁GC -&gt; FULL GC -&gt; OOM；</li><li>如果某个F类对象的finalize()方法执行时间很长，会使得终结者/F类对象累积而导致新生代频繁GC -&gt; 老年代频繁GC -&gt; FULL GC -&gt; OOM；</li><li>JVM/程序运行时，只保证finalize()方法一定会被调用，但不保证会等待其执行结束；</li><li>JVM/程序退出时，无法保证累积的所有F类对象的finalize()方法都被执行，因此可能导致资源泄露。</li></ul><p>终结机制的完整流程如下：</p><ul><li>F类对象创建，JVM自动将之作为所指对象创建终结者。终结者会被默认加入未终结链表，并且终结者作为终引用也会被默认加入发现列表，故而终结者初始会同时存在于发现列表与未终结链表中，此时终结者处于活跃状态；</li><li>F类对象被GC判定为可回收，其终结者被GC线程从发现列表中移除并头插至待定列表（堆栈）中，此时终结者处于待定状态；</li><li>引用处理器线程将终结者从待定列表（堆栈）中移除并头插至f-queue中，此时终结者处于入队状态；</li><li>终结者线程将终结者从f-queue中移除，此时终结者处于怠惰状态；</li><li>终结者线程继续将之从未终结链表中移除，随后执行其所指对象/F类对象的finalize()方法；</li><li>当JVM判断F类对象的finalize()方法执行已/可结束后，终结者线程会断开终结者与其的关联，令两者可便于被GC回收（不是可被回收，即使不断开关联也是可以回收的）。</li></ul><h4 id="辅助终结"><a href="#辅助终结" class="headerlink" title="辅助终结"></a>辅助终结</h4><p>一方面为了避免终结者/F类对象累积过多而导致OOM，另一方面为了在JVM/程序退出时能尽可能保证所有F类对象的finalize()方法都被执行，终结机制存在加速/退出两种辅助终结操作（名字我自己瞎取的），会分别在上述两种情况下执行。虽说命名上有所差异，但实际上两种辅助终结操作的核心是一致的，即创建新的线程参与活动，以加速原本只由终结者线程进行的终结机制的执行效率。但其中需要注意的是：创建的辅助线程并非终结者线程类的实例，只是普通的用户线程，这些线程在名义上被称为二级终结者线程。</p><ul><li>当终结者/F类对象累积过多时，为了避免出现OOM，会触发加速辅助终结操作。</li><li>当JVM/程序退出时，为了尽可能保证所有F类对象的finalize()方法都被执行，会触发退出辅助终结操作。</li><li>F类对象的finalize()方法只能被终结机制执行一次。</li><li>F类对象至少要两次GC才能被真正回收。</li></ul><h4 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h4><p><code>-XX:+RegisterFinalizersAtInit</code>:设置终结者加入未终结链表的时间。为false时在F类对象实例化后、初始化前加入，为true时在F类对象初始化后加入。默认true。</p><h2 id="Cleaner"><a href="#Cleaner" class="headerlink" title="Cleaner"></a>Cleaner</h2><p><strong><em>本文讲述的是JDK8中位于sun.misc包下的Cleaner（清洁工）类（高版本中被迁移至jdk.internal.ref包）。而从JDK9开始，Java在java.lang.ref包下实现了另一个清洁工类，且该类并非PhantomReference（虚引用）类的子类。虽说作用高度相似，但实际上两者却各自发挥着作用，因此请注意区别两者。由于新清洁工类自身携带有一套完整运行流程的缘故，因此目前的主流说法中都将JDK9版本清洁工类的运行流程称之为清洁工机制，故本文中不会出现清洁工机制这个称呼。</em></strong></p><p>洁工类确实实现了与终结机制/finalize()方法相同的功能，即在所指对象被GC回收时执行自定义操作。与常规注册了引用队列的Reference（引用）抽象类对象不同，拿WeakReference（弱引用）类对象举例，如果我们想在其所指对象被GC回收时执行一些操作，首先需要等待引用机制将弱引用置入引用队列中，随后再将之从中取出后或执行弱引用的isEnqueued()方法，因为我们需要通过该操作来判断所指对象是否已/会被GC回收。换句话说就是我们需要先手动的判断所指对象是否已/会被GC回收再去执行自定义操作…这就增加了我们编码的复杂性，但如果使用清洁工的话我们就不需要再做这一步了。<br>清洁工类继承自虚引用类，这意味着其本身也是一个虚引用。当清洁工的所指对象被GC回收时，按照引用机制的统一流程，其会被置入引用队列中。但之前在引用抽象类的文章中已经特意提及过，引用机制在将引用加入引用队列前存在一个特殊判断，即如果引用机制发现引用是一个清洁工，则会执行其内部包含的自定义操作。这意味着我们无需再做手动的判断，甚至于自定义操作都不会发生在用户线程中，引用机制会直接在后台自动处理执行自定义逻辑，从而简化了开发者编码。<br>并且不同于其他子类引用，清洁工类会在完成清洁方法后结束工作，并不会加入到引用队列中。因此它更像是我们在代码外代替Finalizer类。</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p><code>static final ReferenceQueue&lt;Object&gt; dummyQueue = new ReferenceQueue();</code>队列<br>用于填充创建虚引用时必要的引用队列参数，因此所有清洁工的注册引用队列都相同，该参数没有实际作用。</p><p><code>static Cleaner first = null;</code>队列头<br>持有清洁工链表头清洁工的引用。</p><p><code>Cleaner next = null;</code>下一个<br>持有当前清洁工后继清洁工的引用。</p><p><code>Cleaner prev = null;</code>上一个<br>持有当前清洁工前驱清洁工的引用。</p><p><code>final Runnable thunk;</code>线程任务<br>保存当前清洁工需要执行的可运行/任务。</p><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><p><code>Cleaner</code><br>下面方法主要运行了Reference的构造方法，并保存了待运行的任务。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Cleaner</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> var1, Runnable var2</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(var1, dummyQueue);<br>    <span class="hljs-built_in">this</span>.thunk = var2;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>add</code><br>使用头插法来新增数据到清洁工链表中。<br><figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">private static synchronized Cleaner add(Cleaner var0) &#123;<br>    if (<span class="hljs-built_in">first</span> != <span class="hljs-built_in">null</span>) &#123;<br>        var0.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">first</span>;<br>        <span class="hljs-built_in">first</span>.<span class="hljs-built_in">prev</span> = var0;<br>    &#125;<br><br>    <span class="hljs-built_in">first</span> = var0;<br>    return var0;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>remove</code><br>将指定清洁工对象从链表中移除<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> remove(Cleaner var0) &#123;<br>    <span class="hljs-keyword">if</span> (var0.<span class="hljs-keyword">next</span> == var0) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (first == var0) &#123;<br>            <span class="hljs-keyword">if</span> (var0.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>) &#123;<br>                first = var0.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                first = var0.prev;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (var0.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>) &#123;<br>            var0.<span class="hljs-keyword">next</span>.prev = var0.prev;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (var0.prev != <span class="hljs-keyword">null</span>) &#123;<br>            var0.prev.<span class="hljs-keyword">next</span> = var0.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        var0.<span class="hljs-keyword">next</span> = var0;<br>        var0.prev = var0;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>create</code><br>通过所指对象及可运行/任务创建清洁工，创建的清洁工默认处于清洁工链表中<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cleaner <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> var0, Runnable var1</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> var1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : add(<span class="hljs-keyword">new</span> Cleaner(var0, var1));<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>clean</code><br>从链表中移除，并执行可运行/任务。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">clean</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (remove(<span class="hljs-built_in">this</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.thunk.run();<br>        &#125; <span class="hljs-keyword">catch</span> (final Throwable var2) &#123;<br>            AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Void <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                    <span class="hljs-keyword">if</span> (System.err != <span class="hljs-literal">null</span>) &#123;<br>                        (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                    &#125;<br><br>                    System.exit(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>不推荐使用清洁工。说了这么多，结果不让用，感觉有点浪费感情…但是实际上我们确实不推荐使用清洁工，因为其效果会好一些，但基本上终结机制/finalize()方法有的问题它都有。如果真的要说好处，大概就是性能好了些（终结机制/finalize()方法的执行建立在完整的引用机制流程基础上，而清洁工类则直接从中截断，性能自然会好些）和处理速度快了些（引用机制的引用处理器线程为最高优先级10，大于终结机制/finalize()方法的执行线程8的优先级，因此能获得更多的CPU资源）</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/img/Reference/4.png" alt="github"></p><ol><li>发现列表是由GC维护的引用列表，关于他的资料很少，源码中仅有几句描述，目前唯一知道的是发现列表会保存所有引用。发现列表中的引用为活跃状态，由于活跃状态是引用的初始状态，并且初始状态下其必然持有发现列表中的后继引用，因此可知引用在被创建时就被加入发现列表。发现列表中的引用会收到GC的特殊处理。</li><li>GC线程会将发现列表中所指对象已被GC回收的引用移除，并半段其是否注册引用列表。否则直接抛出，变为怠惰状态；是则以头插法将引用加入待定列表。待定列表是引用加入引用队列前的临时存放点，此时引用为待定状态。</li><li>引用处理器线程（唯一）不断循环的待定列表的头部取出引用，如果引用是清洁工则执行自定义操作（清洁工）后抛出，引用变为怠惰状态，这是一个特殊判断；如果不是则将引用以头插法加入各自注册的引用队列中，此时引用为入队状态。</li><li>Java线程从引用队列头部取出引用，以确定引用的所指对象已被GC回收，并以此为契机执行自定义操作，此时引用变为怠惰状态。</li><li>f-queue是由终结者类内部创建的全局唯一引用队列，所有的终结者都会被加入该引用队列中。</li><li>终结者线程会持续将终结者从f-queue头部出队，并将其从未终结链表中移除，随后执行其所指对象的<code>finalize()</code>方法。<code>finalize()</code>方法执行结束后，终结者与其所指对象的才会断开，这与JDK8之前的虚引用很相似，但与其他引用不同。</li><li>当F类对象创建时，JVM会自动将之作为所指对象创建终结者。终结者除发现列表外还会被加入到未终结列表中。未终结列表是一个全局唯一的双向链表，作用是持有终结者的引用以防止被GC回收。</li><li>清洁工除发现列表外还会加入到清洁工链表。清洁工链表是一个全局唯一的双向链表，作用是持有清洁工的引用以防止被GC回收。</li></ol><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在最后，这两个都不建议使用，因为作为处理关闭或析构功能，他的可靠性、效率性都非常低，使用他们更建议使用<code>try-catch-finally</code>来完成。并且他们对异常也相对敏感，需要自行完成。因此我们更建议将这两个功能作为一个保底方案，即最后的安全保障。<br>第二是在使用unsafe来完成jni层面上的内存管理时，来使用cleaner来完成数据的清空工作是一个很好的内存控制方案。因为该内存已经脱离了jvm的控制，因此使用Cleaner来管理。</p>]]></content>
    
    
    <summary type="html">强引用 弱引用 软引用 虚引用</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中Unsafe</title>
    <link href="http://example.com/2023/08/05/UnSafe/"/>
    <id>http://example.com/2023/08/05/UnSafe/</id>
    <published>2023-08-05T08:31:32.000Z</published>
    <updated>2023-08-14T14:01:06.707Z</updated>
    
    <content type="html"><![CDATA[<p>Unsafe是位于sun.misc包下的一个类，提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> <span class="hljs-constructor">Unsafe()</span> &#123;<br>&#125;<br><br>@CallerSensitive<br>public static Unsafe get<span class="hljs-constructor">Unsafe()</span> &#123;<br>    Class var0 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>get<span class="hljs-constructor">CallerClass()</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VM</span>.</span></span>is<span class="hljs-constructor">SystemDomainLoader(<span class="hljs-params">var0</span>.<span class="hljs-params">getClassLoader</span>()</span>)) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">SecurityException(<span class="hljs-string">&quot;Unsafe&quot;</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        return theUnsafe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>注意<code>@CallerSensitive</code>。必须由 启动类classloader加载（如rt.jar ），才可以被识别。 所以rt.jar下面的注解可以正常使用。</p><p>那如若想使用这个类，该如何获取其实例？有如下两个可行方案。</p><ol><li><p>通过Java命令行命令<code>-Xbootclasspath/a</code>把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取Unsafe实例。</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 其中path为调用Unsafe相关方法的类所在jar包路径<br>java -Xbootclasspath/a: <span class="hljs-variable">$&#123;path&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>通过反射获取单例对象theUnsafe。</p><figure class="highlight monkey"><table><tr><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">private</span> static Unsafe getUnsafe() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">Field</span> <span class="hljs-keyword">field</span> = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>      <span class="hljs-keyword">field</span>.setAccessible(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">return</span> (Unsafe) <span class="hljs-keyword">field</span>.get(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(e.getMessage(), e);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类</p><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//分配内存, 相当于C++的malloc函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">allocateMemory</span><span class="hljs-params">(<span class="hljs-keyword">long</span> bytes)</span></span>;<br><br><span class="hljs-comment">//扩充内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">reallocateMemory</span><span class="hljs-params">(<span class="hljs-keyword">long</span> address, <span class="hljs-keyword">long</span> bytes)</span></span>;<br><br><span class="hljs-comment">//释放内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeMemory</span><span class="hljs-params">(<span class="hljs-keyword">long</span> address)</span></span>;<br><br><span class="hljs-comment">//在给定的内存块中设置值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">long</span> bytes, <span class="hljs-keyword">byte</span> value)</span></span>;<br><br><span class="hljs-comment">//内存拷贝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyMemory</span><span class="hljs-params">(Object srcBase, <span class="hljs-keyword">long</span> srcOffset, Object destBase, <span class="hljs-keyword">long</span> destOffset, <span class="hljs-keyword">long</span> bytes)</span></span>;<br><br><span class="hljs-comment">//获取给定地址值，忽略修饰限定符的限制访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function">Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset)</span></span>;<br><br><span class="hljs-comment">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object x)</span></span>;<br><br><span class="hljs-comment">//获取给定地址的byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">byte</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">long</span> address)</span></span>;<br><br><span class="hljs-comment">//为给定地址设置byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putByte</span><span class="hljs-params">(<span class="hljs-keyword">long</span> address, <span class="hljs-keyword">byte</span> x)</span></span>;<br></code></pre></td></tr></table></figure><br>在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。<br>与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</p><h4 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h4><ul><li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模，从而在GC时减少回收停顿对于应用的影响。</li><li>提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li></ul><h4 id="什么情况下使用堆外内存"><a href="#什么情况下使用堆外内存" class="headerlink" title="什么情况下使用堆外内存"></a>什么情况下使用堆外内存</h4><ul><li>堆外内存适用于生命周期中等或较长的对象。</li><li>直接的文件拷贝操作，或者I/O操作。直接使用堆外内存就能少去内存从用户内存拷贝到系统内存的操作，因为I/O操作是系统内核内存和设备间的通信，而不是通过程序直接和外设通信的。</li><li>可以使用 池+堆外内存 的组合方式，来对生命周期较短，但涉及到I/O操作的对象进行堆外内存的再使用。</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，我们可以通过该类实现堆外内存的创建、使用和销毁。<br>DirectByteBuffer该类本身还是位于Java内存模型的堆中。堆内内存是JVM可以直接管控、操纵。<br>而DirectByteBuffer中的unsafe.allocateMemory(size);是个一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配的。分配的内存是系统本地的内存，并不在Java的内存中，也不属于JVM管控范围，所以在DirectByteBuffer一定会存在某种方式来操纵堆外内存。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">DirectByteBuffer(<span class="hljs-params">int</span> <span class="hljs-params">cap</span>)</span> &#123;                   <span class="hljs-comment">// package-private</span><br><br>    super(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    boolean pa = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VM</span>.</span></span>is<span class="hljs-constructor">DirectMemoryPageAligned()</span>;<br>    <span class="hljs-built_in">int</span> ps = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bits</span>.</span></span>page<span class="hljs-constructor">Size()</span>;<br>    long size = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(<span class="hljs-number">1L</span>, (long)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bits</span>.</span></span>reserve<span class="hljs-constructor">Memory(<span class="hljs-params">size</span>, <span class="hljs-params">cap</span>)</span>;<br><br>    long base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 分配内存，返回地址</span><br>        base = unsafe.allocate<span class="hljs-constructor">Memory(<span class="hljs-params">size</span>)</span>;<br>    &#125; catch (OutOfMemoryError x) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bits</span>.</span></span>unreserve<span class="hljs-constructor">Memory(<span class="hljs-params">size</span>, <span class="hljs-params">cap</span>)</span>;<br>        throw x;<br>    &#125;<br>    <span class="hljs-comment">// 内存初始化</span><br>    unsafe.set<span class="hljs-constructor">Memory(<span class="hljs-params">base</span>, <span class="hljs-params">size</span>, (<span class="hljs-params">byte</span>)</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa<span class="hljs-operator"> &amp;&amp; </span>(base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    <span class="hljs-comment">// 跟踪DirectByteBuffer对象的垃圾回收，以实现堆外内存释放</span><br>    cleaner = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cleaner</span>.</span></span>create(this, <span class="hljs-keyword">new</span> <span class="hljs-constructor">Deallocator(<span class="hljs-params">base</span>, <span class="hljs-params">size</span>, <span class="hljs-params">cap</span>)</span>);<br>    att = null;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为DirectByteBuffer是通过虚引用(Phantom Reference)来实现堆外内存的释放的。<br>PhantomReference 是所有“弱引用”中最弱的引用类型。不同于软引用和弱引用，虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。</p><p>Cleaner继承自Java四大引用类型之一的虚引用PhantomReference。其实虚引用主要被用来 跟踪对象被垃圾回收的状态，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否 即将被垃圾回收，从而采取行动。它并不被期待用来取得目标对象的引用，而目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。<br><img src="/img/Unsafe/0.png" alt="github"><br>当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。</p><p>DirectByteBuffer类：当调用守护线程清空逻辑时调用此<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deallocator</span></span><br><span class="hljs-class">    <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class">&#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe unsafe = Unsafe.<span class="hljs-built_in">getUnsafe</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> address;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Deallocator</span><span class="hljs-params">(<span class="hljs-keyword">long</span> address, <span class="hljs-keyword">long</span> size, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span> (address != <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>.address = address;<br>        <span class="hljs-keyword">this</span>.size = size;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Paranoia</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 释放内存</span><br>        unsafe.<span class="hljs-built_in">freeMemory</span>(address);<br>        address = <span class="hljs-number">0</span>;<br>        Bits.<span class="hljs-built_in">unreserveMemory</span>(size, capacity);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>Reference类：制定了守护线程中的清空逻辑<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">boolean</span> tryHandlePending(<span class="hljs-keyword">boolean</span> waitForNotify) &#123;<br>    Reference&lt;<span class="hljs-keyword">Object</span>&gt; r;<br>    Cleaner c;<br>    <span class="hljs-keyword">try</span> &#123;<br>        synchronized (lock) &#123;<br>            <span class="hljs-keyword">if</span> (pending != <span class="hljs-literal">null</span>) &#123;<br>                r = pending;<br>                <span class="hljs-comment">// &#x27;instanceof&#x27; might throw OutOfMemoryError sometimes</span><br>                <span class="hljs-comment">// so do this before un-linking &#x27;r&#x27; from the &#x27;pending&#x27; chain...</span><br>                c = r <span class="hljs-keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// unlink &#x27;r&#x27; from &#x27;pending&#x27; chain</span><br>                pending = r.discovered;<br>                r.discovered = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// The waiting on the lock may cause an OutOfMemoryError</span><br>                <span class="hljs-comment">// because it may try to allocate exception objects.</span><br>                <span class="hljs-keyword">if</span> (waitForNotify) &#123;<br>                    lock.wait();<br>                &#125;<br>                <span class="hljs-comment">// retry if waited</span><br>                <span class="hljs-keyword">return</span> waitForNotify;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        <span class="hljs-comment">// Give other threads CPU time so they hopefully drop some live references</span><br>        <span class="hljs-comment">// and GC reclaims some space.</span><br>        <span class="hljs-comment">// Also prevent CPU intensive spinning in case &#x27;r instanceof Cleaner&#x27; above</span><br>        <span class="hljs-comment">// persistently throws OOME for some time...</span><br>        Thread.<span class="hljs-keyword">yield</span>();<br>        <span class="hljs-comment">// retry</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>        <span class="hljs-comment">// retry</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Fast path for cleaners</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>        c.clean();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ReferenceQueue<span class="hljs-meta">&lt;?</span> super <span class="hljs-keyword">Object</span>&gt; q = r.queue;<br>    <span class="hljs-keyword">if</span> (q != ReferenceQueue.<span class="hljs-literal">NULL</span>) q.enqueue(r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h2><p>如下源代码释义所示，这部分主要为CAS相关操作的方法。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    *  CAS</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> o         包含要修改field的对象</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> offset    对象中某field的偏移量</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> expected  期望值</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> update    更新值</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span>          true | false</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,  Object expected, Object update)</span></span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> update)</span></span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">long</span> expected, <span class="hljs-keyword">long</span> update)</span></span>;<br></code></pre></td></tr></table></figure><br>CAS，比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。<br>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。<br><figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">long</span> valueOffset;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 返回对象成员属性在内存地址相对于此对象的内存地址的偏移量</span><br>        valueOffset = unsafe.objectFieldOffset<br>            (AtomicInteger.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br></code></pre></td></tr></table></figure><br>下面是AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=”0x110000”，通过baseAddress+valueOffset得到value的内存地址valueAddress=”0x11000c”；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。<br><img src="/img/Unsafe/1.png" alt="github"></p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>这部分，包括线程挂起、恢复、锁机制等方法。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//取消阻塞线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Object thread)</span></span>;<br><span class="hljs-comment">//阻塞线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAbsolute, <span class="hljs-keyword">long</span> time)</span></span>;<br><span class="hljs-comment">//获得对象锁（可重入锁）</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitorEnter</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-comment">//释放对象锁</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitorExit</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-comment">//尝试获取对象锁</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryMonitorEnter</span><span class="hljs-params">(Object o)</span></span>;<br></code></pre></td></tr></table></figure><br>方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。</p><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>Java锁和同步器框架的核心类<code>AbstractQueuedSynchronizer</code>，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p><h2 id="Class相关"><a href="#Class相关" class="headerlink" title="Class相关"></a>Class相关</h2><p>此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> staticFieldOffset(Field f);<br><span class="hljs-comment">//获取一个静态类中给定字段的对象指针</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object staticFieldBase(Field f);<br><span class="hljs-comment">//判断是否需要初始化一个类，通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。 此方法当且仅当ensureClassInitialized方法不生效的时候才返回false。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> shouldBeInitialized(<span class="hljs-keyword">Class</span>&lt;?&gt; c);<br><span class="hljs-comment">//检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> ensureClassInitialized(<span class="hljs-keyword">Class</span>&lt;?&gt; c);<br><span class="hljs-comment">//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例来源于调用者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">Class</span>&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len, ClassLoader loader, ProtectionDomain protectionDomain);<br><span class="hljs-comment">//定义一个匿名类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">Class</span>&lt;?&gt; defineAnonymousClass(<span class="hljs-keyword">Class</span>&lt;?&gt; hostClass, <span class="hljs-keyword">byte</span>[] data, Object[] cpPatches);<br></code></pre></td></tr></table></figure></p><h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。</p><ul><li>invokedynamic： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。</li><li>VM Anonymous Class：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。</li></ul><p>在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。</p><p>下面以如下图所示的Test类来举例说明。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><br>    <span class="hljs-keyword">final</span> Consumer consumer = s -&gt; System.out.<span class="hljs-built_in">println</span>(s);<br>    consumer.<span class="hljs-built_in">accept</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>Test类编译后的class文件反编译后的结果如下<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> class version <span class="hljs-number">52.0</span> (<span class="hljs-number">52</span>)<br><span class="hljs-regexp">//</span> access flags <span class="hljs-number">0</span>x21<br>public class com/Test12 &#123;<br><br>  <span class="hljs-regexp">//</span> compiled from: Test12.java<br>  <span class="hljs-regexp">//</span> access flags <span class="hljs-number">0</span>x19<br>  public final static INNERCLASS java<span class="hljs-regexp">/lang/i</span>nvoke<span class="hljs-regexp">/MethodHandles$Lookup java/</span>lang<span class="hljs-regexp">/invoke/</span>MethodHandles Lookup<br><br>  <span class="hljs-regexp">//</span> access flags <span class="hljs-number">0</span>x1<br>  public &lt;init&gt;()V<br>   L0<br>    LINENUMBER <span class="hljs-number">5</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKESPECIAL java<span class="hljs-regexp">/lang/</span>Object.&lt;init&gt; ()V<br>    RETURN<br>   L1<br>    LOCALVARIABLE this Lcom/Test12; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-regexp">//</span> access flags <span class="hljs-number">0</span>x9<br>  public static main([Ljava<span class="hljs-regexp">/lang/</span>String;)V<br>   L0<br>    LINENUMBER <span class="hljs-number">7</span> L0<br>    INVOKEDYNAMIC accept()Ljava<span class="hljs-regexp">/util/</span><span class="hljs-keyword">function</span>/Consumer; [<br>      <span class="hljs-regexp">//</span> handle kind <span class="hljs-number">0</span>x6 : INVOKESTATIC<br>      java<span class="hljs-regexp">/lang/i</span>nvoke<span class="hljs-regexp">/LambdaMetafactory.metafactory(Ljava/</span>lang<span class="hljs-regexp">/invoke/</span>MethodHandles<span class="hljs-variable">$Lookup</span>;Ljava<span class="hljs-regexp">/lang/</span>String;Ljava<span class="hljs-regexp">/lang/i</span>nvoke<span class="hljs-regexp">/MethodType;Ljava/</span>lang<span class="hljs-regexp">/invoke/</span>MethodType;Ljava<span class="hljs-regexp">/lang/i</span>nvoke<span class="hljs-regexp">/MethodHandle;Ljava/</span>lang<span class="hljs-regexp">/invoke/</span>MethodType;)Ljava<span class="hljs-regexp">/lang/i</span>nvoke/CallSite;<br>      <span class="hljs-regexp">//</span> arguments:<br>      (Ljava<span class="hljs-regexp">/lang/</span>Object;)V, <br>      <span class="hljs-regexp">//</span> handle kind <span class="hljs-number">0</span>x6 : INVOKESTATIC<br>      com<span class="hljs-regexp">/Test12.lambda$main$0(Ljava/</span>lang/Object;)V, <br>      (Ljava<span class="hljs-regexp">/lang/</span>Object;)V<br>    ]<br>    ASTORE <span class="hljs-number">1</span><br>   L1<br>    LINENUMBER <span class="hljs-number">8</span> L1<br>    ALOAD <span class="hljs-number">1</span><br>    LDC <span class="hljs-string">&quot;aaa&quot;</span><br>    INVOKEINTERFACE java<span class="hljs-regexp">/util/</span><span class="hljs-keyword">function</span><span class="hljs-regexp">/Consumer.accept (Ljava/</span>lang/Object;)V (itf)<br>   L2<br>    LINENUMBER <span class="hljs-number">9</span> L2<br>    RETURN<br>   L3<br>    LOCALVARIABLE args [Ljava<span class="hljs-regexp">/lang/</span>String; L0 L3 <span class="hljs-number">0</span><br>    LOCALVARIABLE consumer Ljava<span class="hljs-regexp">/util/</span><span class="hljs-keyword">function</span>/Consumer; L1 L3 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-regexp">//</span> access flags <span class="hljs-number">0</span>x100A<br>  private static synthetic lambda<span class="hljs-variable">$main</span><span class="hljs-variable">$0</span>(Ljava<span class="hljs-regexp">/lang/</span>Object;)V<br>   L0<br>    LINENUMBER <span class="hljs-number">7</span> L0<br>    GETSTATIC java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKEVIRTUAL java<span class="hljs-regexp">/io/</span>PrintStream.println (Ljava<span class="hljs-regexp">/lang/</span>Object;)V<br>    RETURN<br>   L1<br>    LOCALVARIABLE s Ljava<span class="hljs-regexp">/lang/</span>Object; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><br>可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法<code>lambda$main$0</code>等。<br>引导方法执行过程中，会通过<code>Unsafe.defineAnonymousClass</code>生成下面所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法<code>lambda$main$0</code>来实现Lambda表达式中定义的逻辑。而后执行语<code>句consumer.accept（&quot;aaa&quot;）</code>其实就是调用下面所示的匿名类的accept方法。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Test</span>$$<span class="hljs-symbol">Lambda</span>$<span class="hljs-symbol">1</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Consumer</span> &#123;<br>    <span class="hljs-keyword">private</span> Test$$Lambda$<span class="hljs-number">1</span> () &#123;&#125;<br>    <br>    @Hidden<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> accept(Object v) &#123;<br>        Test.lambda$main$<span class="hljs-number">0</span>((String)v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><p>此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> objectFieldOffset(Field f);<br><span class="hljs-comment">//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">Object</span> getObject(<span class="hljs-keyword">Object</span> o, <span class="hljs-keyword">long</span> offset);<br><span class="hljs-comment">//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> putObject(<span class="hljs-keyword">Object</span> o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">Object</span> x);<br><span class="hljs-comment">//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">Object</span> getObjectVolatile(<span class="hljs-keyword">Object</span> o, <span class="hljs-keyword">long</span> offset);<br><span class="hljs-comment">//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> putObjectVolatile(<span class="hljs-keyword">Object</span> o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">Object</span> x);<br><span class="hljs-comment">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> putOrderedObject(<span class="hljs-keyword">Object</span> o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">Object</span> x);<br><span class="hljs-comment">//绕过构造方法、初始化代码来创建对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">Object</span> allocateInstance(Class&lt;?&gt; cls) <span class="hljs-keyword">throws</span> InstantiationException;<br></code></pre></td></tr></table></figure></p><h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><ul><li>常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li><li>非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li></ul><p>如下所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorConstructor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-built_in">Map</span>&lt;Type, InstanceCreator&lt;?&gt;&gt; instanceCreators;<br>    <span class="hljs-keyword">private</span> final ReflectionAccessor accessor = ReflectionAccessor.getInstance();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">ConstructorConstructor</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;Type, InstanceCreator&lt;?&gt;&gt; instanceCreators</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.instanceCreators = instanceCreators;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; ObjectConstructor&lt;T&gt; <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">TypeToken&lt;T&gt; typeToken</span>)</span> &#123;<br>        final Type <span class="hljs-keyword">type</span> = typeToken.getType();<br>        Class&lt;? <span class="hljs-built_in">super</span> T&gt; rawType = typeToken.getRawType();<br>        final InstanceCreator&lt;T&gt; typeCreator = (InstanceCreator)<span class="hljs-built_in">this</span>.instanceCreators.get(<span class="hljs-keyword">type</span>);<br>        <span class="hljs-keyword">if</span> (typeCreator != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjectConstructor&lt;T&gt;() &#123;<br>                <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">construct</span>(<span class="hljs-params"></span>)</span> &#123;<br>                    <span class="hljs-keyword">return</span> typeCreator.createInstance(<span class="hljs-keyword">type</span>);<br>                &#125;<br>            &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            final InstanceCreator&lt;T&gt; rawTypeCreator = (InstanceCreator)<span class="hljs-built_in">this</span>.instanceCreators.get(rawType);<br>            <span class="hljs-keyword">if</span> (rawTypeCreator != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjectConstructor&lt;T&gt;() &#123;<br>                    <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">construct</span>(<span class="hljs-params"></span>)</span> &#123;<br>                        <span class="hljs-keyword">return</span> rawTypeCreator.createInstance(<span class="hljs-keyword">type</span>);<br>                    &#125;<br>                &#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ObjectConstructor&lt;T&gt; defaultConstructor = <span class="hljs-built_in">this</span>.newDefaultConstructor(rawType);<br>                <span class="hljs-keyword">if</span> (defaultConstructor != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> defaultConstructor;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ObjectConstructor&lt;T&gt; defaultImplementation = <span class="hljs-built_in">this</span>.newDefaultImplementationConstructor(<span class="hljs-keyword">type</span>, rawType);<br>                    <span class="hljs-comment">// 最终调用该函数创建 newUnsafeAllocator</span><br>                    <span class="hljs-keyword">return</span> defaultImplementation != <span class="hljs-literal">null</span> ? defaultImplementation : <span class="hljs-built_in">this</span>.newUnsafeAllocator(<span class="hljs-keyword">type</span>, rawType);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> &lt;T&gt; ObjectConstructor&lt;T&gt; <span class="hljs-function"><span class="hljs-title">newUnsafeAllocator</span>(<span class="hljs-params">final Type <span class="hljs-keyword">type</span>, final Class&lt;? <span class="hljs-built_in">super</span> T&gt; rawType</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjectConstructor&lt;T&gt;() &#123;<br>            <span class="hljs-comment">// 核心方法调用此处创建</span><br>            <span class="hljs-keyword">private</span> final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();<br><br>            <span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">construct</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">Object</span> newInstance = <span class="hljs-built_in">this</span>.unsafeAllocator.newInstance(rawType);<br>                    <span class="hljs-keyword">return</span> newInstance;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception var2) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to invoke no-args constructor for &quot;</span> + <span class="hljs-keyword">type</span> + <span class="hljs-string">&quot;. Registering an InstanceCreator with Gson for this type may fix this problem.&quot;</span>, var2);<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UnsafeAllocator <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class&lt;?&gt; unsafeClass = Class.forName(<span class="hljs-string">&quot;sun.misc.Unsafe&quot;</span>);<br>        Field f = unsafeClass.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        final <span class="hljs-built_in">Object</span> unsafe = f.get((<span class="hljs-built_in">Object</span>)<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 核心调用该方法</span><br>        final Method allocateInstance = unsafeClass.getMethod(<span class="hljs-string">&quot;allocateInstance&quot;</span>, Class.class);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">UnsafeAllocator</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">public</span> &lt;T&gt; T newInstance(Class&lt;T&gt; c) throws Exception &#123;<br>                assertInstantiable(c);<br>                <span class="hljs-keyword">return</span> allocateInstance.invoke(unsafe, c);<br>            &#125;<br>        &#125;;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h2><p>这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//返回数组中第一个元素的偏移地址</span><br><span class="hljs-keyword">public</span> native <span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span>BaseOffset(Class&lt;?&gt; <span class="hljs-built_in">array</span>Class);<br><span class="hljs-comment">//返回数组中一个元素占用的大小</span><br><span class="hljs-keyword">public</span> native <span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span>IndexScale(Class&lt;?&gt; <span class="hljs-built_in">array</span>Class);<br></code></pre></td></tr></table></figure></p><h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。<br><figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2862133569453604235</span>L;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br>    <span class="hljs-comment">// 获取数组元素的首地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> base = unsafe.arrayBaseOffset(<span class="hljs-keyword">int</span>[].<span class="hljs-keyword">class</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> shift;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] <span class="hljs-keyword">array</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 获取每个元素所占大小</span><br>        <span class="hljs-keyword">int</span> scale = unsafe.arrayIndexScale(<span class="hljs-keyword">int</span>[].<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">if</span> ((scale &amp; (scale - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;data type scale not a power of two&quot;</span>);<br>        shift = <span class="hljs-number">31</span> - Integer.numberOfLeadingZeros(scale);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> checkedByteOffset(<span class="hljs-keyword">int</span> i) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-keyword">array</span>.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;index &quot;</span> + i);<br><br>        <span class="hljs-keyword">return</span> byteOffset(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过数据数组的位置计算偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> byteOffset(<span class="hljs-keyword">int</span> i) &#123;<br>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span>) i &lt;&lt; shift) + base;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p><p>后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(i, <span class="hljs-number">-1</span>)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Atomically adds the given value to the element at index &#123;<span class="hljs-doctag">@code</span> i&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i the index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delta the value to add</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> delta)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadFence</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">storeFence</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//内存屏障，禁止load、store操作重排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fullFence</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></p><h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><p>在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> x, y;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock sl = <span class="hljs-keyword">new</span> StampedLock();<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">double</span> deltaX, <span class="hljs-keyword">double</span> deltaY)</span> </span>&#123; <span class="hljs-comment">// an exclusively locked method</span><br>     <span class="hljs-keyword">long</span> stamp = sl.writeLock();<br>     <span class="hljs-keyword">try</span> &#123;<br>       x += deltaX;<br>       y += deltaY;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       sl.unlockWrite(stamp);<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distanceFromOrigin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// A read-only method</span><br>     <span class="hljs-keyword">long</span> stamp = sl.tryOptimisticRead();<br>     <span class="hljs-keyword">double</span> currentX = x, currentY = y;<br>     <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123;<br>        stamp = sl.readLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>          currentX = x;<br>          currentY = y;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           sl.unlockRead(stamp);<br>        &#125;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">return</span> Math.<span class="hljs-title">sqrt</span><span class="hljs-params">(currentX * currentX + currentY * currentY)</span></span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveIfAtOrigin</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newX, <span class="hljs-keyword">double</span> newY)</span> </span>&#123; <span class="hljs-comment">// upgrade</span><br>     <span class="hljs-comment">// Could instead start with optimistic, not read mode</span><br>     <span class="hljs-keyword">long</span> stamp = sl.readLock();<br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">while</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>) &#123;<br>         <span class="hljs-keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);<br>         <span class="hljs-keyword">if</span> (ws != <span class="hljs-number">0</span>L) &#123;<br>           stamp = ws;<br>           x = newX;<br>           y = newY;<br>           <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>           sl.unlockRead(stamp);<br>           stamp = sl.writeLock();<br>         &#125;<br>       &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       sl.unlock(stamp);<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br><img src="/img/Unsafe/2.png" alt="github"><br>如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。<br>StampedLock.validate方法的源码实现则是使用load方法实现内存屏障。</p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p>这部分包含两个获取系统相关信息的方法。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//返回系统指针的大小。返回值为4（32位系统）或8（64位系统）。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addressSize</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-comment">//内存页的大小，此值为2的幂次方。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pageSize</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></p><h4 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h4><p>如下所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">pageSize</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (pageSize == <span class="hljs-number">-1</span>) &#123;<br>        pageSize = <span class="hljs-keyword">unsafe</span>().pageSize();<br>    &#125;<br>    <span class="hljs-keyword">return</span> pageSize;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java中Unsafe</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://example.com/2023/07/31/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2023/07/31/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2023-07-31T20:11:01.000Z</published>
    <updated>2023-08-07T08:44:19.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>历史上，红黑树是AVL树的一个变种。对红黑树的操作在最坏情况下花费<code>O(long N)</code>时间，并且可以看到（对于插入操作的）一种审慎的非递归实现可以相对容易的完成（与AVL数相比）。</p><h2 id="红黑树规则特点"><a href="#红黑树规则特点" class="headerlink" title="红黑树规则特点"></a>红黑树规则特点</h2><ol><li>每一个节点为红色，或者黑色。</li><li>根是黑色的。</li><li>如果一个节点是攻色那么子节点必是黑色。</li><li>从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点。</li></ol><p>着色法则的一个结论是，红黑树的高度最多是<code>2log(N+1)</code>。因此，查找操作保证是一种对数的操作。</p><p>困难在于将一个新项插入到树中。通常把新项作为树叶放到树中。如果将它涂成黑色那么会违反条件4，因为将会建立一条更长的黑节点路径。因此这一项必须涂成红色。<br>如果他的父节点是黑色的，则插入完成。如果他的父节点是红色的，那么得到了连续的红色节点，这就违反了条件3。<br>此时我们必须要调整该树。用于完成这项任务的基本操作是颜色的改变和树旋转。</p><h2 id="自底向上的插入"><a href="#自底向上的插入" class="headerlink" title="自底向上的插入"></a>自底向上的插入</h2><p>如果新插入的项的父节点是黑色的，那么插入完成。因此将25插入到图中的树中是简单的操作。<br><img src="/img/RedBlackTree/0.png" alt="github"></p><p>如果父节点是红色的，那么有几种情况（每种都有一个镜像对称）需要考虑。<br>首先，假设这个父节点的兄弟是褐色的（我们采纳规定：null节点都是黑色的）。<br>这对于插入3或8是适用的，但对插入99不适用。令X是新添加的树叶，P是他的父节点，S是父节点的兄弟（若存在），G是祖父节点。<br>在这种情形只有X和P是红色的，G是黑色的，否则就会在插入前有两个相连的红色节点，违反规则。<br>采用伸展树的术语，X、P和G可以形成一个一字形链或之字形链（两个方向中的任意个方向）。</p><p>下图指出P是一个左儿子时我们应该如何旋转该树。即使X是一片树叶，我们还是画出较一般的情形，使得X在树的中间。后面我们将用到这个较一般的旋转。<br><img src="/img/RedBlackTree/1.png" alt="github"><br>如果S是黑色，则单旋转和之字形旋转有效</p><p>第一种情形对应P和G之间的单旋转，而第二种情形对应双旋转，该双旋转首先在X和P之间进行，然后在X和G之间进行。当编写程序时，必须记录父节点、祖父节点，以及为了重新连接还要记录曾祖节点。<br>在这两种情形下，子树的新根均被涂为黑色，因此，即使原来的曾祖时红色，我们也排除了两个相邻红色节点的可能性。同样重要的是，这些旋转的结果是通过A，B和C诸路径上的黑色节点个数保持不变。</p><h2 id="自顶向下的红黑树"><a href="#自顶向下的红黑树" class="headerlink" title="自顶向下的红黑树"></a>自顶向下的红黑树</h2><p>上面的实现需要用到一个栈或用一些父链保存路径。我们看到，如果使用一个自顶向下的过程，则伸展树会更有效，事实上我们可以对红黑树应用自顶向下的过程而保证S不会是红色的。<br>这个过程在概念上非常容易。在向下的过程中功能当看到一个节点X有两个红儿子的时候，可使X呈红色而他的两个儿子是黑色的。（如果X是根，则在颜色旋转后他将是红色的，但是为恢复性质2可以直接着成黑色）<br>下图显示这种颜色反转的现象，只有当X的父节点P也是红色的时候这种反转将破坏红黑的法则。<br><img src="/img/RedBlackTree/2.png" alt="github"><br><strong>颜色翻转：只有当X的父节点是红色的时候我们才能继续旋转。</strong><br><img src="/img/RedBlackTree/4.png" alt="github"><br>此时可以进行适当的旋转。如果X的父节点的兄弟是红色会怎样，这周可能已经被从顶向下过程中的行动所排出，因此X的父节点的兄弟不可能是红色。特别的，如果在延树向下的过程中我们看到一个节点Y有两个红儿子，那么我们知道Y的孙子必然是黑的，由于Y的儿子也要变成黑的，升职在可能发生的旋转之后，因此我们将不会看到两层上另外的红节点。这样我们看到X，若X的父节点是红色的，则X的父节点的兄弟不可能也是红色的。</p><p>例如，假设要将45插入到下面的树中。在延树向下的过程中，我们看到50有两个红儿子。因此我们执行一次颜色翻转，使50位红的，40和55为黑的。<br>现在50和60都是红的，在60和70之间执行单旋转，使得60时30的右子树的黑根，而70和50都是红的。<br>如果我们在路径上看到另外的含有两个红儿子的节点，那么我们继续执行统一的操作。当我们达到树叶时，把45作为红节点插入，由于父节点使黑的，因此插入完成得到最后的结果。<br><img src="/img/RedBlackTree/3.png" alt="github"><br>最后得到了平衡的红黑树。红黑树的优点是执行插入所需要的开销相对较低，另外就是实践中发生的旋转相对较少。（相较于AVL树）</p><p>红黑树的具体实现时很复杂的，这不仅因为有大量可能的旋转，而且还因为一些子树可能是空的，以及处理根的特殊的情况（尤其是根没有父亲）。<br>因此，我们使用两个标记节点：一个是根，一个是NulNode，他的作用像在伸展树中那样指示一个null引用。根标记将存储关键字∞和一个只想真正的根的右链。<br>为此，查找和输出过程均需要调整。递归的历程都很巧妙。下面代码中指出如何重新编写中序遍历<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public void print<span class="hljs-constructor">Tree()</span> &#123;<br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Empty()</span>)<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;empty tree&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        print<span class="hljs-constructor">Tree(<span class="hljs-params">header</span>.<span class="hljs-params">right</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void print<span class="hljs-constructor">Tree(RedBlackNode&lt;AnyType&gt; <span class="hljs-params">t</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (t != nullNode) &#123;<br>        print<span class="hljs-constructor">Tree(<span class="hljs-params">t</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(t.element);<br>        print<span class="hljs-constructor">Tree(<span class="hljs-params">t</span>.<span class="hljs-params">right</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>下面代码显示RedBlackTree架构（省去了其中的一些成员方法）以及构造方法。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">RedBlackTree</span>&lt;<span class="hljs-symbol">AnyType</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Comparable</span>&lt;? <span class="hljs-symbol">super</span> <span class="hljs-symbol">AnyType</span>&gt;&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> RedBlackNode&lt;AnyType&gt; header;<br>    <span class="hljs-keyword">private</span> RedBlackNode&lt;AnyType&gt; <span class="hljs-literal">null</span>Node;<br>    <br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> BLACK = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> RED = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> RedBlackTree() &#123;<br>        <span class="hljs-literal">null</span>Node = new RedBlackTree&lt;AnyType&gt;(<span class="hljs-literal">null</span>);<br>        <span class="hljs-literal">null</span>Node.left = <span class="hljs-literal">null</span>Node.right = <span class="hljs-literal">null</span>Node;<br>        header = new RedBlackTree&lt;AnyType&gt;(<span class="hljs-literal">null</span>);<br>        header.left = header.right = <span class="hljs-literal">null</span>Node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> <span class="hljs-symbol">RedBlackNode</span>&lt;<span class="hljs-symbol">AnyType</span>&gt; &#123;<br>        <span class="hljs-comment">// 数值</span><br>        AnyType element;<br>        <span class="hljs-comment">// 左节点</span><br>        RedBlackNode&lt;AnyType&gt; left;<br>        <span class="hljs-comment">// 右节点</span><br>        RedBlackNode&lt;AnyType&gt; right;<br>        <span class="hljs-comment">// 颜色</span><br>        <span class="hljs-built_in">int</span> color;<br>    <br>        RedBlackNode(AnyType theElement) &#123;<br>            <span class="hljs-keyword">this</span>(theElement, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>    <br>        RedBlackNode(AnyType theElement, RedBlackNode&lt;AnyType&gt; lt, RedBlackNode&lt;AnyType&gt; rg) &#123;<br>            element = theElement; left = lt; right = rt; color = RedBlackTree.BLACK;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>下面则显示执行一次单旋转的例子，因为所得到的数必须要附接到一个父节点上，所以rotate把父节点作为一个参数。我们把item作为一个参数传递而不是在延树下行时记录旋转的类型。<br>由于期望在插入过程中进行很少的旋转，因此使用这个这种方式实际上不仅更简单，而且还更快。rotate直接返回执行一次适当的单旋转的结果。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> RedBlackNode&lt;AnyType&gt; rotate(AnyType item, RedBlackNode&lt;AnyType&gt; parent) &#123;<br>    <span class="hljs-keyword">if</span> (compare(item, parent) &lt; <span class="hljs-number">0</span>) <br>        return parent.left = compare(item, parent.left) &lt; <span class="hljs-number">0</span> ?<br>            rotate<span class="hljs-constructor">WithLeftChild(<span class="hljs-params">parent</span>.<span class="hljs-params">left</span>)</span> : <br>            rotate<span class="hljs-constructor">WithRightChild(<span class="hljs-params">parent</span>.<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-keyword">else</span><br>        return parent.right = compare(item, parent.right) &lt; <span class="hljs-number">0</span> ?<br>            rotate<span class="hljs-constructor">WithLeftChild(<span class="hljs-params">parent</span>.<span class="hljs-params">right</span>)</span> : <br>            rotate<span class="hljs-constructor">WithRightChild(<span class="hljs-params">parent</span>.<span class="hljs-params">right</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> final <span class="hljs-built_in">int</span> compare(AnyType item, RedBlackNode&lt;AnyType&gt; t) &#123;<br>    <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>header)<br>        return <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        return item.compare<span class="hljs-constructor">To(<span class="hljs-params">t</span>.<span class="hljs-params">element</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>下面则给出了插入过程。handleReorient当我们遇到带有两个红儿子的节点时被调用，在我们插入一片树叶时他也被调用。最为复杂的部分时，一个双旋转实际上是两个单旋转，而且只有当通向X的分值（在insert方法中由current表示）去相反方向时才进行。正如我们在较早的讨论中提到的，当延树向下进行的时候，insert必须记录父亲、祖父和曾祖。<br>由于这些量要由handleReorient共享，因此让他们时类成员。<br>注意，在一次旋转之后，存储在祖父和饿曾祖父节点中的值将不再正确。不会肯定到下一次在需要他们的时候他将被修复。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; current;<br><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; parent;<br><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; grand;<br><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; great;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> handleReorient(AnyType item) &#123;<br>    current.<span class="hljs-built_in">color</span> = RED;<br>    current.left.<span class="hljs-built_in">color</span> = BLACK;<br>    current.right.<span class="hljs-built_in">color</span> = BLACK;<br>    <span class="hljs-keyword">if</span> (parent.<span class="hljs-built_in">color</span> == RED) &#123;<br>        grand.<span class="hljs-built_in">color</span> = RED;<br>        <span class="hljs-comment">// 双旋转中的单旋转</span><br>        <span class="hljs-comment">// 判断添加为下面情况则需要进行双旋转</span><br>        <span class="hljs-comment">//          GP</span><br>        <span class="hljs-comment">//        /</span><br>        <span class="hljs-comment">//      P</span><br>        <span class="hljs-comment">//    /    \</span><br>        <span class="hljs-comment">//   C    (item)</span><br>        <span class="hljs-keyword">if</span> ((compare(item, grand) &lt; <span class="hljs-number">0</span>) != (compare(item, parent) &lt; <span class="hljs-number">0</span>))<br>            parent = <span class="hljs-built_in">rotate</span>(item, great);<br>        <span class="hljs-comment">// 单旋转</span><br>        current = <span class="hljs-built_in">rotate</span>(item, great);<br>        current.<span class="hljs-built_in">color</span> = BLACK;<br>    &#125;<br>    header.right.<span class="hljs-built_in">color</span> = BLACK;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> insert(AnyType item) &#123;<br>    current = parent = grand = header;<br>    nullNode.element = item;<br>    <br>    <span class="hljs-keyword">while</span>(compare(item, current) != <span class="hljs-number">0</span>) &#123;<br>        great = grand;<br>        grand = parent;<br>        parent = current;<br>        current = compare(item, current) &lt; <span class="hljs-number">0</span>? current.left : current.right;<br>        <br>        <span class="hljs-comment">// 两个儿子为红色</span><br>        <span class="hljs-keyword">if</span> (current.left.<span class="hljs-built_in">color</span> == RED &amp;&amp; current.right.<span class="hljs-built_in">color</span> == RED)<br>            handleReorient(item);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (current != nullNode) <br>        <span class="hljs-keyword">return</span>;<br>    current = <span class="hljs-keyword">new</span> RedBlackNode&lt;AnyType&gt;(item, nullNode, nullNode);<br>    <br>    <span class="hljs-keyword">if</span> (compare(item, parent) &lt; <span class="hljs-number">0</span>)<br>        parent.left = current;<br>    <span class="hljs-keyword">else</span><br>        parent.right = current;<br>    <span class="hljs-comment">// 单旋转</span><br>    handleReorient(item);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="自顶向下的删除"><a href="#自顶向下的删除" class="headerlink" title="自顶向下的删除"></a>自顶向下的删除</h2><p>红黑树中的删除也可以自顶向下进行。每一件工作都归结于能够删除树叶。这是因为，要删除一个带有两个儿子的节点，用右子树上的最小节点代替他；该节点必然最多有一个儿子，然后将该节点删除。只有一个右儿子的节点可以用相同的方式删除，而只有一个左儿子的节点通过用其左子树上最大节点替换而被删除，然后再将该节点删除。<br>注意，对于红黑树，我们不要使用绕过带有一个儿子的节点的情形的方法，因为这可能在树的中部连接两个红色节点，增加红黑条件实现的困难。</p><p>当然，红色树叶的删除很简单。但是如果一片黑色树叶，那么删除操作会复杂多，因为黑色节点的删除会破坏规则4.解决方法是保证从上到下删除期间树叶是红色的。<br>在整个讨论中，令X为当前节点，T是他的兄弟，P是他们的父亲。开始时我们把树的根涂成红色。当延树向下遍历时，我们设法保证X是红色的。当到达一个新的节点时，我们要确信P是红色的并且X和T是黑色的。这存在两个主要的情况。</p><p>首先，设定X右两个黑儿子。此时有三种子情况，如下图</p><ol><li>如果T也有两个黑儿子，那么可以翻转X、T和P的颜色来保持这种不变形。<br><img src="/img/RedBlackTree/5.png" alt="github"></li><li>T的儿子之一是红的，根据哪个儿子是红的需要区分哪种旋转，需要特别注意，这种情形对于树叶是适用的，因为nullNode为黑。<br><img src="/img/RedBlackTree/6.png" alt="github"></li></ol><p>其次，X的儿子之一是红的，在这种情形下，我们落到下一层上，得到新的X、T和P。<br>如果幸运，X落在的红儿子上，则我们可以继续向前进行。如果不是，那么我们就知道T将是红的，而X和P都将是黑的。我们就可以旋转T和P，使得X的新父亲是红的；<br><img src="/img/RedBlackTree/7.png" alt="github"></p><ol><li>下坠</li><li>变换</li><li>旋转</li><li>根据规则变色</li><li>颜色反转</li><li>删除</li></ol><h2 id="确定性跳跃表"><a href="#确定性跳跃表" class="headerlink" title="确定性跳跃表"></a>确定性跳跃表</h2><p>用于红黑树的一些想法可以应用到跳跃表以保证对数最坏情况操作。这里我们描述所得到数据结构的最简单的实现方法，1-2-3确定性跳跃表。<br>跳跃表中的节点随机指定了高度。高度为h的节点包含h个前向链p1,p2,p3…Ph,Pi链接到高度为i或更大的下一个节点。一个节点具有高度h的概率为0.5^h(为了实现时/空交换，0.5可以用0到1.0之间的任何数来代替)。因此，我们期望只处理一些前向链直到下降一层；由于有大约logN层，因此我们得到每次操作花费O(logN)的期望运行时间。<br>为使这个界称为最坏情形的界，我们需要保证只有常数个前向链从一个元素指向另一个元素。<br><strong>定义1：两个元素称为是链接的，如果至少存在一个链从一个元素指向另一个元素。</strong><br><strong>定义2：两个在高度h上连接的元素间的间隙容量等于他们之间高度为h-1的元素数量</strong></p><p>1-2-3确定性跳跃表满足一下性质：每一个间隙（除在头和尾之间）的容量为1、2或3。<br>例如下图，显示了一个1-2-3确定性跳跃表。该表有两个容量为3的间隙；第一个是35和45之间有高度为1的三个元素，第二个是在表头和表尾之间有高度为2的三个元素。尾节点包含∞，他的出现简化了算法并使得定义表终端间隙的概念更容易。<br><img src="/img/RedBlackTree/8.png" alt="github"></p><p>显然，沿任一层行进仅仅通过常数个链就可以下降到低一层。因此，在最坏的情形下查找的时间是O(log N)。<br>为了执行插入，我们必须保证当一个高度为h的新节点加入进来不会产生具有4个高度为h的节点间隙。实际上很简单，我们采用类似于在红黑树中所做的自顶向下的策略即可。</p><p>设我们在L层上，并正要降到下一层去。如果要降到的间隙容量是3，那么我们提高该间隙的中间项使其高度为L，从而形成两个容量为1的间隙。由于这使得朝向插入的道路上消除了容量为3的间隙，因此插入是安全的。</p><p>例如下面将27插入到表中。<br><img src="/img/RedBlackTree/10.png" alt="github"></p><ol><li>从第三层降到第二层</li><li>由于降落到容量为3的间隙，因此这里需要将中间项上升到3的高度，并在表中拼接。</li><li>下降到第一层，又见到容量为3的间隙，因此把35提升到高度2</li><li>最后插入到表中。</li></ol><p>删除的困难是出现在间隙容量为1的情况。当我们看到将要下降到一个容量为1的间隙时，我们要把这个间隙放大，或者是通过从相邻间隙（如果容量不为1）借来的方式，或者通过将该间隙与邻间隙分开的节点的高度降低的方式。由于这两个都是容量为1的间隙，因此结果变成容量为3的间隙。由于有几种情况要处理，因此程序比我们的描述稍微复杂一点。<br>第一个重要的细节是，当我们将一个高h的节点提升到高h+1的时候，我们不能花费时间O(h)用来奖h个链拷贝到一个新数组。否则插入的时间就要成为O(log^2 N)。一种方法是用一个链表来表示高度为h的节点中的h个前向链。由于我们是沿着各层向下进行，因此一个节点的链表是以第h层前向链开始并以第一层前向链结束<br>第二个优化更复杂且可能占用更多的空间。我们不是把节点作为一项和前向链的链表来存储，而且是存储前向链和前向项对的链表。理解其含义的最容易的方法是下图，我们将使用术语<strong>抽象</strong>或<strong>逻辑</strong>来表示。<br><img src="/img/RedBlackTree/11.png" alt="github"></p><p>注意，除了尾节点被删除外，抽象表示和实际实现二者的地平线是一样的。我们的实现中，每一个节点都留有使我们下降一层的链，指向同层上的下一个节点的链以及逻辑上存储在下一项中的项。<br>有些项的出现是多于一次的。例如25出现了三个地方。事实上，如果一个节点在抽象表示中的高度为h，那么他的项在实际实现中就会出现h个地方。部分重要的结论和结果需要在实现方法后进行解释。<br>基本节点由一个项和两个链组成。为了使编程更快更简单，我们使用了尾节点。如果不能够或不希望赋值♾，那么就必须使用其他方式。</p><p>我们对头节点和底层节点都有一个标记以代替null链。SkipNode类和DSL构造方法如下：<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DSL&lt;AnyType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable&lt;?</span> <span class="hljs-title">super</span> <span class="hljs-title">AnyType&gt;&gt;</span> </span>&#123;<br>    public <span class="hljs-type">DSL</span>(<span class="hljs-type">AnyType</span> inf) &#123;<br>        infinity = inf;<br>        bottom = <span class="hljs-keyword">new</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt;(<span class="hljs-literal">null</span>);<br>        bottom.right = bottom.down = bottom;<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt;(infinity);<br>        tail.right = tail;<br>        header = <span class="hljs-keyword">new</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt;(infinity, tail, bottom);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipNode&lt;AnyType&gt;</span> </span>&#123;<br>        <span class="hljs-type">SkipNode</span>(<span class="hljs-type">AnyType</span> theElement) &#123;<br>            <span class="hljs-keyword">this</span>(theElement, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <br>        <span class="hljs-type">SkipNode</span>(<span class="hljs-type">AnyType</span> theElement, <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; rt, <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; dt) &#123;<br>            element = theElement;<br>            right = rt;<br>            down = dt;<br>        &#125;<br>        <br>        <span class="hljs-type">AnyType</span> element;<br>        <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; right;<br>        <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; down;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AnyType</span> infinity;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; header;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; bottom = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; tail = <span class="hljs-literal">null</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p><p>查找函数与随机化跳跃表的查找函数相同。下面代码中如果我们得不到匹配的项，那么或者向下进行，或者向右进行，这依赖于比较的结果。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> contains(AnyType x) &#123;<br>    SkipNode&lt;AnyType&gt; <span class="hljs-keyword">current</span> = <span class="hljs-keyword">header</span>;<br>    bottom.element = x;<br>    <span class="hljs-keyword">for</span>( ; ; ) &#123;<br>        <span class="hljs-type">int</span> compareResult = x.compareTo(<span class="hljs-keyword">current</span>.element);<br>        <span class="hljs-keyword">if</span> (compareResult &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.down<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareResult &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.right<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span> != bottom<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>下面则是插入操作，由于标记的引入而大大的得到简化。利用某些繁琐的链跟踪可以看到，如果对每一个链是否是null进行测试，那么可能将代码扩大三倍。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">insert</span>(AnyType x) &#123;<br>    SkipNode&lt;AnyType&gt; <span class="hljs-keyword">current</span> = <span class="hljs-keyword">header</span>;<br>    <br>    bootom.element = x;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != bottom) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>.element.compareTo(x) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.right;<br>            <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span>.down.right.right.element.compareTo(<span class="hljs-keyword">current</span>.elemenmt) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">current</span>.right = <span class="hljs-built_in">new</span> SkipNode&lt;AnyType&gt;(<span class="hljs-keyword">current</span>.element, <span class="hljs-keyword">current</span>.right, <span class="hljs-keyword">current</span>.down.right.right);<br>            <span class="hljs-keyword">current</span>.element = <span class="hljs-keyword">current</span>.down.right.element;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.down;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">header</span>.right != tail)<br>        <span class="hljs-keyword">header</span> = <span class="hljs-built_in">new</span> SkipNode&lt;AnyType&gt;(<span class="hljs-keyword">infinity</span>, tail, <span class="hljs-keyword">header</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>确定性跳跃表插入过程的程序多少要短一些，考虑的情况比红黑树少得多。我们所付出的代价只有空间：在最坏情况下我们有2N个节点，每一个节点包含两个链和一个项。<br>对于红黑树，我们有N个节点，每一个节点包含两个链、一项以及一个颜色位。因此我们可能要用两倍多的空间。经验指出确定性跳跃表平均使用1.57N个节点，其次某些情况下，确定性跳跃表实际使用的空间少于红黑树。</p><p>有一个适用于C/C++的实际例子。在32位机器上，链和整数是4个字节。对于某些系统，包括某些UNIX，内存时按块(chunk)来培植的，他们通常是2的幂，但存储管理程序使用4个字节的块。于是对于12个字节的请求将得到一个16字节块，即12个字节用户使用而剩下4个字节作为系统开销。<br>但是对于13个字节的需求则必须提供一个32字节块。因此，这种情况下，确定性跳跃表每个节点使用16个字节，而平均有1.57个N，因此总数一般有25N个字节。可是红黑树却使用32N个字节。这说明在某些机器上一个附加位(bit)是非常昂贵的。这是自组织结构的吸引力之一。</p><p><img src="/img/RedBlackTree/12.png" alt="github"><br>确定性跳跃表的性能似乎比红黑树要强。当寻找插入时间的改进时，下面代码包含有逻辑测试：<br><code>if (current.down.right.right.element.compareTo(current.elemenmt) &lt; 0)</code><br>如果我们把一些项存储在最多三个元素的一个数组中，那么对于第三项的访问可以直接进行，而不用再通过两个right链。上面图中所表示的结构，具有讽刺意味的是，这个结构很像B-树。称之为1-2-3确定性跳跃表的水平数组实现。</p>]]></content>
    
    
    <summary type="html">红黑树</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2023/07/25/HashMap/"/>
    <id>http://example.com/2023/07/25/HashMap/</id>
    <published>2023-07-25T22:31:46.000Z</published>
    <updated>2023-07-31T08:10:07.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在 JDK1.8 中，HashMap 是由 数组+链表+红黑树构成(1.7版本是数组+链表)<br><img src="/img/HashMap/0.png" alt="github"><br>当一个值中要存储到HashMap中的时候会根据Key的值来计算出他的hash，通过hash值来确认存放到数组中的位置，如果发生hash冲突就以链表的形式存储，当链表过长的话，HashMap会把这个链表转换成红黑树来存储。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 默认初始容量大小：2的4次方 16 0</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">//最大容量：2的30次方,Integer.MAX_VALUE</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">//默认加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-comment">//计数阈值至少为8转化为使用树而不是列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">//计数阈值小于6反树化，即红黑树转为列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">//可对桶进行树化的最小表容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-comment">//表在第一次使用时初始化，大小调整为必要的。在分配时，长度总是2的幂。在某些操作中，我们也允许长度为零。目前不需要的引导机制。) </span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">//保存缓存的entrySet()</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">//包含的键值映射的元素数量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;<br><br><span class="hljs-comment">//HashMap在结构上被修改的次数，用于快速失败机制</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">// 调整大小的阈值(容量*负载因子)</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">//哈希表扩容使用的负载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></td></tr></table></figure><blockquote><p>这里需要注意的一点是table数组并不是在构造方法里面初始化的，它是在resize(扩容)方法里进行初始化的。</p></blockquote><h2 id="Node的数据结构"><a href="#Node的数据结构" class="headerlink" title="Node的数据结构"></a>Node的数据结构</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; <span class="hljs-keyword">next</span>;<br><br>    Node(<span class="hljs-built_in">int</span> hash, K key, V value, Node&lt;K,V&gt; <span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Node的数据结构是一个链表结构，红黑树也是基于Node的数据结构构建得到。<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">TreeNode<span class="hljs-tag">&lt;K,V&gt;</span> replacementTreeNode(<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; p, <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; next) &#123;<br>    return new TreeNode<span class="hljs-tag">&lt;&gt;</span>(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params">int initialCapacity, float loadFactor</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">// 根据tableSizeFor获取扩容阈值</span><br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params">int initialCapacity</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当初始容量initialCapacity大于最大容量MAXIMUM_CAPACITY大小时，设置成最大容量MAXIMUM_CAPACITY大小，防止溢出。</li></ul><p>根据tableSizeFor获取扩容阈值。<br><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>对任意十进制数转换为2的整数幂，结果是这个数本身的最高有效位的前一位变成1，最高有效位以及其后的位都变为0。</p><p>核心思想是，先将最高有效位以及其后的位都变为1，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是如何将最高有效位后面都变为1。</p><p>此时这里的阈值threshold不是初始容量*负载因子，不必在意，这只是临时的，真正设置threshold在后面put方法中。</p><p>当数组长度为2的幂次方时，可以使用位运算来计算元素在数组中的下标。<br>HashMap是通过<code>index=hash&amp;(table.length-1)</code>这条公式来计算元素在table数组中存放的下标，就是把元素的hash值和数组长度减1的值做一个与运算，即可求出该元素在数组中的下标，这条公式其实等价于<code>hash%length</code>，也就是对数组长度求模取余，<code>只不过只有当数组长度为2的幂次方时，hash&amp;(length-1)才等价于hash%length</code>，使用位运算可以提高效率。</p><p>另外增加hash值的随机性，减少hash冲突。<br>如果 length 为 2 的幂次方，则 length-1 转化为二进制必定是 11111……的形式，这样的话可以使所有位置都能和元素hash值做与运算，如果是如果 length 不是2的次幂，比如length为15，则length-1为14，对应的二进制为1110，在和hash 做与运算时，最后一位永远都为0 ，浪费空间。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    // 调用putVal方法， hash(<span class="hljs-built_in">key</span>)-计算<span class="hljs-built_in">key</span>的hash值<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里分别调用了两个方法。</p><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-built_in">int</span> h;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算key.hashCode()并将哈希的高位数扩展到低位数。</p><ul><li>key.hashCode()获取key的hashCode值</li><li>key的hashCode值与其无符号右移16位值进行异或^。从而让Hash值分布更均匀，右移16位就能让低16位和高16位进行异或，将高位的碰撞影响向下扩散，为了增加hash值的随机性。</li></ul><h2 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">final</span> V putVal(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    <span class="hljs-comment">// 指向hash数组</span><br>    Node&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// 初始化为table中第一个节点</span><br>    Node&lt;K,V&gt; p; <br>    <span class="hljs-comment">// n为数组长度</span><br>    <span class="hljs-comment">// i为索引</span><br>    <span class="hljs-built_in">int</span> n, i;<br>    <span class="hljs-comment">// 如果数组为空，进行 resize() 初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash相当于取模，获取数组的索引位置</span><br>    <span class="hljs-comment">// 如果计算的位置上Node不存在，直接创建节点插入</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果计算的位置上Node 存在，链表或者红黑树处理</span><br>        <span class="hljs-comment">// 果要插入的key-value已存在，用e指向该节点</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果已存在的key和传入的key一模一样，则需要覆盖</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 如果是红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 将元素put到红黑树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, <span class="hljs-built_in">key</span>, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则如果是链表的情况，对链表进行遍历，并统计链表长度binCount</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 如果节点链表的next为空</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 找到节点链表中next为空的节点，创建新的节点插入</span><br>                    p.next = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 如果节点链表中数量超过TREEIFY_THRESHOLD（8）个，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">// 树化</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断节点链表中的key和传入的key是否一样</span><br>                <span class="hljs-comment">// 如果要插入的key-value已存在则终止遍历，否则向后遍历</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    <span class="hljs-comment">// 如果一样的话，退出</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果e不为null说明要插入的key-value已存在</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">// 设置新的值</span><br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧的结果</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 当前大小大于临界大小，扩容</span><br>    <span class="hljs-keyword">if</span> (++<span class="hljs-built_in">size</span> &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>putVal</code>方法总结归纳主要做了如下几件事：</p><ol><li>当桶数组 table 为空时，通过扩容的方式初始化 table。</li><li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值。</li><li>如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树。</li><li>判断键值对数量是否大于阈值，大于的话则进行扩容操作。</li></ol><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">final Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">// 现有容量的大小，等于数组的长度，如果数组为空，返回0</span><br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    <span class="hljs-comment">// 现有的扩容阈值</span><br>    int oldThr = threshold;<br>    <span class="hljs-comment">// newCap表示新的容量，newThr新的扩容阈值</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果现有容量大于0，表示已经初始化过了</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果现有容量已经大于最大容量。结束扩容，直接返回</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>         <span class="hljs-comment">// 否则，如果扩大两倍之后的容量小于最大容量，且现有容量大于等于初始容量16    </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>             <span class="hljs-comment">// 新的扩容阀值扩大为两倍，左移&lt;&lt;1 相当于乘以2</span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 若数组未被初始化，而threshold&gt;0说明调用了HashMap(initialCapacity)和HashMap(initialCapacity, loadFactor)构造器</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)<br>         <span class="hljs-comment">// 进入这里，新的容量等于当前的扩容阈值，</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-comment">// 若table数组未被初始化，且threshold为0说明调用HashMap()构造方法</span><br>    <span class="hljs-keyword">else</span> &#123;               <br>        <span class="hljs-comment">// 新的容量等于默认容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-comment">// 新的扩容阈值等于默认负载因子0.75*默认容量16=12</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 如果新的扩容阈值等于0</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 设置新的扩容阈值等于新的容量*负载因子</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?<br>                  (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// 设置hashmap对象的扩容阈值位新的扩容阈值</span><br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    @SuppressWarnings(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>    <span class="hljs-comment">// 初始化数组     </span><br>    Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    <span class="hljs-comment">// 设置hashmap对象的桶数组为newTab</span><br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-comment">// 下面是rehash的过程</span><br>    <span class="hljs-comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历老的数组</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-comment">// 如果数组索引位置不为空</span><br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果节点下面没有链表或者红黑树，只链接一个节点</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 用新数组容量取模，设置到新数组中</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果节点是红黑树    </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 需要对红黑树进行拆分</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-comment">// 如果节点是链表 </span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                     <span class="hljs-comment">// 遍历链表，并将链表节点按原顺序根据高低位分组</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 使用的是：e.hash &amp; oldCap，若为0则索引位置不变，不为0则新索引=原索引+旧数组长度</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                     <span class="hljs-comment">// 将分组后的链表映射到新桶中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>resize</code>方法大致做了如下的事情：</p><ol><li>计算新桶数组的容量 newCap 和新阈值 newThr。</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的。</li><li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通链表节点，则节点按原顺序进行分组。</li></ol><p><strong>通过hash &amp; oldCap的值来判断，若为0则索引位置不变，不为0则新索引=原索引+旧数组长度</strong><br>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap</p><p>把链表转换成红黑树，树化需要满足以下两个条件：</p><ul><li>链表长度大于等于8</li><li>table数组长度大于等于64</li></ul><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h2><figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">final Node&lt;K,V&gt; getNode(<span class="hljs-type">int</span> hash, Object <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-comment">// 指向hash数组</span><br>    Node&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// first指向hash数组链接的第一个节点，e指向下一个节点</span><br>    Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; <br>    <span class="hljs-comment">// n:hash数组长度</span><br>    <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 定位键值对所在桶的位置</span><br>    if ((tab = table) != <span class="hljs-built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">//(n - 1)&amp; hash相当于取模运算，算出桶的在桶数组中的位置</span><br>        (<span class="hljs-built_in">first</span> = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-built_in">null</span>) &#123;<br>        <span class="hljs-comment">//根据hash算法找到对应位置的第一个数据，如果是指定的key，则直接返回</span><br>        if (<span class="hljs-built_in">first</span>.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            return <span class="hljs-built_in">first</span>;<br>        if ((e = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>) &#123;<br>            <span class="hljs-comment">//如果该节点为红黑树，则通过树进行查找</span><br>            if (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                return ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(hash, <span class="hljs-built_in">key</span>);<br>            <span class="hljs-comment">//如果该节点是链表，则遍历查找到数据</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                if (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    return e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-built_in">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致逻辑如下：</p><ol><li>根据hash值查找到指定位置的数据。</li><li>校验指定位置第一个节点的数据是key是否为传入的key，如果是直接返回第一个节点，否则继续查找第二个节点。</li><li>如果数据是TreeNode（红黑树结构），直接通过红黑树查找节点数据并返回。</li><li>如果是链表结构，循环查找所有节点，返回数据。</li><li>如果没有找到符合要求的节点，返回null。</li></ol><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V remove(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="removeNode方法"><a href="#removeNode方法" class="headerlink" title="removeNode方法"></a>removeNode方法</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">final <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) &#123;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;[] tab; <br>    <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; p; <br>    int n, index;<br>    //定位元素桶位置<br>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != null) &#123;<br>        <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; <span class="hljs-keyword">node</span> <span class="hljs-title">= null</span>, e; <br>        K k; <br>        V v;<br>        // 如果键的值与链表第一个节点相等，则将 <span class="hljs-keyword">node</span> <span class="hljs-title">指向该节点</span><br><span class="hljs-title">        if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">node</span> <span class="hljs-title">= p</span>;<br>        else if ((e = p.next) != null) &#123;  <br>            // 如果是红黑树类型，调用红黑树的查找逻辑定位待删除节点<br>            if (p instanceof TreeNode)<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= ((TreeNode</span><span class="hljs-tag">&lt;K,V&gt;</span>)p).getTreeNode(hash, key);<br>            else &#123;<br>                // 遍历链表，找到待删除节点<br>                do &#123;<br>                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;<br>                        <span class="hljs-keyword">node</span> <span class="hljs-title">= e</span>;<br>                        break;<br>                    &#125;<br>                    p = e;<br>                &#125; while ((e = e.next) != null);<br>            &#125;<br>        &#125;        <br>        //删除节点，并修复链表或红黑树<br>        if (<span class="hljs-keyword">node</span> <span class="hljs-title">!= null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123;<br>            if (<span class="hljs-keyword">node</span> <span class="hljs-title">instanceof</span> TreeNode)<br>                ((TreeNode<span class="hljs-tag">&lt;K,V&gt;</span>)<span class="hljs-keyword">node</span><span class="hljs-title">).removeTreeNode</span>(this, tab, movable);<br>            else if (<span class="hljs-keyword">node</span> <span class="hljs-title">== p</span>)<br>                tab[index] = node.next;<br>            else<br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">            return</span> <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        &#125;</span><br><span class="hljs-title">    &#125;</span><br><span class="hljs-title">    return</span> null;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅需三个步骤即可完成。</p><ol><li>定位桶位置</li><li>遍历链表找到相等的节点</li><li>第三步删除节点</li></ol>]]></content>
    
    
    <summary type="html">HashMap</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用JNI构建环境</title>
    <link href="http://example.com/2023/07/25/Java_JNI/"/>
    <id>http://example.com/2023/07/25/Java_JNI/</id>
    <published>2023-07-25T19:22:35.000Z</published>
    <updated>2023-07-25T03:07:33.439Z</updated>
    
    <content type="html"><![CDATA[<p>如果熟悉Android的朋友应该会有影响，Gradle会帮我们把Java和JNI进行捆绑，方便开发。而Java则会复杂一点，gradle的工作都需要我们来做。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>macos X86_64<br>java 1.8<br>模拟环境 springboot<br>包结构<br><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">project<br>    +-build<br>    +-src<br>    <span class="hljs-string">|  +-main</span><br>    <span class="hljs-string">|     +-cpp</span><br>    <span class="hljs-string">|     +-java</span><br>    <span class="hljs-string">|     +-resources</span><br>    <span class="hljs-string">|           +JniLibs</span><br>    <span class="hljs-string">|</span><br>    +-CMakeLists.txt<br>    +-pom.xml<br></code></pre></td></tr></table></figure><br>可以看到<code>cpp</code>中存放我们的c/c++代码，java中有我们的业务功能以及匹配<code>cpp</code>的jni接口文件，<code>resources</code>中的<code>JniLibs</code>存放的是生成的静态、动态库文件。<br><code>CMakeList.txt</code>则是我们c/c++代码的管理包，这里面需要配置本地的编译环境及生产静态、动态库的库管理。<br>最后<code>build</code>是我们在打包动态链接库的时候生成的临时文件夹。</p><p>开发工具：IDEA、CLION<br>这里推荐Clion是方便开发c/c++代码。</p><h2 id="准备JNI-Java部分代码"><a href="#准备JNI-Java部分代码" class="headerlink" title="准备JNI Java部分代码"></a>准备JNI Java部分代码</h2><p>首先是构建java开发环境及工程，这里就略过了。然后在<code>java</code>文件夹中，创建与C沟通的JNI接口文件:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNative</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;PrintNative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><code>static</code>让其在加载类的时候同时加载本地的资源<code>PrintNative</code>文件。但是目前还没有，我们后续在建。</p><p>接下来，需要对这个文件进行编译，转为头文件：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">cd <span class="hljs-keyword">project</span><span class="hljs-regexp">/src/m</span>ain/java<br><br>javac com<span class="hljs-regexp">/xx/</span>x/PrintNative.java<br>javah com.xx.x.PrintNative<br></code></pre></td></tr></table></figure><br>完成后会生成对应的class文件和头文件，class文件可以删除掉，我们需要的是<code>.h</code>的头文件。我们需要将头文件移动到<code>src/main/cpp/include</code>文件夹下面。</p><h2 id="构建C-C-项目"><a href="#构建C-C-项目" class="headerlink" title="构建C/C++项目"></a>构建C/C++项目</h2><p>首先创建<code>CMakeLists.txt</code>文件，根据上面的路径创建，填入下面内容:<br><figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span>.<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-keyword">add_definitions</span>(-std=c++<span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">set</span>(java_home <span class="hljs-string">&quot;xxxxx/jdk1.8.0_101.jdk/Contents/Home/&quot;</span>)<br><span class="hljs-keyword">set</span>(jdk_home <span class="hljs-string">&quot;xxxxxx/jdk1.8.0_101.jdk/Contents/Home/&quot;</span>)<br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;jdk_home&#125;</span>/<span class="hljs-keyword">include</span>/<br>                    <span class="hljs-variable">$&#123;jdk_home&#125;</span>/<span class="hljs-keyword">include</span>/darwin/<br>                    src/main/cpp/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">add_library</span>(<br>        PrintNative<br>        SHARED<br>        src/main/cpp/print-native.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(PrintNative)<br></code></pre></td></tr></table></figure><br>首先建立了cmake版本、项目的名称、c++版本。<br>然后创建了两个path路径，这里需要根据自己电脑来获取。<br>接下来需要指定include文件夹路径，这里我们需要三个，前两个是java中的头文件路径，最后一个是我们项目中的头文件路径。<br>最后就是建立当前库名称、动态/静态、cpp文件进行打包、链接，这里我们并没有其他的库添加到项目中，因此比较简单。</p><p>上面我们添加了一个cpp文件，因此我们就在这个目录下创建这个文件即可。</p><h2 id="编写测试用的cpp文件"><a href="#编写测试用的cpp文件" class="headerlink" title="编写测试用的cpp文件"></a>编写测试用的cpp文件</h2><p>下面是我们创建的头文件<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span><br><span class="hljs-comment">/* Header for class xx_xx_x_PrintNative */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _Included_xx_xx_x_PrintNative</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _Included_xx_xx_x_PrintNative</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Class:     xx_xx_x_PrintNative</span><br><span class="hljs-comment"> * Method:    print</span><br><span class="hljs-comment"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="hljs-comment"> */</span><br>JNIEXPORT <span class="hljs-keyword">void</span> JNICALL Java_xx_xx_x_PrintNative_print<br>  (JNIEnv *, jobject);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br>需要注意，在使用clion打开这个文件的时候，如果cmake配置错误，头文件第二行的<code>jni.h</code>库引用失败导致编译报错。</p><p>接下来就需要将这个定义的jni接口函数，复制到cpp中，并配置好括号即可。<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#include &quot;Java_xx_xx_xx_PrintNative.h&quot;</span><br><br><span class="hljs-keyword">JNIEXPORT </span>void <span class="hljs-keyword">JNICALL </span><span class="hljs-keyword">Java_xx_xx_x_PrintNative_print</span><br><span class="hljs-keyword"> </span> (<span class="hljs-keyword">JNIEnv </span>*, <span class="hljs-keyword">jobject) </span>&#123;<br>      <br>  &#125;<br></code></pre></td></tr></table></figure><br>这里引用了我们加入的头文件，以及对应的Jni接口函数。<br>接下来就可以进行编写工作。</p><h2 id="打包动态库"><a href="#打包动态库" class="headerlink" title="打包动态库"></a>打包动态库</h2><p>完成工作后，我们就需要开始打包。<br>首先在<code>CMakeLists.txt</code>文件的同级目录下，创建<code>build</code>文件夹。<br>然后在<code>build</code>文件的目录下运行下面的指令：<br><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">cmake -DCMAKE_BUILD_TYPE=Release ..<br><br>cmake --build .<br></code></pre></td></tr></table></figure><br>此时就会在该目录下生成动态链接库了，注意如果报错，部分问题可能是代码错误，部分问题可能是<code>CMakeLists.txt</code>配置错误。<br>由于我的电脑是mac环境，因此生产的文件是<code>libPrintNative.dylib</code>。因此将它复制到resources<code>中的</code>JniLibs`即可。</p><h2 id="java调用动态链接库"><a href="#java调用动态链接库" class="headerlink" title="java调用动态链接库"></a>java调用动态链接库</h2><p>最后我们就需要在java调用了。<br>首先需要修改<code>PrintNative</code>中的代码：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PrintNative &#123;<br><br>    static &#123;<br>        URL url = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PrintNative</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.get<span class="hljs-constructor">Resource(<span class="hljs-string">&quot;jniLibs/libPrintNative.dylib&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>load(url.get<span class="hljs-constructor">Path()</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><br>这里看到是根据路径进行添加，此时是为了我们后续更好的兼容其他版本的架构，因为并不可能只支持x86（假如）也有arm等架构需要支持，此时就需要在<code>jniLibs</code>文件夹下增加一层文件夹，命名就是架构名称，当服务启动时，首先需要检查当前架构名称，然后对该字符串进行拼接得到正确的链接库地址，进行链接即可。<br>修改完成后，就可以编写一个main来进行测试啦。</p><h2 id="特殊bug"><a href="#特殊bug" class="headerlink" title="特殊bug"></a>特殊bug</h2><p>需要注意在运行时可能会出现下面的异常<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">Caused by: java.lang.UnsatisfiedLinkError: <span class="hljs-regexp">/xxx/</span>target<span class="hljs-regexp">/classes/</span>lib<span class="hljs-regexp">/xxx.so: dlopen(/</span>xxx<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/lib/</span>xxx.so, <span class="hljs-number">1</span>): no suitable image found.  Did <span class="hljs-keyword">find</span>:<br><span class="hljs-regexp">/xxx/</span>target<span class="hljs-regexp">/classes/</span>lib/xxx.so: unknown <span class="hljs-keyword">file</span> type, first eight bytes: <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF<br><span class="hljs-regexp">/xxx/</span>target<span class="hljs-regexp">/classes/</span>lib/xxx.so: unknown <span class="hljs-keyword">file</span> type, first eight bytes: <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF<br></code></pre></td></tr></table></figure><br>这需要注意，使用idea编译代码后，由于将二进制文件从resource拷贝到输出路径可能会导致文件格式被破坏。<br>因此需要在pom下提示：<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">nonFilteredFileExtensions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span>so<span class="hljs-tag">&lt;/<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span>dylib<span class="hljs-tag">&lt;/<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">nonFilteredFileExtensions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><br>重新编译即可。</p>]]></content>
    
    
    <summary type="html">Java中使用JNI构建环境</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JNI 一</title>
    <link href="http://example.com/2023/07/25/JNI_1/"/>
    <id>http://example.com/2023/07/25/JNI_1/</id>
    <published>2023-07-25T12:00:01.000Z</published>
    <updated>2023-07-26T06:04:34.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JNI概述"><a href="#JNI概述" class="headerlink" title="JNI概述"></a>JNI概述</h2><p>JNI(Java Native Interface)意为JAVA本地调用，它允许Java代码和其他语言写的代码进行交互，简单的说，一种在Java虚拟机控制下执行代码的标准机制。<br>Android NDK（Native Development Kit ）是一套工具集合，允许你用像C/C++语言那样实现应用程序的一部分。</p><p>JNI和NDK的区别？</p><ul><li>从工具上说，NDK其实多了一个把.so和.apk打包的工具，而JNI开发并没有打包，只是把.so文件放到文件系统的特定位置。</li><li>从编译库说，NDK开发C/C++只能能使用NDK自带的有限的头文件，而使用JNI则可以使用文件系统中带的头文件。</li><li>从编写方式说，它们一样。</li></ul><h2 id="JNI-元素"><a href="#JNI-元素" class="headerlink" title="JNI 元素"></a>JNI 元素</h2><h2 id="JNI组织结构"><a href="#JNI组织结构" class="headerlink" title="JNI组织结构"></a>JNI组织结构</h2><p>JNI函数表的组成就像C++的虚函数表，虚拟机可以运行多张函数表。<br>JNI接口指针仅在当前线程中起作用，指针不能从一个线程进入另一个线程，但可以在不同的线程中调用本地方法。</p><p><img src="/img/JNI/0.png" alt="github"></p><h2 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h2><p>jobject 对象引用类型<br><img src="/img/JNI/1.png" alt="github"></p><div class="table-container"><table><thead><tr><th>Java类型</th><th>本地类型（JNI）</th><th>描述</th></tr></thead><tbody><tr><td>boolean（布尔型）</td><td>jboolean</td><td>无符号8个比特</td></tr><tr><td>byte(字节型)</td><td>jbyte</td><td>有符号8个比特</td></tr><tr><td>char(字符型)</td><td>jchar</td><td>无符号16个比特</td></tr><tr><td>short(短整型)</td><td>jshort</td><td>有符号16个比特</td></tr><tr><td>int(整型)</td><td>jint</td><td>有符号32个比特</td></tr><tr><td>long(长整型)</td><td>jlong</td><td>有符号64个比特</td></tr><tr><td>float(浮点型)</td><td>jfloat</td><td>32个比特</td></tr><tr><td>double(双精度浮点型)</td><td>jdouble</td><td>64个比特</td></tr><tr><td>void(空型)</td><td>void</td><td>N/A</td></tr></tbody></table></div><h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><div class="table-container"><table><thead><tr><th>函数</th><th>Java 数组类型</th><th>本地类型</th><th>说明        </th></tr></thead><tbody><tr><td>GetBooleanArrayElements</td><td>jbooleanArray</td><td>jboolean</td><td>ReleaseBooleanArrayElements 释放</td></tr><tr><td>GetByteArrayElements</td><td>jbyteArray</td><td>jbyte</td><td>ReleaseByteArrayElements 释放</td></tr><tr><td>GetCharArrayElements</td><td>jcharArray</td><td>jchar</td><td>ReleaseShortArrayElements 释放</td></tr><tr><td>GetShortArrayElements</td><td>jshortArray</td><td>jshort</td><td>ReleaseBooleanArrayElements 释放</td></tr><tr><td>GetIntArrayElements</td><td>jintArray</td><td>jint</td><td>ReleaseIntArrayElements 释放</td></tr><tr><td>GetLongArrayElements</td><td>jlongArray</td><td>jlong</td><td>ReleaseLongArrayElements 释放</td></tr><tr><td>GetFloatArrayElements</td><td>jfloatArray</td><td>jfloat</td><td>ReleaseFloatArrayElements 释放</td></tr><tr><td>GetDoubleArrayElements</td><td>jdoubleArray</td><td>jdouble</td><td>ReleaseDoubleArrayElements 释放</td></tr><tr><td>GetObjectArrayElement</td><td>自定义对象</td><td>object</td><td></td></tr><tr><td>SetObjectArrayElement</td><td>自定义对象</td><td>object</td><td></td></tr><tr><td>GetArrayLength</td><td></td><td></td><td>获取数组大小</td></tr><tr><td><code>New&lt;Type&gt;Array</code></td><td></td><td></td><td>创建一个指定长度的原始数据类型的数组</td></tr><tr><td>GetPrimitiveArrayCritical</td><td></td><td></td><td>得到指向原始数据类型内容的指针，该方法可能使垃圾回收不能执行，该方法可能返回数组的拷贝，因此必须释放此资源。</td></tr><tr><td>ReleasePrimitiveArrayCritical</td><td></td><td></td><td>释放指向原始数据类型内容的指针，该方法可能使垃圾回收不能执行，该方法可能返回数组的拷贝，因此必须释放此资源。</td></tr><tr><td>NewStringUTF</td><td></td><td></td><td>jstring类型的方法转换</td></tr><tr><td>GetStringUTFChars</td><td></td><td></td><td>jstring类型的方法转换</td></tr><tr><td>DefineClass</td><td></td><td></td><td>从原始类数据的缓冲区中加载类</td></tr><tr><td>FindClass</td><td></td><td></td><td>该函数用于加载本地定义的类。它将搜索由CLASSPATH 环境变量为具有指定名称的类所指定的目录和 zip文件</td></tr><tr><td>GetObjectClass</td><td></td><td></td><td>通过对象获取这个类。该函数比较简单，唯一注意的是对象不能为NULL，否则获取的class肯定返回也为NULL</td></tr><tr><td>GetSuperclass</td><td></td><td></td><td>获取父类或者说超类 。 如果 clazz 代表类class而非类 object，则该函数返回由 clazz 所指定的类的超类。 如果 clazz指定类 object 或代表某个接口，则该函数返回NULL</td></tr><tr><td>IsAssignableFrom</td><td></td><td></td><td>确定 clazz1 的对象是否可安全地强制转换为clazz2</td></tr><tr><td>Throw</td><td></td><td></td><td>抛出 java.lang.Throwable 对象</td></tr><tr><td>ThrowNew</td><td></td><td></td><td>利用指定类的消息（由 message 指定）构造异常对象并抛出该异常</td></tr><tr><td>ExceptionOccurred</td><td></td><td></td><td>确定是否某个异常正被抛出。在平台相关代码调用 ExceptionClear() 或 Java 代码处理该异常前，异常将始终保持抛出状态</td></tr><tr><td>ExceptionDescribe</td><td></td><td></td><td>将异常及堆栈的回溯输出到系统错误报告信道（例如 stderr）。该例程可便利调试操作</td></tr><tr><td>ExceptionClear</td><td></td><td></td><td>清除当前抛出的任何异常。如果当前无异常，则此例程不产生任何效果</td></tr><tr><td>FatalError</td><td></td><td></td><td>抛出致命错误并且不希望虚拟机进行修复。该函数无返回值</td></tr><tr><td>NewGlobalRef</td><td></td><td></td><td>创建 obj 参数所引用对象的新全局引用。obj 参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef() 来显式撤消。</td></tr><tr><td>DeleteGlobalRef</td><td></td><td></td><td>删除 globalRef 所指向的全局引用</td></tr><tr><td>DeleteLocalRef</td><td></td><td></td><td>删除 localRef所指向的局部引用</td></tr><tr><td>AllocObject</td><td></td><td></td><td>分配新 Java 对象而不调用该对象的任何构造函数。返回该对象的引用。clazz 参数务必不要引用数组类。</td></tr><tr><td>getObjectClass</td><td></td><td></td><td>返回对象的类</td></tr><tr><td>IsSameObject</td><td></td><td></td><td>测试两个引用是否引用同一 Java 对象</td></tr><tr><td>NewString</td><td></td><td></td><td>利用 Unicode 字符数组构造新的 java.lang.String 对象</td></tr><tr><td>GetStringLength</td><td></td><td></td><td>返回 Java 字符串的长度（Unicode 字符数）</td></tr><tr><td>GetStringChars</td><td></td><td></td><td>返回指向字符串的 Unicode 字符数组的指针。该指针在调用 ReleaseStringchars() 前一直有效</td></tr><tr><td>ReleaseStringChars</td><td></td><td></td><td>通知虚拟机平台相关代码无需再访问 chars。参数chars 是一个指针，可通过 GetStringChars() 从 string 获得</td></tr><tr><td>NewStringUTF</td><td></td><td></td><td>利用 UTF-8 字符数组构造新 java.lang.String 对象</td></tr><tr><td>GetStringUTFLength</td><td></td><td></td><td>以字节为单位返回字符串的 UTF-8 长度</td></tr><tr><td>GetStringUTFChars</td><td></td><td></td><td>返回指向字符串的 UTF-8 字符数组的指针。该数组在被ReleaseStringUTFChars() 释放前将一直有效</td></tr><tr><td>ReleaseStringUTFChars</td><td></td><td></td><td>通知虚拟机平台相关代码无需再访问 utf。utf 参数是一个指针，可利用 GetStringUTFChars() 获得</td></tr><tr><td>NewObjectArray</td><td></td><td></td><td>构造新的数组，它将保存类 elementClass 中的对象。所有元素初始值均设为 initialElement</td></tr><tr><td><code>Set&lt;PrimitiveType&gt;ArrayRegion</code></td><td></td><td></td><td>将基本类型数组的某一区域从缓冲区中复制回来的一组函数</td></tr><tr><td>GetFieldID</td><td></td><td></td><td>返回类的实例（非静态）域的属性 ID。该域由其名称及签名指定。访问器函数的<code>Get&lt;type&gt;Field</code> 及 <code>Set&lt;type&gt;Field</code>系列使用域 ID 检索对象域。GetFieldID() 不能用于获取数组的长度域。应使用GetArrayLength()。</td></tr><tr><td><code>Get&lt;type&gt;Field</code></td><td></td><td></td><td>该访问器例程系列返回对象的实例（非静态）域的值。要访问的域由通过调用GetFieldID() 而得到的域 ID 指定。 </td></tr><tr><td><code>Set&lt;type&gt;Field</code></td><td></td><td></td><td>该访问器例程系列设置对象的实例（非静态）属性的值。要访问的属性由通过调用SetFieldID() 而得到的属性 ID指定。</td></tr><tr><td><code>GetStaticFieldID</code>  <code>GetStatic&lt;type&gt;Field</code> <code>SetStatic&lt;type&gt;Field</code></td><td></td><td></td><td>同上，只不过是静态属性。</td></tr><tr><td>GetMethodID</td><td></td><td></td><td>返回类或接口实例（非静态）方法的方法 ID。方法可在某个 clazz 的超类中定义，也可从 clazz 继承。该方法由其名称和签名决定。 GetMethodID() 可使未初始化的类初始化。要获得构造函数的方法 ID，应将<init> 作为方法名，同时将void (V) 作为返回类型。</td></tr><tr><td>CallVoidMethod</td><td></td><td></td><td></td></tr><tr><td>CallObjectMethod</td><td></td><td></td><td></td></tr><tr><td>CallBooleanMethod</td><td></td><td></td><td></td></tr><tr><td>CallByteMethod</td><td></td><td></td><td></td></tr><tr><td>CallCharMethod</td><td></td><td></td><td></td></tr><tr><td>CallShortMethod</td><td></td><td></td><td></td></tr><tr><td>CallIntMethod</td><td></td><td></td><td></td></tr><tr><td>CallLongMethod</td><td></td><td></td><td></td></tr><tr><td>CallFloatMethod</td><td></td><td></td><td></td></tr><tr><td>CallDoubleMethod</td><td></td><td></td><td></td></tr><tr><td>GetStaticMethodID</td><td></td><td></td><td>调用静态方法</td></tr><tr><td><code>Call&lt;type&gt;Method</code></td><td></td><td></td><td></td></tr><tr><td>RegisterNatives</td><td></td><td></td><td>向 clazz 参数指定的类注册本地方法。methods 参数将指定 JNINativeMethod 结构的数组，其中包含本地方法的名称、签名和函数指针。nMethods 参数将指定数组中的本地方法数。</td></tr><tr><td>UnregisterNatives</td><td></td><td></td><td>取消注册类的本地方法。类将返回到链接或注册了本地方法函数前的状态。该函数不应在常规平台相关代码中使用。相反，它可以为某些程序提供一种重新加载和重新链接本地库的途径。    </td></tr></tbody></table></div><h2 id="域描述符"><a href="#域描述符" class="headerlink" title="域描述符"></a>域描述符</h2><div class="table-container"><table><thead><tr><th>域</th><th>Java 语言</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double</td></tr></tbody></table></div><ul><li>引用类型则为 L + 该类型类描述符。</li><li>数组，其为 :  [ + 其类型的域描述符。</li><li>多维数组则是 n个[ +该类型的域描述符, N代表的是几维数组。<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">String类型的域描述符为 Ljava<span class="hljs-regexp">/lang/</span>String;    <br>  <br>[ + 其类型的域描述符 + ;  <br><span class="hljs-keyword">int</span>[]     其描述符为[I  <br><span class="hljs-keyword">float</span>[]   其描述符为[F  <br>String[]  其描述符为[Ljava<span class="hljs-regexp">/lang/</span>String;  <br>Object[]类型的域描述符为[Ljava<span class="hljs-regexp">/lang/</span>Object;  <br><span class="hljs-keyword">int</span>  [][] 其描述符为[[I  <br><span class="hljs-keyword">float</span>[][] 其描述符为[[F  <br></code></pre></td></tr></table></figure></li></ul><p>将参数类型的域描述符按照申明顺序放入一对括号中后跟返回值类型的域描述符，规则如下： (参数的域描述符的叠加)返回类型描述符。对于没有返回值的，用V(表示void型)表示。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">Java层方法                                               JNI函数签名  <br><span class="hljs-keyword">String</span> test ()                                          Ljava/lang/<span class="hljs-keyword">String</span>;  <br><span class="hljs-built_in">int</span> f (<span class="hljs-built_in">int</span> i, <span class="hljs-keyword">Object</span> object)                            (ILjava/lang/<span class="hljs-keyword">Object</span>;)I  <br><span class="hljs-keyword">void</span> <span class="hljs-built_in">set</span> (<span class="hljs-built_in">byte</span>[] bytes)                                ([B)V  <br></code></pre></td></tr></table></figure></p><h2 id="JNIEnv与JavaVM"><a href="#JNIEnv与JavaVM" class="headerlink" title="JNIEnv与JavaVM"></a>JNIEnv与JavaVM</h2><p>JNIEnv 概念 : 是一个线程相关的结构体, 该结构体代表了 Java 在本线程的运行环境 ; </p><p>JNIEnv 与 JavaVM : 注意区分这两个概念; </p><ul><li>JavaVM : JavaVM 是 Java虚拟机在 JNI 层的代表, JNI 全局只有一个;</li><li>JNIEnv : JavaVM 在线程中的代表, 每个线程都有一个, JNI 中可能有很多个 JNIEnv;</li></ul><p>JNIEnv 体系结构<br>线程相关 : JNIEnv 是线程相关的, 即 在 每个线程中 都有一个 JNIEnv 指针, 每个JNIEnv 都是线程专有的, 其它线程不能使用本线程中的 JNIEnv, 线程 A 不能调用 线程 B 的 JNIEnv。</p><p>JNIEnv 不能跨线程 : </p><ul><li>当前线程有效 : JNIEnv 只在当前线程有效, JNIEnv 不能在线程之间进行传递, 在同一个线程中, 多次调用 JNI层方法, 传入的 JNIEnv 是相同的;</li><li>本地方法匹配多JNIEnv : 在 Java 层定义的本地方法, 可以在不同的线程调用, 因此可以接受不同的 JNIEnv;</li></ul><p>JNIEnv 结构 :<br>由上面的代码可以得出, JNIEnv 是一个指针,  指向一个线程相关的结构, 线程相关结构指向 JNI 函数指针 数组, 这个数组中存放了大量的 JNI 函数指针, 这些指针指向了具体的 JNI 函数; </p><p>UTF-8编码<br>JNI使用改进的UTF-8字符串来表示不同的字符类型。Java使用UTF-16编码。UTF-8编码主要使用于C语言，因为它的编码用\u000表示为0xc0，而不是通常的0×00。非空ASCII字符改进后的字符串编码中可以用一个字节表示。</p><p>异常<br>JNI允许用户使用Java异常处理。大部分JNI方法会返回错误代码但本身并不会报出异常。因此，很有必要在代码本身进行处理，将异常抛给Java。在JNI内部，首先会检查调用函数返回的错误代码，之后会调用ExpectOccurred()返回一个错误对象。</p><h2 id="JNI函数实战"><a href="#JNI函数实战" class="headerlink" title="JNI函数实战"></a>JNI函数实战</h2><h2 id="so的入口函数"><a href="#so的入口函数" class="headerlink" title="so的入口函数"></a>so的入口函数</h2><p><code>JNI_OnLoad()</code>与<code>JNI_OnUnload()</code></p><p>当VM(Virtual Machine)执行到System.loadLibrary()函数时，首先会去执行C组件里的JNI_OnLoad()函数。</p><ul><li>告诉VM此C组件使用那一个JNI版本。如果你的*.so档没有提供JNI_OnLoad()函数，VM会默认该*.so档是使用最老的JNI 1.1版本。由于新版的JNI做了许多扩充，如果需要使用JNI的新版功能，例如JNI 1.4的java.nio.ByteBuffer,就必须藉由JNI_OnLoad()函数来告知VM。</li><li>由于VM执行到System.loadLibrary()函数时，就会立即先呼叫JNI_OnLoad()，所以C组件的开发者可以藉由JNI_OnLoad()来进行C组件内的初期值之设定(Initialization) 。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h4 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h4><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">native</span> <span class="hljs-built_in">String</span> <span class="hljs-built_in">print</span>();<br><br><br>jstring res = env-&gt;NewStringUTF(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><h4 id="返回数组"><a href="#返回数组" class="headerlink" title="返回数组"></a>返回数组</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native List&lt;String&gt; add<span class="hljs-constructor">List()</span>;<br><br>jobjectArray pArray = env-&gt;<span class="hljs-constructor">NewObjectArray(4, <span class="hljs-params">env</span>-&gt;FindClass(<span class="hljs-string">&quot;java/lang/String&quot;</span>)</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>    jstring s = env-&gt;<span class="hljs-constructor">NewStringUTF(<span class="hljs-string">&quot;A&quot;</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetObjectArrayElement(<span class="hljs-params">pArray</span>, <span class="hljs-params">i</span>, <span class="hljs-params">s</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回自定义对象"><a href="#返回自定义对象" class="headerlink" title="返回自定义对象"></a>返回自定义对象</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native TestInfo create<span class="hljs-constructor">Test(<span class="hljs-params">int</span> <span class="hljs-params">data1</span>, String <span class="hljs-params">data2</span>)</span>;<br><br><span class="hljs-comment">// 构建TestInfo对象</span><br>jclass pJclass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/xx/xxxx/test/entity/TestInfo&quot;</span>)</span>;<br>jmethodID method_init = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>jfieldID nameField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>)</span>;<br>jfieldID dataField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/Integer;&quot;</span>)</span>;<br>jobject obj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">pJclass</span>, <span class="hljs-params">method_init</span>)</span>;<br><br><span class="hljs-comment">// 构建Integer对象及其字段</span><br>jclass integerClass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;java/lang/Integer&quot;</span>)</span>;<br>jmethodID integerMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">integerClass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>)</span>;<br>jobject integerObj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">integerClass</span>, <span class="hljs-params">integerMethod</span>, <span class="hljs-params">d1</span>)</span>;<br>env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">dataField</span>, <span class="hljs-params">integerObj</span>)</span>;<br><br><span class="hljs-comment">// 构建String字段</span><br>env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">nameField</span>, <span class="hljs-params">env</span>-&gt;NewStringUTF(<span class="hljs-string">&quot;Data&quot;</span>)</span>);<br>return obj;<br></code></pre></td></tr></table></figure><h4 id="返回自定义对象的数组"><a href="#返回自定义对象的数组" class="headerlink" title="返回自定义对象的数组"></a>返回自定义对象的数组</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native List&lt;TestInfo&gt; add<span class="hljs-constructor">List(<span class="hljs-params">int</span> <span class="hljs-params">data1</span>, String <span class="hljs-params">data2</span>)</span>;<br><br>jclass arrClass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;Ljava/util/ArrayList;&quot;</span>)</span>;<br>jmethodID arrMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">arrClass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>jobject arrObj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">arrClass</span>, <span class="hljs-params">arrMethod</span>)</span>;<br><br>jmethodID addMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">arrClass</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Z&quot;</span>)</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    jobject item = create<span class="hljs-constructor">Item(<span class="hljs-params">env</span>, <span class="hljs-params">d1</span>, <span class="hljs-params">d2</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">CallBooleanMethod(<span class="hljs-params">arrObj</span>, <span class="hljs-params">addMethod</span>, <span class="hljs-params">item</span>)</span>;<br>&#125;<br><br>return arrObj;<br></code></pre></td></tr></table></figure><p>这里的<code>createItem</code>是对返回自定义对象功能的一个封装函数:<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">jobject create<span class="hljs-constructor">Item(JNIEnv <span class="hljs-operator">*</span><span class="hljs-params">env</span>, <span class="hljs-params">jint</span> <span class="hljs-params">d1</span>, <span class="hljs-params">jstring</span> <span class="hljs-params">d2</span>)</span> &#123;<br>    jclass pJclass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/hy/modules/test/entity/TestInfo&quot;</span>)</span>;<br>    jmethodID method_init = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>    jfieldID nameField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>)</span>;<br>    jfieldID dataField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/Integer;&quot;</span>)</span>;<br><br>    jobject obj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">pJclass</span>, <span class="hljs-params">method_init</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">nameField</span>, <span class="hljs-params">env</span>-&gt;NewStringUTF(<span class="hljs-string">&quot;Data&quot;</span>)</span>);<br><br>    jclass integerClass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;java/lang/Integer&quot;</span>)</span>;<br>    jmethodID integerMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">integerClass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>)</span>;<br>    jobject integerObj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">integerClass</span>, <span class="hljs-params">integerMethod</span>, <span class="hljs-params">d1</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">dataField</span>, <span class="hljs-params">integerObj</span>)</span>;<br>    return obj;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="操作Java层的类"><a href="#操作Java层的类" class="headerlink" title="操作Java层的类"></a>操作Java层的类</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native void test<span class="hljs-constructor">ThisObjField(TestInfo <span class="hljs-params">info</span>)</span>;<br><br>jclass pJclass = env-&gt;<span class="hljs-constructor">GetObjectClass(<span class="hljs-params">obj</span>)</span>;<br>jfieldID fieldId = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>)</span>;<br><br><span class="hljs-comment">// 获得该属性的值</span><br>jstring data = (jstring)env-&gt;<span class="hljs-constructor">GetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">fieldId</span>)</span>;<br>const <span class="hljs-built_in">char</span> *datas = env-&gt;<span class="hljs-constructor">GetStringUTFChars(<span class="hljs-params">data</span>, NULL)</span>;<br><span class="hljs-comment">// 释放局部引</span><br>env-&gt;<span class="hljs-constructor">ReleaseStringUTFChars(<span class="hljs-params">data</span>, <span class="hljs-params">datas</span>)</span>;<br><br><span class="hljs-built_in">char</span><span class="hljs-operator"> * </span>new_data = <span class="hljs-string">&quot;aaabbb&quot;</span>;<br>jstring pJstring = env-&gt;<span class="hljs-constructor">NewStringUTF(<span class="hljs-params">new_data</span>)</span>;<br>env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">fieldId</span>, <span class="hljs-params">pJstring</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="回调Java层方法"><a href="#回调Java层方法" class="headerlink" title="回调Java层方法"></a>回调Java层方法</h4><p>这里分为两种</p><ol><li>在jni中找到类，创建对象，调用该对象函数</li><li>将接口为参数给jni函数，jni调用该接口中的函数，完成接口回调功能</li></ol><p>首先是第一个：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native void test<span class="hljs-constructor">CallBackToMethod()</span>;<br><br>jclass pJclass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/hy/modules/jni/PrintNative&quot;</span>)</span>;<br>jmethodID pJmethodId = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>jobject pJobject = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">pJclass</span>, <span class="hljs-params">pJmethodId</span>)</span>;<br><br>jmethodID testMethodId = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(I)I&quot;</span>)</span>;<br>jint i = env-&gt;<span class="hljs-constructor">CallIntMethod(<span class="hljs-params">pJobject</span>, <span class="hljs-params">testMethodId</span>, 2)</span>;<br>printf(<span class="hljs-string">&quot;%d&quot;</span>, i);<br></code></pre></td></tr></table></figure><br>这里只是简单调用了对象中的函数</p><p>下面就是接口回调函数<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native void test<span class="hljs-constructor">CallBack(CallBack <span class="hljs-params">callBack</span>)</span>;<br><br>jclass callback_cls = env-&gt;<span class="hljs-constructor">GetObjectClass(<span class="hljs-params">callback</span>)</span>;<br>jmethodID callback_mth = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">callback_cls</span>, <span class="hljs-string">&quot;callback&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>)</span>;<br>env-&gt;<span class="hljs-constructor">CallVoidMethod(<span class="hljs-params">callback</span>, <span class="hljs-params">callback_mth</span>, <span class="hljs-params">env</span>-&gt;NewStringUTF(<span class="hljs-string">&quot;aabbcc&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><br>可以看到她不需要找类，创建新的对象，直接找到需要调用的函数名称并调用即可。</p><blockquote><p>注意，上面是在主进程中使用，如果在jni中的线程中单独使用，则需要特殊处理</p></blockquote><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">JavaVM *g_VM;<br>env-&gt;<span class="hljs-constructor">GetJavaVM(&amp;<span class="hljs-params">g_VM</span>)</span>;<br><br>...<br><br>JNIEnv *env;<br><span class="hljs-comment">//获取当前native线程是否有没有被附加到jvm环境中</span><br><span class="hljs-built_in">int</span> getEnvStat = g_VM-&gt;<span class="hljs-constructor">GetEnv((<span class="hljs-params">void</span> <span class="hljs-operator">**</span>)</span> &amp;env,JNI_VERSION_1_6);<br><br><span class="hljs-keyword">if</span> (getEnvStat<span class="hljs-operator"> == </span>JNI_EDETACHED) &#123;<br>    <span class="hljs-comment">// 关联线程</span><br>    <span class="hljs-keyword">if</span> (g_VM-&gt;<span class="hljs-constructor">AttachCurrentThread(&amp;<span class="hljs-params">env</span>, NULL)</span> != <span class="hljs-number">0</span>) &#123;<br>        return;<br>    &#125;<br>    mNeedDetach = JNI_TRUE;<br>&#125;<br><span class="hljs-comment">//通过jcallback 获取到要回调的类</span><br>jclass javaClass = env-&gt;<span class="hljs-constructor">GetObjectClass(<span class="hljs-params">callback</span>)</span>;<br><br>g_VM-&gt;<span class="hljs-constructor">DetachCurrentThread()</span>;<br></code></pre></td></tr></table></figure><h4 id="jbytearray转c-byte数组"><a href="#jbytearray转c-byte数组" class="headerlink" title="jbytearray转c++byte数组"></a>jbytearray转c++byte数组</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">jbyte</span> * arrayBody = env-&gt;<span class="hljs-type">GetByteArrayElements</span>(<span class="hljs-class"><span class="hljs-keyword">data</span>,0);</span><br><span class="hljs-title">jsize</span> theArrayLengthJ = env-&gt;<span class="hljs-type">GetArrayLength</span>(<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br><span class="hljs-type">BYTE</span> * starter = (<span class="hljs-type">BYTE</span> *)arrayBody;<br></code></pre></td></tr></table></figure><h4 id="jbyteArray-转-c-中的BYTE"><a href="#jbyteArray-转-c-中的BYTE" class="headerlink" title="jbyteArray 转 c++中的BYTE[]"></a>jbyteArray 转 c++中的BYTE[]</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jbyte </span>* olddata = (<span class="hljs-keyword">jbyte*)env-&gt;GetByteArrayElements(strIn, </span><span class="hljs-number">0</span>);<br><span class="hljs-keyword">jsize </span> oldsize = env-&gt;GetArrayLength(strIn);<br><span class="hljs-keyword">BYTE* </span><span class="hljs-keyword">bytearr </span>= (<span class="hljs-keyword">BYTE*)olddata;</span><br><span class="hljs-keyword">int </span>len = (int)oldsize;<br></code></pre></td></tr></table></figure><h4 id="C-中的BYTE-转jbyteArray"><a href="#C-中的BYTE-转jbyteArray" class="headerlink" title="C++中的BYTE[]转jbyteArray"></a>C++中的BYTE[]转jbyteArray</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jbyte </span>*<span class="hljs-keyword">by </span>= (<span class="hljs-keyword">jbyte*)pData;</span><br><span class="hljs-keyword">jbyteArray </span><span class="hljs-keyword">jarray </span>= env-&gt;NewByteArray(nOutSize);<br>env-&gt;SetByteArrayRegin(<span class="hljs-keyword">jarray, </span><span class="hljs-number">0</span>, nOutSize, <span class="hljs-keyword">by);</span><br></code></pre></td></tr></table></figure><h4 id="jbyteArray-转-char"><a href="#jbyteArray-转-char" class="headerlink" title="jbyteArray 转 char *"></a>jbyteArray 转 char *</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">char</span>* <span class="hljs-class"><span class="hljs-keyword">data</span> = (<span class="hljs-title">char</span>*)env-&gt;<span class="hljs-type">GetByteArrayElements</span>(<span class="hljs-title">strIn</span>, 0);</span><br></code></pre></td></tr></table></figure><h4 id="char-转jstring"><a href="#char-转jstring" class="headerlink" title="char* 转jstring"></a>char* 转jstring</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jstring str</span> = env-&gt;GetStringUTFChars(char_data, NULL);<br></code></pre></td></tr></table></figure><h4 id="jstring-转char"><a href="#jstring-转char" class="headerlink" title="jstring 转char*"></a>jstring 转char*</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *char_data = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(jstring_data, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JNI 一</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型 关于 ? extends super</title>
    <link href="http://example.com/2023/07/19/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2023/07/19/%E6%B3%9B%E5%9E%8B/</id>
    <published>2023-07-19T20:14:22.000Z</published>
    <updated>2023-07-19T12:32:17.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>? extends T：声明上界，表示参数化的类型可能是所指定的 T 类型，或者是此类型的任意子类型。最终子类型：未知。</li><li>? super T：声明下界，表示参数化的类型可能是所指定的 T 类型，或者是此类型的任意父类型。最终父类型：已知——Object。</li><li>Java 中泛型不变：假设有 A extends B，但 List<A> 和 List<B> 不存在型变关系。</li></ul><h2 id="泛型的简单使用"><a href="#泛型的简单使用" class="headerlink" title="泛型的简单使用"></a>泛型的简单使用</h2><h2 id="泛型不变"><a href="#泛型不变" class="headerlink" title="泛型不变"></a>泛型不变</h2><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><span class="hljs-type">List</span>&lt;<span class="hljs-type">A</span>&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<span class="hljs-comment">// 泛型不变</span><br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>());<br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-type">B</span>());<br><span class="hljs-type">A</span> a = list1.get(<span class="hljs-number">1</span>);<br><span class="hljs-type">List</span>&lt;<span class="hljs-type">A</span>&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">B</span>&gt;();<span class="hljs-comment">// 编译错误，泛型不变，也就不支持协变（类似多态）</span><br></code></pre></td></tr></table></figure><h2 id="extends-泛型协变"><a href="#extends-泛型协变" class="headerlink" title="extends 泛型协变"></a>extends 泛型协变</h2><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">B</span>&gt;();<span class="hljs-comment">// 协变——父类引用指向子类</span><br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>());  <span class="hljs-comment">// 错误，容器不可写，不能放入任何值（null 除外）</span><br><span class="hljs-type">A</span> a = list1.get(<span class="hljs-number">1</span>);<span class="hljs-comment">// work 可读，且有泛型</span><br></code></pre></td></tr></table></figure><p>集合可读、不可写，集合泛型协变。</p><h2 id="super-泛型逆变"><a href="#super-泛型逆变" class="headerlink" title="super 泛型逆变"></a>super 泛型逆变</h2><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">B</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<span class="hljs-comment">// 逆变——子类引用指向父类</span><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>());  <span class="hljs-comment">// 编译错误，集合中放入的元素类型只能为 B 及 B 子类型</span><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-type">B</span>());    <span class="hljs-comment">// work</span><br><span class="hljs-type">Object</span> b = list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// work 可读，但无类型都是 Object</span><br></code></pre></td></tr></table></figure><p>集合可读 Object 、可写，集合泛型逆变。</p><h2 id="结束说明"><a href="#结束说明" class="headerlink" title="结束说明"></a>结束说明</h2><ul><li>? extends T：针对返回值泛型使用（如，只读的消费者集合泛型），指定的 T 为集合元素的通用父类型，用于限定取出类型为 T 的子类型、打破泛型不变。</li><li>? super T：针对方法参数泛型使用（如，只写的生产者集合泛型），指定的 T 为集合元素的通用父类型，用于限定放入类型为 T 的子类型、打破泛型不变。</li></ul><p>可以看出，感觉到extends 与 super 功能互补。extends 用于方法返回值，super 用于方法参数。</p><h2 id="逆变协变优点"><a href="#逆变协变优点" class="headerlink" title="逆变协变优点"></a>逆变协变优点</h2><p>我们用 Java 对现实世界的水果进行简单的抽象，水果抽象为 Fruit，Apple等于 Fruit 存在继承关系。盛放水果的盘子 plate 被抽象为 List。</p><p>于是我们 OOP 代码抽象得到：<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watermelon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; plate1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Apple</span>&gt;();      <span class="hljs-comment">// 编译错误</span><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; plate2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Banana</span>&gt;();     <span class="hljs-comment">// 编译错误</span><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; plate3 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Watermelon</span>&gt;(); <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><br>编译错误：</p><blockquote><p>Java 中类型存在协变关系<br>但是 Java 中类型上泛型不存在协变关系，即 List<Fruit> != ArrayList<Apple>，因此编译器提示泛型协变的编译错误。</p></blockquote><p>我们利用上面学到的 ? extends 、? super 打破泛型不变的特性，提供泛型协变，提高代码的复用性：<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><br><span class="hljs-comment">// 协变，用作只读型容器————集合中元素都是 A 或 A 子类型</span><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; plate1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; plate2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">B</span>&gt;();<br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; plate3 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">C</span>&gt;();<br><span class="hljs-comment">// 逆变，用作只写型容器————集合中元素都是 B 或 B 父类型</span><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">B</span>&gt; plate4 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<br><br><span class="hljs-comment">// 上述结果</span><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">Fruit</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Apple</span>&gt;();<br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">Apple</span>&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Fruit</span>&gt;();<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java锁</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://example.com/2023/07/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2023/07/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-07-11T19:22:35.000Z</published>
    <updated>2023-07-19T14:04:43.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/ThreadPool/3.png" alt="github"></p><h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul><li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。</li><li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。</li><li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序。</li><li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池。</li><li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池。</li><li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li><li>ThreadPoolExecutor：手动创建线程池的方式，它创建时最多可以设置 7 个参数。</li></ul><p>线程池的创建推荐使用最后一种 ThreadPoolExecutor 的方式来创建，因为使用它可以明确线程池的运行规则，规避资源耗尽的风险。 </p><h2 id="线程池七个参数含义"><a href="#线程池七个参数含义" class="headerlink" title="线程池七个参数含义"></a>线程池七个参数含义</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,<br>                          <span class="hljs-keyword">int</span> maximumPoolSize,<br>                          <span class="hljs-keyword">long</span> keepAliveTime,<br>                          TimeUnit unit,<br>                          BlockingQueue&lt;Runnable&gt; workQueue,<br>                          ThreadFactory threadFactory,<br>                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程数。</li><li>maximumPoolSize：最大线程数。</li><li>keepAliveTime：空闲线程存活时间。</li><li>TimeUnit：时间单位。</li><li>BlockingQueue：线程池任务队列。</li><li>ThreadFactory：创建线程的工厂。</li><li>RejectedExecutionHandler：拒绝策略。</li></ul><p>详细如下</p><h2 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h2><p>核心线程数：是指线程池中长期存活的线程数。</p><h2 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h2><p>最大线程数：线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。</p><p>最大线程数 maximumPoolSize 的值不能小于核心线程数 corePoolSize，否则在程序运行时会报 IllegalArgumentException 非法参数异常。</p><h2 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h2><p>空闲线程存活时间，当线程池中没有任务时，会销毁一些线程，销毁的线程数=maximumPoolSize（最大线程数）-corePoolSize（核心线程数）。</p><h2 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h2><p>时间单位：空闲线程存活时间的描述单位，此参数是配合参数 3 使用的。</p><ul><li>TimeUnit.DAYS：天</li><li>TimeUnit.HOURS：小时</li><li>TimeUnit.MINUTES：分</li><li>TimeUnit.SECONDS：秒</li><li>TimeUnit.MILLISECONDS：毫秒</li><li>TimeUnit.MICROSECONDS：微妙</li><li>TimeUnit.NANOSECONDS：纳秒</li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列：线程池存放任务的队列，用来存储线程池的所有待执行任务</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li></ul><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>线程工厂：线程池创建线程时调用的工厂方法，通过此方法可以设置线程的优先级、线程命名规则以及线程类型（用户线程还是守护线程）等。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建线程工厂</span><br>    ThreadFactory threadFactory = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">ThreadFactory</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-function"><span class="hljs-title">newThread</span>(<span class="hljs-params">Runnable r</span>)</span> &#123;<br>            <span class="hljs-comment">// 创建线程池中的线程</span><br>            Thread thread = <span class="hljs-keyword">new</span> Thread(r);<br>            <span class="hljs-comment">// 设置线程名称</span><br>            thread.setName(<span class="hljs-string">&quot;Thread-&quot;</span> + r.hashCode());<br>            <span class="hljs-comment">// 设置线程优先级（最大值：10）</span><br>            thread.setPriority(Thread.MAX_PRIORITY);<br>            <span class="hljs-comment">//......</span><br>            <span class="hljs-keyword">return</span> thread;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 创建线程池</span><br>    ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>,<br>                                                                   TimeUnit.SECONDS,<br>                                                             <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<br>                                                                   threadFactory); <span class="hljs-comment">// 使用自定义的线程工厂</span><br>    threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            Thread thread = Thread.currentThread();<br>            System.out.println(<span class="hljs-built_in">String</span>.format(<span class="hljs-string">&quot;线程：%s，线程优先级：%d&quot;</span>,<br>                                             thread.getName(), thread.getPriority()));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h2><p>拒绝策略：当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。</p><ul><li>AbortPolicy：拒绝并抛出异常。</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务。</li><li>DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。</li><li>DiscardPolicy：忽略并抛弃当前任务。</li></ul><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><h2 id="线程池的五种状态"><a href="#线程池的五种状态" class="headerlink" title="线程池的五种状态"></a>线程池的五种状态</h2><div class="table-container"><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>处于RUNNING状态下的线程池能够接收新的任务以及处理阻塞队列中的任务。</td></tr><tr><td>SHUTDOWN</td><td>处于SHUTDOWN状态下的线程池，不再接收新到来的任务，但是依然能够处理阻塞队列中的任务。</td></tr><tr><td>STOP</td><td>处于STOP状态下的线程池，不再接收新到来的任务，但是依然能够处理阻塞队列中的任务。</td></tr><tr><td>TIDYING</td><td>所有任务已经终止，有效线程数为0， 线程转换到TIDYING状态对运行terminated钩子方法</td></tr><tr><td>TERMINATED</td><td>terminated方法执行完成后进入terminated状态</td></tr></tbody></table></div><p><img src="/img/ThreadPool/0.png" alt="github"></p><h2 id="ThreadPoolExecutor中表示线程池状态设计"><a href="#ThreadPoolExecutor中表示线程池状态设计" class="headerlink" title="ThreadPoolExecutor中表示线程池状态设计"></a>ThreadPoolExecutor中表示线程池状态设计</h2><p><img src="/img/ThreadPool/2.png" alt="github"></p><p>在ThreadPoolExecutor中使用一个AtomicInteger类型的ctl字段来描述线程池地运行状态和线程数量，通过ctl的高3位来表示线程池的5种状态，低29位表示线程池中现有的线程数量。使用最少的变量来减少锁竞争，提高并发效率。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicInteger</span>(<span class="hljs-built_in">ctlOf</span>(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 线程池线程数地bit数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 线程池中最大线程容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = <span class="hljs-number">-1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 获取线程池地运行状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-comment">// 获取有效工作线程地数量</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-comment">// 组装线程数量和线程池状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure></p><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><ul><li>如果工作线程 小于 核心线程，那么就会创建线程执行提交的任务。</li><li>如果工作线程 大于 核心线程，并且阻塞队列未满，那么就会添加至阻塞队列，等待后续线程来执行提交地任务。</li><li>如果工作线程 大于 核心线程，并且工作线程 小于 最大线程数，并且阻塞队列已满，那么就会创建非核心线程执行提交的任务。</li><li>如果工作线程 大于等于 最大线程数，并且阻塞队列已满，那么就会执行拒绝策略。</li></ul><p><img src="/img/ThreadPool/1.png" alt="github"></p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public void execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command<span class="hljs-operator"> == </span>null)<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">NullPointerException()</span>;<br>    <span class="hljs-built_in">int</span> c = ctl.get<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 如果工作线程 小于 核心线程</span><br>    <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">c</span>)</span> &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (add<span class="hljs-constructor">Worker(<span class="hljs-params">command</span>, <span class="hljs-params">true</span>)</span>)<br>            return;<br>        c = ctl.get<span class="hljs-literal">()</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果工作线程 大于 核心线程</span><br>    <span class="hljs-comment">// 线程池处于运行状态，加入队列</span><br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Running(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;<br>        <span class="hljs-built_in">int</span> recheck = ctl.get<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// 两次获取ctl</span><br>        <span class="hljs-comment">// 在往阻塞队列中添加任务地时候，有可能阻塞队列已满，需要等待其他的任务移出队列，在这个过程中，线程池的状态可能会发生变化</span><br>        <span class="hljs-comment">// 如果在往阻塞队列中添加任务地时候，线程池地状态发生变化，则需要将任务remove</span><br>        <span class="hljs-keyword">if</span> (! is<span class="hljs-constructor">Running(<span class="hljs-params">recheck</span>)</span><span class="hljs-operator"> &amp;&amp; </span>remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">recheck</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>            add<span class="hljs-constructor">Worker(<span class="hljs-params">null</span>, <span class="hljs-params">false</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!add<span class="hljs-constructor">Worker(<span class="hljs-params">command</span>, <span class="hljs-params">false</span>)</span>)<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="addWorker-创建线程加入线程池"><a href="#addWorker-创建线程加入线程池" class="headerlink" title="addWorker 创建线程加入线程池"></a>addWorker 创建线程加入线程池</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> addWorker(Runnable firstTask, <span class="hljs-built_in">boolean</span> core) &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">int</span> c = ctl.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-built_in">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// 线程池状态处于非RUNNING状态，添加worker失败</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 判断线程池中线程数量是否处于该线程池允许的最大线程数量，如果允许创建线程，则cas更新线程池中线程数量，并退出循环检查，执行下面创建线程地逻辑</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-built_in">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.<span class="hljs-built_in">get</span>();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-built_in">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建线程</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">int</span> rs = runStateOf(ctl.<span class="hljs-built_in">get</span>());<br>                <span class="hljs-comment">// 如果线程池处于RUNNING状态，并且线程已经启动则提前抛出线程异常启动异常</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">// 将线程加入已创建地线程集合，更新用于追踪线程池中线程数量largestPoolSize字段</span><br>                    workers.<span class="hljs-built_in">add</span>(w);<br>                    <span class="hljs-built_in">int</span> s = workers.<span class="hljs-built_in">size</span>();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 启动线程执行任务</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 启动线程会调用Worker中地runWorker()来执行任务</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>将一个任务Runnable提交给线程池执行时，主要分三步：</p><ul><li><ol><li>如果线程池中的线程数（workCount）&lt; 线程池大小（corePoolSize），则创建一个线程，执行这个任务，并把这个线程放入线程池。添加任务时会对线程池状态进行检查，以防止线程池状态为关闭时还添加线程。</li></ol></li><li><ol><li>如果线程池中的线程数（workCount）&gt;= 线程池大小（corePoolSize），或者上一步添加任务最后失败，将任务放入缓存队列中。当任务成功加入缓存队列，仍需要对线程池状态进行二次检查，防止线程池状态改为关闭或线程池中已经没有可以运行的线程。</li></ol></li><li><ol><li>如果上一步将任务放入缓存队列失败，试着去增加一个新的线程来执行它（超过线程池大小的额外线程）。如果添加新线程失败（可能是线程数已到达maximumPoolSize），则抛出异常拒绝执行该任务。</li></ol></li></ul><h2 id="runWorker执行任务"><a href="#runWorker执行任务" class="headerlink" title="runWorker执行任务"></a>runWorker执行任务</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">final void run<span class="hljs-constructor">Worker(Worker <span class="hljs-params">w</span>)</span> &#123;<br>    <span class="hljs-comment">// 获取执行任务线程</span><br>    Thread wt = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-comment">// 获取执行任务</span><br>    Runnable task = w.firstTask;<br>    <span class="hljs-comment">// 将worker中的任务置空</span><br>    w.firstTask = null;<br>    <span class="hljs-comment">// 这里不是解锁操作，这里是为了设置state = 0 以及 ExclusiveOwnerThread = null，因为起始状态state = -1, 不允许任何线程抢占锁，这里就是初始化操作。</span><br>    w.unlock<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 表示是否突然退出标志位，</span><br>    <span class="hljs-comment">// true-&gt;  发生异常了，当前线程突然退出，后面会做处理</span><br>    <span class="hljs-comment">// false-&gt; 正常退出</span><br>    boolean completedAbruptly = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 核心逻辑，这里 task 就是从队列里面取出一个runnable跑</span><br>        <span class="hljs-comment">// 条件1：</span><br>        <span class="hljs-comment">// task != null 指的就是firstTask是不是null，不是null执行循环体</span><br>        <span class="hljs-comment">// 条件2：</span><br>        <span class="hljs-comment">// getTask()方法就是当前线程从BlockingQueue中获取任务，此方法会阻塞</span><br>        <span class="hljs-comment">// getTask() == null 说明当前线程需要执行结束逻辑</span><br>        <span class="hljs-keyword">while</span> (task != null<span class="hljs-operator"> || </span>(task = get<span class="hljs-constructor">Task()</span>) != null) &#123;<br>            w.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 1.线程池处于STOP/TIDYING/TERMINATION状态时需要设置线程的中断标志位</span><br>            <span class="hljs-comment">// 2.强制刷新标志位为false，通过Thread.interrupted()方法，因为有可能上一次执行task时，当前线程的中断标志位被设置为了true，且没有处理，这里就需要强制刷新一下，不会影响到后面的task。</span><br>            <span class="hljs-keyword">if</span> ((run<span class="hljs-constructor">StateAtLeast(<span class="hljs-params">ctl</span>.<span class="hljs-params">get</span>()</span>, STOP) <span class="hljs-pattern-match"><span class="hljs-operator">||</span></span><br><span class="hljs-pattern-match">                 (<span class="hljs-constructor">Thread</span>.interrupted() <span class="hljs-operator">&amp;&amp;</span></span><br><span class="hljs-pattern-match">                  run<span class="hljs-constructor">StateAtLeast(<span class="hljs-params">ctl</span>.<span class="hljs-params">get</span>()</span>, <span class="hljs-constructor">STOP</span>))) <span class="hljs-operator">&amp;&amp;</span></span><br><span class="hljs-pattern-match">                !wt.is<span class="hljs-constructor">Interrupted()</span>)</span><br><span class="hljs-pattern-match">                wt.interrupt();</span><br><span class="hljs-pattern-match">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="hljs-pattern-match">                <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 前置执行任务钩子函数</span><br><span class="hljs-pattern-match">                before<span class="hljs-constructor">Execute(<span class="hljs-params">wt</span>, <span class="hljs-params">task</span>)</span>;</span><br><span class="hljs-pattern-match">                <span class="hljs-constructor">Throwable</span> thrown = null;</span><br><span class="hljs-pattern-match">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="hljs-pattern-match">                    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 执行当前任务</span><br><span class="hljs-pattern-match">                    task.run();</span><br><span class="hljs-pattern-match">                &#125; catch (<span class="hljs-constructor">RuntimeException</span> x) &#123;</span><br><span class="hljs-pattern-match">                    thrown = x; throw x;</span><br><span class="hljs-pattern-match">                &#125; catch (<span class="hljs-constructor">Error</span> x) &#123;</span><br><span class="hljs-pattern-match">                    thrown = x; throw x;</span><br><span class="hljs-pattern-match">                &#125; catch (<span class="hljs-constructor">Throwable</span> x) &#123;</span><br><span class="hljs-pattern-match">                    thrown = x; throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-params">x</span>)</span>;</span><br><span class="hljs-pattern-match">                &#125; finally &#123;</span><br><span class="hljs-pattern-match">                    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 后置只sing任务钩子函数</span><br><span class="hljs-pattern-match">                    after<span class="hljs-constructor">Execute(<span class="hljs-params">task</span>, <span class="hljs-params">thrown</span>)</span>;</span><br><span class="hljs-pattern-match">                &#125;</span><br><span class="hljs-pattern-match">            &#125; finally &#123;</span><br><span class="hljs-pattern-match">                task = null;</span><br><span class="hljs-pattern-match">                w.completed<span class="hljs-constructor">Tasks</span><span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">                w.unlock();</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        completed<span class="hljs-constructor">Abruptly</span> = <span class="hljs-literal">false</span>;</span><br><span class="hljs-pattern-match">    &#125; finally &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 回收线程</span><br><span class="hljs-pattern-match">        process<span class="hljs-constructor">WorkerExit(<span class="hljs-params">w</span>, <span class="hljs-params">completedAbruptly</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>线程池有个内部类 Worker，它实现了 Runnable接口，它自己要 run 起来。 然后它会在合适的时候获取我们提交的 Runnable 任务，然后调用任务的 run()接口。 一个 Worker 不终止的话可以不断执行任务。<br>Worker 继承了AQS，用的是非公平锁，独占锁（不可重入）。</p><ul><li>Worker执行任务时获得锁，执行完毕释放锁。</li><li>Worker具有不可重入特性，目的是为了防止worker刚好在运行途中，线程池控制类操作（比如setCorePoolSize)时获得锁，这样的话，因为重入性，setCorePoolSize会执行中断操作，会把正在运行的任务中断掉。在空闲时可以响应中断，在执行任务时不可被中断</li></ul><blockquote><p>比如进行shutdown()优雅停机的时候，要进行w.tryLock方法，没有获取到锁，说明正在运行或者干其他事情，是不会被其他事情打断掉的。</p></blockquote><p>实现了runnable来达到具备线程功能。</p><p>“线程池中的线程”，其实就是 Worker；等待队列中的元素，是我们提交的 Runnable 任务。每一个 Worker 在创建出来的时候，会调用它本身的 run()方法，实现是 runWorker(this)，这个实现的核心是一个 while 循环，这个循环不结束， Worker 线程就不会终止，就是这个基本逻辑。</p><ul><li>在这个 while 条件中，有个 getTask()方法是核心中的核心，它所做的事情就是从等待队列中取出任务来执行</li></ul><h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">private Runnable getTask() &#123;<br>    <span class="hljs-regexp">//</span> 表示当前线程获取任务是否超时，默认是false，true表示已超时<br>    boolean timedOut = false;<br><br>    <span class="hljs-regexp">//</span> 自旋<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        int c = ctl.get();<br>        <span class="hljs-regexp">//</span> 获取线程池当前运行状态<br>        int rs = runStateOf(c);<br><br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">1</span>：rs &gt;= SHUTDOWN 条件成立：说明当前线程池是非RUNNING状态，可能是SHUTDOWN/STOP...<br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">2</span>：(rs &gt;= STOP || workQueue.isEmpty())<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span> rs &gt;= STOP 成立说明：当前的状态最低也是STOP状态，一定要返回null了<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2.2</span> 前置条件：状态是SHUTDOWN(因为 rs &gt;= SHUTDOWN 且 rs &gt;= STOP 不成立，所以当前状态只能为SHUTDOWN)<br>        <span class="hljs-regexp">//</span>     workQueue.isEmpty()条件成立：说明当前线程池状态为SHUTDOWN状态 且 任务队列已空，此时一定返回null<br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            <span class="hljs-regexp">//</span> 使用CAS + 自旋将ctl值-<span class="hljs-number">1</span><br>            decrementWorkerCount();<br>            <span class="hljs-regexp">//</span> runWorker方法就会将返回null的线程执行线程退出线程池的逻辑。<br>            return null;<br>        &#125;<br><br>        <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.线程池是Running状态<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.线程池是SHUTDOWN状态，但是队列中还有任务(此时可以创建线程)<br>        <br>        <span class="hljs-regexp">//</span> 获取线程池中的线程数量<br>        int wc = workerCountOf(c);<br><br>        <span class="hljs-regexp">//</span> timed == true<br>        <span class="hljs-regexp">//</span> 表示当前这个线程获取task时是支持超时机制的，使用queue.poll(xx, xx); 第一个参数是时间，第二个参数是时间单位。当获取task超时的情况下，下一次自旋就可能返回null了。<br>        <span class="hljs-regexp">//</span> timed == false<br>        <span class="hljs-regexp">//</span> 表示当前这个线程 获取 task 时 是不支持超时机制的，当前线程会使用 queue.take();<br>        <span class="hljs-regexp">//</span> 情况<span class="hljs-number">1</span>：allowCoreThreadTimeOut == true 表示核心线程数量内的线程 也可以被回收。所有线程 都是使用queue.poll(xx, xx) 超时机制这种方式获取task<br>        <span class="hljs-regexp">//</span> 情况<span class="hljs-number">2</span>：allowCoreThreadTimeOut == false 表示当前线程池会维护核心数量内的线程<br>        <span class="hljs-regexp">//</span> wc &gt; corePoolSize<br>        <span class="hljs-regexp">//</span> 条件成立：当前线程池中的线程数量是大于核心线程数的，此时让所有路过这里的线程(救急线程)，都使用poll(xx,xx)支持超时的方式去获取任务<br>        <span class="hljs-regexp">//</span> 这样，就会可能有一部分线程获取不到任务，获取不到任务 返回null，然后runWorker会执行线程退出逻辑。<br>        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">1</span>：(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">1.1</span>：wc &gt; maximumPoolSize 为什么会成立？setMaximumPoolSize()方法，可能外部线程将线程池最大线程数设置为比初始化时的要小<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">1.2</span>: (timed &amp;&amp; timedOut) 条件成立：前置条件，当前线程使用poll方式获取task。上一次循环时 使用poll方式获取任务时，超时了<br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">1</span> 为true表示 线程可以被回收，达到回收标准，当确实需要回收时再回收。<br>        <span class="hljs-regexp">//</span> <br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">2</span>：(wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span>: wc &gt; <span class="hljs-number">1</span> 条件成立，说明当前线程池中还有其他线程，当前线程可以直接回收，返回null<br>        <span class="hljs-regexp">//</span> workQueue.isEmpty() 前置条件 wc == <span class="hljs-number">1</span>， 条件成立：说明当前任务队列 已经空了，最后一个线程，也可以放心的退出。<br>        <span class="hljs-regexp">//</span> 判断当前线程是否达到了回收的标准，<br>        <span class="hljs-regexp">//</span> 当获取任务超时并且核心线程可以被回收并且 当前线程池线程数量大于<span class="hljs-number">1</span>并且队列中没有任务了，当前线程就达到回收标准了，<br>        <span class="hljs-regexp">//</span> 当确实需要回收时才会被回收。<br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-regexp">//</span> 使用CAS机制 将ctl值-<span class="hljs-number">1</span>，减<span class="hljs-number">1</span>成功的线程，返回null<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                return null;<br>            <span class="hljs-regexp">//</span> 如果CAS失败，再次自旋，timed就有可能是false了，因为当前线程CAS失败，<br>            <span class="hljs-regexp">//</span> 很有可能是因为其他线程成功退出导致的，再次自旋时检查发现，当前线程就可能不属于回收范围了<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        try &#123;<br>            <span class="hljs-regexp">//</span> 根据timed的值，判断去队列中获取任务是使用带超时时间的还是不带超时时间的(注意：如果获取不到任务都会阻塞)<br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != null)<br>                return r;<br>            <span class="hljs-regexp">//</span> 说明当前线程超时了 继续进行自旋<br>            timedOut = true;<br>        &#125; catch (InterruptedException retry) &#123;<br>            timedOut = false;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果没有达到 corePoolSize，则创建的 Worker 在执行完它承接的任务后，会用workQueue.take()取任务，这个接口是阻塞接口，如果取不到任务， Worker线程一直阻塞。</li><li>如果超过了 corePoolSize，或者allowCoreThreadTimeOut，一个Worker 在空闲了之后，会用 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)取任务。注意，这个接口只阻塞等待 keepAliveTime 时间，超过这个时间返回 null，则Worker 的 while 循环执行结束，则被终止了。</li></ul><p>核心线程（Worker）即使一直空闲也不终止，是通过workQueue.take()实现的，它会一直阻塞到从等待队列中取到新的任务。 非核心线程空闲指定时间后终止是通过workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)实现的，一个空闲的 Worker 只等待 keepAliveTime，如果还没有取到任务则循环终止，线程也就运行结束了。</p><p>另外，这里针对<code>allowCoreThreadTimeOut</code>是否允许核心线程超时（被清理）有大量的使用。也可以通过设置这个字段来达到不被清理的效果。</p><h2 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit()"></a>processWorkerExit()</h2><p>runWorker() 的收尾方法。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// completedAbruptly</span><br><span class="hljs-comment">// true表示当前worker是因为任务出异常退出的</span><br><span class="hljs-comment">// false表示当前worker是因为没有获取到任务</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        <span class="hljs-comment">// 使用CAS + 自旋将ctl的值-1</span><br>        <span class="hljs-built_in">decrementWorkerCount</span>();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将当前worker完成的任务总数累加到全局总数上</span><br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">// 将当前worker从线程池(workers就是一个HashSet)移除</span><br>        workers.<span class="hljs-built_in">remove</span>(w);<br>    &#125; finally &#123;<br>        mainLock.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">tryTerminate</span>();<br><br>    <span class="hljs-keyword">int</span> c = ctl.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-comment">// 条件成立：当前线程池状态为RUNNING 或者 SHUTDOWN状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">runStateLessThan</span>(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>                    <span class="hljs-comment">// min表示线程池最低可以持有的线程数量</span><br>            <span class="hljs-comment">// allowCoreThreadTimeOut == true =&gt; 说明核心线程数内的线程，也会超时被回收 =&gt; min == 0</span><br>            <span class="hljs-comment">// allowCoreThreadTimeOut == false =&gt; min == corePoolSize</span><br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <br>            <span class="hljs-comment">// 线程池状态：RUNNING SHUTDOWN</span><br>            <span class="hljs-comment">// 条件1：假设mid == 0成立</span><br>            <span class="hljs-comment">// 条件2：队列不为空</span><br>            <span class="hljs-comment">// 说明队列中还有任务，起码得留一个线程</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.<span class="hljs-built_in">isEmpty</span>())<br>                min = <span class="hljs-number">1</span>;<br>                <br>            <span class="hljs-comment">// 条件成立： 线程池中还拥有足够的线程时，后续就不需要调用addWorker()了</span><br>            <span class="hljs-comment">// 考虑一个问题： workerCountOf(c) &gt;= min -&gt; (0 &gt;= 0) ？</span><br>            <span class="hljs-comment">// 当线程池中的核心线程数是可以被回收的情况下，会出现这种情况，这种情况下，</span><br>            <span class="hljs-comment">// 当前线程池中的线程数会变为0，下次在提交任务时，会再创建线程。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">workerCountOf</span>(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 来到这里的情况</span><br>        <span class="hljs-comment">// 1.completedAbruptly为true，表示当前线程在执行task时发生异常退出了，这里一定要创建一个新worker顶上去</span><br>        <span class="hljs-comment">// 2.当队列中还有任务时，起码留一个线程，这里就会创建一个线程(worker)</span><br>        <span class="hljs-comment">// 3.当前线程数 &lt; corePoolSize，此时会创建线程，维护线程池数量在corePoolSize个</span><br>        <span class="hljs-built_in">addWorker</span>(null, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后可以看到无论是否为核心线程，都会执行<code>remove</code>的操作，来销毁该线程。</p><h2 id="allowCoreThreadTimeOut-boolean-value"><a href="#allowCoreThreadTimeOut-boolean-value" class="headerlink" title="allowCoreThreadTimeOut(boolean value)"></a>allowCoreThreadTimeOut(boolean value)</h2><p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//允许核心线程池超时之后回收。</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">allowCoreThreadTimeOut</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Core threads must have nonzero keep alive times&quot;</span>);<br>    <span class="hljs-keyword">if</span> (value != allowCoreThreadTimeOut) &#123;<br>        allowCoreThreadTimeOut = value;<br>        <span class="hljs-comment">//能回收</span><br>        <span class="hljs-keyword">if</span> (value)<br>            interruptIdleWorkers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看到<code>allowCoreThreadTimeOut</code>字段在之前也出现过。</p><h2 id="线程池的阻塞队列"><a href="#线程池的阻塞队列" class="headerlink" title="线程池的阻塞队列"></a>线程池的阻塞队列</h2><h2 id="1-有界队列"><a href="#1-有界队列" class="headerlink" title="1.有界队列"></a>1.有界队列</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//基于数组的先进先出（FIFO）队列，支持公平锁和非公平锁，有界</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//基于链表的先进先出（FIFO）队列，默认长度为 Integer.MaxValue 有OOM危险，有界</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;&gt;();<br><br><span class="hljs-comment">//一个由链表结构组成的,双向阻塞队列，有界</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingDeque</span>();<br></code></pre></td></tr></table></figure><h2 id="2-无界队列"><a href="#2-无界队列" class="headerlink" title="2.无界队列"></a>2.无界队列</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//支持优先级排序的无限队列，默认自然排序，可以实现 compareTo()方法指定排序规则，不能保证同优先级元素的顺序，无界。</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">PriorityBlockingQueue</span>();<br><br><span class="hljs-comment">//一个使用优先级队列（PriorityQueue）实现的无界延时队列，在创建时可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">DelayQueue</span>();<br><br><span class="hljs-comment">//一个由链表结构组成的,无界阻塞队列</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedTransferQueue</span>();<br></code></pre></td></tr></table></figure><h2 id="3-同步移交队列"><a href="#3-同步移交队列" class="headerlink" title="3.同步移交队列"></a>3.同步移交队列</h2><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">workQueue</span> = new SynchronousQueue&lt;&gt;()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>无缓冲的等待队列，队列不存元素，每个put操作必须等待take操作，否则无法添加元素，支持公平非公平锁，无界。workQueue 不要使用无界队列，尽量使用有界队列。 避免大量任务等待，造成 OOM。</p><h2 id="线程池四类拒绝策略"><a href="#线程池四类拒绝策略" class="headerlink" title="线程池四类拒绝策略"></a>线程池四类拒绝策略</h2><p>当线程池中的线程和阻塞队列中的任务已经处于饱和状态，线程池则需要执行给定的拒绝策略来拒绝正在提交的任务，ThreadPoolExecutor主要提供了一下四种拒绝策略来拒绝任务。</p><h2 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h2><p>抛出RejectedExecutionException异常拒绝任务提交<br><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">RejectedExecutionHandler</span></span> </span>&#123;<br>    <span class="hljs-keyword">public</span> void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h2><p>什么也不做，直接丢弃任务<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h2><p>将阻塞队列中的任务poll出来，然后执行当前任务<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h2><p>让提交任务的线程来执行任务<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="Excutors的四类线程"><a href="#Excutors的四类线程" class="headerlink" title="Excutors的四类线程"></a>Excutors的四类线程</h2><h2 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1.newCachedThreadPool"></a>1.newCachedThreadPool</h2><p>创建一个可缓存的无界线程池，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程，核心线程数为0。当线程池中的线程空闲时间超过60s，则会自动回收该线程，当任务超过线程池的线程数则创建新的线程，线程池的大小上限为Integer.MAX_VALUE,可看作无限大。</p><p>缺点：使用多少个最大线程，用户是无法控制的。</p><h2 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2.newFixedThreadPool"></a>2.newFixedThreadPool</h2><p>创建一个指定大小的线程池，可控制线程的最大并发数，超出的线程会在LinkedBlockingQueue阻塞队列中等待。</p><h2 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3.newScheduledThreadPool"></a>3.newScheduledThreadPool</h2><p>创建一个定长的线程池，可以指定线程池核心线程数，支持定时及周期性任务的执行。</p><p>方法：</p><ul><li>schedule(Runnable command, long delay, TimeUnit unit)，延迟一定时间后执行Runnable任务；</li><li>schedule(Callable callable, long delay, TimeUnit unit)，延迟一定时间后执行Callable任务；</li><li>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)，延迟一定时间后，以间隔period时间的频率周期性地执行任务；</li><li>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)，与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔。</li></ul><h2 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4.newSingleThreadExecutor"></a>4.newSingleThreadExecutor</h2><p>创建一个单线程化的线程池，它只有一个线程，用仅有的一个线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO，优先级）执行，所有的任务都保存在队列LinkedBlockingQueue中，等待唯一的单线程来执行任务。该方法无参数，所有任务都保存队列LinkedBlockingQueue中，核心线程数为1，线程空闲时间为0。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container"><table><thead><tr><th>工厂方法</th><th>corePoolSize</th><th>maximumPoolSize</th><th>keepAliveTime</th><th>workQueue </th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>60s</td><td>SynchronousQueue</td></tr><tr><td>newFixedThreadPool</td><td>nThreads</td><td>nThreads</td><td>0</td><td>LinkedBlockingQueue</td></tr><tr><td>newScheduledThreadPool</td><td>1</td><td>1</td><td>0</td><td>LinkedBlockingQueue</td></tr><tr><td>newSingleThreadExecutor</td><td>corePoolSize</td><td>Integer.MAX_VALUE</td><td>0</td><td>DelayedWorkQueue</td></tr></tbody></table></div><p>其他参数都相同，其中线程工厂的默认类为DefaultThreadFactory，线程饱和的默认策略为ThreadPoolExecutor.AbortPolicy。</p><h2 id="合理设置线程池参数"><a href="#合理设置线程池参数" class="headerlink" title="合理设置线程池参数"></a>合理设置线程池参数</h2><h2 id="CPU-密集型任务-N-1"><a href="#CPU-密集型任务-N-1" class="headerlink" title="CPU 密集型任务(N+1)"></a>CPU 密集型任务(N+1)</h2><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><h2 id="I-O-密集型任务-2N"><a href="#I-O-密集型任务-2N" class="headerlink" title="I/O 密集型任务(2N)"></a>I/O 密集型任务(2N)</h2><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。 </p><h2 id="如何判断是-CPU-密集任务还是-IO-密集任务？"><a href="#如何判断是-CPU-密集任务还是-IO-密集任务？" class="headerlink" title="如何判断是 CPU 密集任务还是 IO 密集任务？"></a>如何判断是 CPU 密集任务还是 IO 密集任务？</h2><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>]]></content>
    
    
    <summary type="html">线程池</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>GC学习</title>
    <link href="http://example.com/2023/07/01/gc/"/>
    <id>http://example.com/2023/07/01/gc/</id>
    <published>2023-07-01T23:02:35.000Z</published>
    <updated>2023-07-11T03:19:41.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GC 是垃圾回收器的简称，全称是Garbage Collection。<br><strong>Stop The World</strong> 在这里非常重要。当 Stop The World 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到 GC 任务完成。每一代的Java垃圾回收器，都把缩减 Stop The World 停顿时间作为很重要的目标。</p><p>JVM GC只回收<strong>堆区</strong>和<strong>方法区</strong>内的基本类型数据和对象。</p><h2 id="是否允许被回收"><a href="#是否允许被回收" class="headerlink" title="是否允许被回收"></a>是否允许被回收</h2><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>在对象里添加一个被引用的计数器，每当有地方引用了它，计数器就加1，引用失效时，计数器就减1。<br>在触发回收内存的时候，遍历所有对象，把计数器值等于0的找出来，释放掉即可。<br>但是它有个问题，无法回收互相引用的对象！</p><p>所以，市面上主流的Java虚拟机都没有使用这个算法，而是使用可达性分析法做为判断对象是否存活的算法。</p><h2 id="可达性分析法（根搜索算法）"><a href="#可达性分析法（根搜索算法）" class="headerlink" title="可达性分析法（根搜索算法）"></a>可达性分析法（根搜索算法）</h2><p>其实不止是Java，C# 也是使用可达性分析算法来判断对象是否存活的，这个算法也可以称之为根搜索算法。</p><p>基本原理是通过一系列可被作为 GC Roots 的根对象来作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程的就是一条引用链（Reference Chain），没有在这个链条上面的对象，也就是根节点通过引用链不可达到这个对象时，就认为这个对象是可以被回收的。</p><h4 id="哪些对象可以作为根节点呢？"><a href="#哪些对象可以作为根节点呢？" class="headerlink" title="哪些对象可以作为根节点呢？"></a>哪些对象可以作为根节点呢？</h4><blockquote><p>在虚拟机栈帧中引用的对象，例如线程调用方法时，使用或产生的参数、局部变量、临时变量等。<br>在方法区中，类的引用类型静态变量或常量。<br>在本地方法栈中的JNI引用的对象，<br>在JVM内部的对象，例如基本数据类型的Class对象，一些常驻的异常对象（NullPointExcepiton），系统类加载器等。<br>所有synchronized同步锁的持有对象。<br>反映JVM内部情况的JMXBean、JVMTI注册的回调、本地代码缓存等。<br>……</p></blockquote><h2 id="JVM-GC什么时候执行"><a href="#JVM-GC什么时候执行" class="headerlink" title="JVM GC什么时候执行"></a>JVM GC什么时候执行</h2><p>当程序创建一个新的对象或者基本类型的数据，内存空间不足时，会触发GC的执行。</p><h2 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h2><p>大多数的商业虚拟机，都采用分代回收的理论来设计垃圾收集器。既然绝大多数对象都熬不过几次垃圾回收，而熬过多次回收的对象又很难消亡，那么可以根据年龄把它们划分到不同的区域，例如新生代区域和老年代区域，然后分而治之。</p><p>各区域触发垃圾回收的类型与解释：</p><ul><li>Minor GC：只回收新生代区域。</li><li>Major GC：只回收老年代区域。只有CMS实现了Major GC，所以在老年代里，触发GC，除了CMS和G1之外的其他收集器，大多数触发的其实是 Full GC</li><li>Full GC：回收整个堆区和方法区</li><li>Mixed GC：回收整个新生代和部分老年代。G1收集器实现了这个类型。</li></ul><h2 id="新生代（Young-generation）"><a href="#新生代（Young-generation）" class="headerlink" title="新生代（Young generation）"></a>新生代（Young generation）</h2><p>绝大多数新创建的对象都会被分配到这里，这个区域触发的垃圾回收称之为：Minor GC 。</p><p>默认情况下，新生代（Young generation）、老年代（Old generation）所占空间比例为 1 : 2 。</p><p>默认情况下，新生代空间的分配：Eden : Fron : To = 8 : 1 : 1</p><h2 id="新生代GC收集的执行顺序如下"><a href="#新生代GC收集的执行顺序如下" class="headerlink" title="新生代GC收集的执行顺序如下"></a>新生代GC收集的执行顺序如下</h2><ul><li><ol><li>绝大多数新创建的对象会存放在Eden空间。</li></ol></li><li><ol><li>在Eden空间执行第 1 次GC（Minor GC）之后，存活的对象被移动到其中一个幸存者空间（Survivor）。</li></ol></li><li><ol><li>此后每次 Minor GC，都会将 Eden 和 使用中的Survivor 区域中存活的对象，一次性复制到另一块空闲中的Survivor区，然后直接清理 Eden 和 使用过的那块Survivor 空间。</li></ol></li><li><ol><li>从以上空间分配我们知道，Survivor区内存占比很小，当空闲中的Survivor空间不够存放活下来的对象时，这些对象会通过分配担保机制直接进入老年代。</li></ol></li><li><ol><li>在以上步骤中重复N次（N = MaxTenuringThreshold（年龄阀值设定，默认15））依然存活的对象，就会被移动到老年代。</li></ol></li></ul><p>新创建的对象，是保存在Eden空间的。那些经历多次GC依然存活的对象会经由Survivor空间转存到老年代空间（Old generation）。</p><h2 id="老年代（Old-generation）"><a href="#老年代（Old-generation）" class="headerlink" title="老年代（Old generation）"></a>老年代（Old generation）</h2><p>对象在新生代周期中存活了下来的，会被拷贝到这里。通常情况下这个区域分配的空间要比新生代多。正是由于对象经历的GC次数越多越难回收，加上相对大的空间，发生在老年代的GC次数要比新生代少得多。这个区域触发的垃圾回收称之为：Major GC 或者 Full GC</p><p>为什么老年代的回收耗时，比新生代更长</p><ul><li><ol><li>老年代内存占比更大，所以理论上回收的时间也更长</li></ol></li><li><ol><li>老年代使用的是标记-整理算法，清理完成内存后，还得把存活的对象重新排序整理成连续的空间，成本更高</li></ol></li></ul><h2 id="方法区（Method-area）"><a href="#方法区（Method-area）" class="headerlink" title="方法区（Method area）"></a>方法区（Method area）</h2><p>这个区域主要回收废弃的常量和类型，例如常量池里不会再被使用的各种符号引用等等。类型信息的回收相对来说就比较严苛了，必须符合以下3个条件才会被回收：</p><ul><li><ol><li>所有实例被回收</li></ol></li><li><ol><li>加载该类的ClassLoader 被回收</li></ol></li><li><ol><li>Class 对象无法通过任何途径访问（包括反射）</li></ol></li></ul><h2 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h2><p>新生代中的对象很有可能会被老年代里的对象所引用，当新生代触发GC的时候，只搜索新生代的区域明显是不够的，还得搜索老年代的对象是否引用了新生代中非 GC Roots 引用链上的对象，来确保正确性。但这样做会带来很大的性能开销。为了解决这个问题，Java定义了一种名为记忆集的抽象的数据结构，用于记录存在跨区域引用的对象指针集合。</p><p>大多数的虚拟机，都采用一种名为卡表（Card Table）的方式去实现记忆集，卡表由一个数组构成，每一个元素都对应着一块特定大小的内存区域，这块内存区域被称之为卡页（Card Page），每一个卡页，可能会包含N个存在跨区域引用的对象，只要存在跨区域引用的对象，这个卡页就会被标识为1。当GC发生的时候，就不需要扫描整个区域了，只需要把这些被标识为1的卡页加入对应区域的 GC Roots 里一起扫描即可。</p><h2 id="总结整个过程"><a href="#总结整个过程" class="headerlink" title="总结整个过程"></a>总结整个过程</h2><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="/img/Gc/0.png" alt="github"><br>图中大致将各个代说明了一下各个代的关系。</p><p><img src="/img/Gc/1.png" alt="github"><br>上图中则是大致说明了对象后的生命周期</p><ul><li>首先是创建并在新生代eden中</li><li>此时如果发生gc则会判断其大小，如果过大则直接进入老年代，否则就进入s1中</li><li>gc时s1和s2会发生循环往复的复制，其一是用来计算代数，其二是因为这里会经常发生数据调整产生数据碎片导致存储率降低，因此复制调整也是为了减少碎片提高使用率</li><li>而当s1和s2每次换代的时候，就会计算如果超过了阀值则进入老年代</li></ul><h2 id="回收算法讲解"><a href="#回收算法讲解" class="headerlink" title="回收算法讲解"></a>回收算法讲解</h2><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><p>这个算法和它的名字一样，分两个步骤：标记 和 清除。首先标记出所有存活的对象，再扫描整个空间中未被标记的对象直接回收。</p><p>并没有规定标记阶段一定要标记“存活”的对象，也可以标记“可回收”的对象。但是是标记存活的。这样效率高些。<br>首先，Java使用的是可达性分析算法来判断对象是否存活。</p><p>我们假设要标记“可回收”的对象，再进行清除，那么需要三个步骤：</p><ul><li>1、先通过可达性分析法，通过根对象（GC Roots）顺着引用链先把这些存活对象都标出来</li><li>2、遍历这个区域所有对象，把没标记存活的对象，打上一个“可回收”的标记</li><li>3、遍历这个区域所有对象，把标记了“可回收”的对象，释放掉。</li></ul><p>但标记的是“存活”的对象，再进行清除，只需要两个步骤即可：</p><ul><li>1、先通过可达性分析法，通过根对象（GC Roots）顺着引用链先把这些存活对象都标出来</li><li>2、遍历这个区域所有对象，把没标记存活的对象，直接清理掉即可。</li></ul><p>所以，标记“可回收”的对象，会多了一次完全没有必要的遍历。</p><p><img src="/img/Gc/2.png" alt="github"></p><p>可以看到在标记后，就会将未标记的清除掉，但是有一个问题，由于回收后没有进行整理的操作，所以会存在内存空间碎片化的问题。<br>但是反过来想，正是因为没有标记，效率才会高。</p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记 - 复制算法"></a>标记 - 复制算法</h2><p>一个80%的Eden空间和两个10%的Survivor空间。<br>每次分配内存，只使用Eden和其中一块Survivor空间，发生GC回收时，把Eden和其中一块Survivor空间中存活的对象，复制到另一块空闲的Survivor空间，然后直接把Eden和使用过的那块Survivor空间清理掉。</p><p>这个在上面的分代回收机制中已说明。</p><p>目前主流的使用分代回收机制的Java虚拟机，都是使用标记-复制算法来作为新生代的回收算法。它非常适合用在新生代这种回收率极高的场景，这样的场景下，复制算法浪费的空间几乎可以忽略不计。效率高，且内存不会有碎片化的问题。但对于老年代这种存活率很高的场景，就不适合了。</p><p>标记-复制算法还有一个非常重要的知识点，就是分配担保机制。虽然GC新生代里98%的对象都会被回收，但这不是百分之百的几率，极端情况下可能会出现超过10%的对象存活。分配担保机制就是为了保证当出现这种情况时，有其他内存空间来进行兜底。通常这个“担保人”是老年代，当存活的对象超过Survivor空间大小时，这些存活的对象会忽略年龄，直接进入老年代里。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h2><p>标记-清除算法会产生内存碎片，不适合哪些需要大量连续内存空间的场景，而标记-整理算法，就是在其基础之上，增加了整理这个操作，去解决这些内存空间碎片化的问题，</p><p><img src="/img/Gc/3.png" alt="github"></p><p>和标记-清除算法一样，先标记，但清除之前，会先进行整理，把所有存活的对象往内存空间的左边移动，然后清理掉存活对象边界以外的内存，即完成了清除的操作。标记-整理 算法是在 标记-清除 算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><p>老年代里的对象存活率很高，不适合使用标记-复制的算法。而且老年代存储大对象的概率要比新生代大很多，这些大对象需要连续的内存空间来存储，标记-清除这个算法也不适合。所以大多数的老年代都采用标记-整理来作为这个区域的回收算法。</p><h2 id="常用的垃圾回收器"><a href="#常用的垃圾回收器" class="headerlink" title="常用的垃圾回收器"></a>常用的垃圾回收器</h2><p>目前应用范围最广的，应该还是JDK8，它默认使用的是 Parallel Scavenge + Parallelo Old 收集器组合。</p><h2 id="Serial（-XX-UseSerialGC）"><a href="#Serial（-XX-UseSerialGC）" class="headerlink" title="Serial（-XX:+UseSerialGC）"></a>Serial（-XX:+UseSerialGC）</h2><p>Serial 是Java虚拟机初代收集器，在JDK1.3之前是Java虚拟机新生代收集器的唯一选择，这是一个单线程工作的收集器。在进行垃圾回收的时候，需要暂停所有的用户线程，直到回收结束。</p><p>虽然历史久远，但它依然是HotSpot虚拟机运行在客户端模式下，或者4核4GB以下服务端的默认新生代收集器，这种核心数和内存空间较小的场景下，它单线程的优势就体现出来了，没有线程交互的开销，加上内存空间不大，单次回收耗时几十毫秒，这点停顿时间，完全是可以接受的。</p><p>Serial 负责收集新生代区域，它采用标记-复制算法。</p><p><img src="/img/Gc/4.png" alt="github"></p><h2 id="Serial-Old（-XX-UseSerialOldGC）"><a href="#Serial-Old（-XX-UseSerialOldGC）" class="headerlink" title="Serial Old（-XX:+UseSerialOldGC）"></a>Serial Old（-XX:+UseSerialOldGC）</h2><p>SerialOld 是 Serial 收集器的老年代版本，和 Serial 一样，它也是单线程的收集器。目前主要应用在客户端模式（Client VM）下的HotSpot虚拟机使用。</p><p>如果在服务端模式（Server VM）下，它也有两种用途：一个是在JDK5以及之前，和Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器在出现并发模式故障（Concurrent Mode Failure） 时作为后备收集器。</p><p>SerialOld 负责收集老年代区域，它采用标记-整理算法。</p><p><img src="/img/Gc/5.png" alt="github"></p><h2 id="ParNew（-XX-UseParNewGC）"><a href="#ParNew（-XX-UseParNewGC）" class="headerlink" title="ParNew（-XX:+UseParNewGC）"></a>ParNew（-XX:+UseParNewGC）</h2><p>Serial 收集器单线程的性能明显比较落后了，ParNew 就是 在Serial 收集器的基础之上，实现了它的多线程版本。它可以多条线程同时进行垃圾收集，这也是它和 Serial 收集器的最大的区别，其他的功能性、配置、策略等等的和 Serial 基本一致。</p><p>在JDK9之后，Java官方取消了ParNew和除了CMS收集器之外的所有老年代收集器的搭配，而且还取消了 - XX:+UseParNewGC 这个参数。所以JDK9之后，ParNew只能和CMS搭配使用了。</p><p>ParNew 负责收集新生代区域，它采用标记-复制算法。<br><img src="/img/Gc/6.png" alt="github"></p><h2 id="Parallel-Scavenge（-XX-UseParallelGC）"><a href="#Parallel-Scavenge（-XX-UseParallelGC）" class="headerlink" title="Parallel Scavenge（-XX:+UseParallelGC）"></a>Parallel Scavenge（-XX:+UseParallelGC）</h2><p>Parallel Scavenge 从外观上看，和 ParNew 很相似，都是新生代的收集器，支持多线程并行回收，也同样是使用标记-复制来作为回收算法。但 Parallel Scavenge 的关注点不一样，它的目标是实现一个可控制吞吐量的垃圾收集器。</p><p>吞吐量的计算公式：运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)</p><p>Parallel Scavenge 收集器提供了一些参数，给用户按自身需求控制吞吐量：</p><blockquote><p>-XX:MaxGCPauseMillis<br>控制垃圾收集停顿的最大时间，单位是毫秒，可以设置一个大于0的数值。<br>不要想着把这个数值设置得很小来提升垃圾收集的速度，这里缩短的停顿时间是以牺牲新生代空间大小换来的，空间小，回收自然就快，停顿时间自然也短，但是空间小，吞吐量自然也会小。所以得综合考虑。</p><p>-XX:GCTimeRatio<br>设置垃圾收集时间占比的计算因子，参数范围是0 - 100的整数。它的公式是 1 / (1+GCTimeRatio)<br>举个栗子：当设置成15，那就是 1 / (1+15) = 0.0625，就是允许最大垃圾收集时间占总时间的6.25%，当设置成99的时候，就是 1 / (1+99) = 0.01，也就是允许最大垃圾收集时间占总时间的1%，依次类推。</p><p>-XX:+UseAdaptiveSizePolicy<br>动态调整开关，这个参数和 Parallel Scavenge 收集器无关，但是搭配起来使用是一个很好的选择。<br>当这个参数被激活，就不需要人工指定新生代的大小、Eden和Survivor区的比例、对象直接进入老年代的大小等等细节参数了，JVM会根据当前运行的情况动态调整，给出最合适的停顿时间和吞吐量。搭配以上两个参数，和把基本的内存数据设置好即可，例如堆的最大占用空间等等。</p></blockquote><h2 id="Parallel-Old（-XX-UseParallelOldGC）"><a href="#Parallel-Old（-XX-UseParallelOldGC）" class="headerlink" title="Parallel Old（-XX:+UseParallelOldGC）"></a>Parallel Old（-XX:+UseParallelOldGC）</h2><p>就像 Serial Old 是 Serial 的老年代版本一样，Parallel Old 是 Parallel Scavenge 的老年代版本。</p><p>Parallel Old 也支持多线程并行回收的能力，使用标记-整理来作为回收算法。这个收集器是JDK6的时候推出的，和 Parallel Scavenge 搭配，在多CPU核心和大内存的场景下，吞吐性能优秀。</p><p><img src="/img/Gc/7.png" alt="github"><br>在注重吞吐量和多CPU核心的情况下，都可以优先考虑 Parallel Scavenge + Parallelo Old 收集器，这也是JDK8默认的垃圾收集器组合。</p><h2 id="CMS-（-XX-UseConcMarkSweepGC）"><a href="#CMS-（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS （-XX:+UseConcMarkSweepGC）"></a>CMS （-XX:+UseConcMarkSweepGC）</h2><p>CMS（Concurrent Mark Sweep） 是JDK1.4后期推出的GC收集器，它是一款并发低停顿的收集器，对于响应速度有较高要求，对停顿时间忍受度低的应用，非常适合使用CMS作为垃圾收集器。</p><h4 id="CMS-负责收集老年代区域，它采用标记-清除算法。"><a href="#CMS-负责收集老年代区域，它采用标记-清除算法。" class="headerlink" title="CMS 负责收集老年代区域，它采用标记-清除算法。"></a>CMS 负责收集老年代区域，它采用标记-清除算法。</h4><p>它的运行过程相对于前几个来说会复杂一些，可以分为四个步骤：</p><ul><li>1、初始标记（CMS initial mark）<ul><li>这个阶段需要 Stop Tow World（暂停暂停所有用户线程），但这个阶段的速度很快，因为只标记和根节点（GC Roots）直接关联的对象。</li></ul></li><li>2、并发标记（CMS Concurrent mark）<ul><li>这个阶段不需要 Stop Tow World，在初始标记完成后，并发标记从GC Roots直接关联的对象开始，遍历整个引用链，这个阶段耗时较长，但用户线程可以和GC线程一起并发执行。</li></ul></li><li>3、重新标记（CMS remark）<ul><li>这个阶段需要 Stop Tow World，因为并发标记阶段，用户线程和标间线程同时在运行，相当于一边扫地一边丢垃圾，重新标记就是修正用户线程继续运行，导致的变动的那一部分对象。这一阶段的耗时比初始标记长一些，但远没有达到并发标记阶段那么长的时间。这个阶段可以多线程并行标记。</li></ul></li><li>4、并发清理（Concurrent sweep） <ul><li>这个阶段不需要 Stop Tow World，执行到这里，说明标记阶段已经完成，此时遍历整个老年代的内存空间，清理掉可回收的对象，由于不需要移动整理存活的对象，这个阶段可以允许用户线程和回收线程并发执行。在清理完成后，会重置CMS收集器的数据结构，等待下一次垃圾回收。</li></ul></li></ul><p><img src="/img/Gc/8.png" alt="github"><br>以上4个步骤可以看出，CMS之所以能实现低延迟，是因为它把垃圾搜集分成了几个明确的步骤，在一些耗时较长的阶段实现了用户线程和GC线程并发执行的能力。用两次短暂的 Stop Tow World 来代替了其他收集器一整段长时间的 Stop Tow World。</p><h4 id="CMS确实是非常优秀的垃圾收集器，但它也是有缺点的"><a href="#CMS确实是非常优秀的垃圾收集器，但它也是有缺点的" class="headerlink" title="CMS确实是非常优秀的垃圾收集器，但它也是有缺点的"></a>CMS确实是非常优秀的垃圾收集器，但它也是有缺点的</h4><ul><li>1、内存碎片。由于使用了 标记-清理 算法，回收结束后会产生大量不连续的内存空间，也就是内存碎片。</li><li>2、GC进行时会降低吞吐量。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，GC线程肯定会占用一部分计算资源，这个期间会降低一部分吞吐量（尽管这样，也比之前几个收集器好很多）。</li><li>3、浮动垃圾。CMS有两个阶段是可以用户线程和GC线程并发执行的，用户线程的继续执行自然会伴随垃圾的不断产生，这些就是浮动垃圾。这些垃圾只能等下次触发GC的时候才能清除了，也因为这些浮动垃圾的存在，CMS收集器需要留一手，JDK5的时候，在老年代内存空间使用了68%的时候就会触发一次GC，到了JDK6，觉得JDK5的这个设置太保守了，所以调整到了92%。</li></ul><blockquote><p>可以通过-XX:CMSInitiatingOccupancyFraction 调整这个阈值</p></blockquote><h2 id="Garbage-First（G1）"><a href="#Garbage-First（G1）" class="headerlink" title="Garbage First（G1）"></a>Garbage First（G1）</h2><p>G1 是 Garbage First 收集器的简称，它在JDK7的时候立项，JDK8 Update 40的时候才全部完工。这个收集器在JDK9 的时候成为了服务端模式下的默认垃圾收集器。</p><p>G1 收集器的设计理念是：实现一个停顿时间可控的低延迟垃圾收集器</p><p>G1 依然遵循分代回收的设计理论，但它对堆（Java Heap）内存进行了重新布局，不再是简单的按照新生代、老年代分成两个固定大小的区域了，而是把堆区划分成很多个大小相同的区域（Region），新、老年代也不再固定在某个区域了，每一个Region都可以根据运行情况的需要，扮演Eden、Survivor、老年代区域、或者Humongous区域。</p><p>大对象会被存储到Humongous区域，G1大多数情况下会把这个区域当作老年代来看待。如果对象占用空间超过Region的容量，就会存放到N个连续的 Humongous Region 中。</p><p><img src="/img/Gc/9.png" alt="github"></p><p>收集器的运行过程可以大致分成四个步骤：</p><ul><li>初始标记（Initial Marking）- Stop Tow World<ul><li>只标记 GC Roots 能直接关联的对象，还有一些额外的细节操作例如修改TAMS指针的值，保证后续阶段用户程序并发运行的时候，新对象分配在正确的位置。这个阶段需要暂停用户线程，但耗时很短。</li></ul></li><li>并发标记（Concurrent Marking）- No Stop Tow World<ul><li>从根节点（GC Root）开始，顺着引用链遍历整个堆，找出存活的对象。这个步骤耗时较长，但用户线程可以和GC线程并发执行。</li></ul></li><li>最终标记（Final Marking）- Stop Tow World<ul><li>处理并发标记阶段，用户线程继续运行产生的引用变动，这个阶段需要暂停用户线程，支持并行处理。</li></ul></li><li>筛选回收（Live Data Counting and Evacuation）- Stop Tow World<ul><li>根据以上三个阶段标记完成的数据，计算出各个Region的回收价值和成本，再根据用户期望的停顿时间来决定要回收多少个Region。回收使用的是复制算法，把需要回收的这些Region里存活的对象，复制到空闲的Region中，然后清理掉旧Region全部空间。因为需要移动存活的对象，所以不可避免的要暂停用户线程，这个步骤支持多条线程并行回收。</li></ul></li></ul><p><img src="/img/Gc/10.png" alt="github"></p><p>设置停顿时间</p><blockquote><p>-XX:MaxGCPauseMillis 默认值是 200 毫秒<br>首先G1把内存区域分成了若干个相同大小的 Region 区，在执行回收的时候，根据标记阶段统计到的数据，计算出各个 Region 区的回收价值和成本，有了这些数据之后，就可以计算出回收哪几个Region价值最高，且符合用户预期的停顿时间。</p></blockquote>]]></content>
    
    
    <summary type="html">GC学习</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习</title>
    <link href="http://example.com/2023/06/19/jvm/"/>
    <id>http://example.com/2023/06/19/jvm/</id>
    <published>2023-06-19T09:22:35.000Z</published>
    <updated>2023-07-11T03:20:50.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>线程独占:栈,本地方法栈,程序计数器<br>线程共享:堆,方法区</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法 出口等信息.调用方法时执行入栈,方法返回式执行出栈.<br>使用jclasslib工具可以查看class类文件的结构。<br><img src="/img/jvm/7.png" alt="github"></p><p>栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出 stackOverflowError;如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出 OutofMemoryError。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行 Native方法时,程序计数器为空.</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆 没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行 垃圾的回收管理</p><p><img src="/img/jvm/6.png" alt="github"></p><p>若堆的空间不够实例分配，则 OutOfMemoryError。</p><h2 id="方法区-1-8以后为元空间"><a href="#方法区-1-8以后为元空间" class="headerlink" title="方法区(1.8以后为元空间)"></a>方法区(1.8以后为元空间)</h2><p>又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现</p><h2 id="JVM-内存可见性"><a href="#JVM-内存可见性" class="headerlink" title="JVM 内存可见性"></a>JVM 内存可见性</h2><p><img src="/img/jvm/0.png" alt="github"></p><p>JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主 内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.</p><p><img src="/img/jvm/1.png" alt="github"></p><h2 id="类加载与卸载"><a href="#类加载与卸载" class="headerlink" title="类加载与卸载"></a>类加载与卸载</h2><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><p><img src="/img/jvm/2.png" alt="github"></p><p>其中<strong>验证,准备,解析</strong>合称链接</p><ul><li>加载：通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象. </li><li>验证：确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.</li><li>准备：进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变量, 因为final变量在编译时分配.</li><li>解析：将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等. </li><li>初始化：主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用时才会初始化.</li></ul><p>触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用<code>Class.forName</code>反射类的时候,<br>或者某个子类初始化的时候. Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.</p><h4 id="加载机制-双亲委派模式"><a href="#加载机制-双亲委派模式" class="headerlink" title="加载机制-双亲委派模式"></a>加载机制-双亲委派模式</h4><p><img src="/img/jvm/4.png" alt="github"><br>双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载<code>.*</code><br>优点:</p><ol><li>避免类的重复加载</li><li>避免Java的核心API被篡改</li></ol><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObject</span> &#123;</span><br><br>&#125;<br><span class="hljs-comment">//加载该类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    Class clazz = MyObject.class;<br>    System.out.<span class="hljs-built_in">println</span>(clazz.<span class="hljs-built_in">getClassLoader</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">//输出结果<br><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> <span class="hljs-title">name: java.lang</span><br></code></pre></td></tr></table></figure></p><h6 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><strong><em>ClassLoader</em></strong></h6><p>所有的类加载器（除了根类加载器）都必须继承java.lang.ClassLoader。它是一个抽象类，主要的方法如下：</p><ul><li>loadClass：这里就是双亲委托模式的代码实现。只有父类加载器加载不到类时，会调用findClass方法进行类的查找，所以，在定义自己的类加载器时，不要覆盖掉该方法，而应该覆盖掉findClass方法。</li><li>findClass：在自定义类加载器时，一般我们需要覆盖这个方法，且ClassLoader中给出了一个默认的错误实现。</li><li>defineClass：用来将byte字节解析成虚拟机能够识别的Class对象。defineClass()方法通常与findClass()方法一起使用。在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法获取要加载类的字节码，然后调用defineClass()方法生成Class对象。</li><li>resolveClass：连接指定的类，类加载器可以使用此方法来连接类。</li></ul><h6 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a><strong><em>URLClassLoader</em></strong></h6><p>JDK提供了一个更加易用的类加载器URLClassLoader，它扩展了ClassLoader，能够从本地或者网络上指定的位置加载类。我们可以使用该类作为自定义的类加载器使用。</p><ul><li><code>public URLClassLoader(URL[] urls)</code>: 指定要加载的类所在的URL地址，父类加载器默认为系统类加载器。</li><li><code>public URLClassLoader(URL[] urls, ClassLoader parent)</code>：指定要加载的类所在的URL地址，并指定父类加载器。</li></ul><h6 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong><em>自定义类加载器</em></strong></h6><p>我们如果需要自定义类加载器，只需要继承ClassLoader类，并覆盖掉findClass方法即可。<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyFileClassLoader <span class="hljs-keyword">extends</span> ClassLoader &#123;<br>    <span class="hljs-keyword">private</span> String directory;<span class="hljs-comment">//被加载的类所在的目录</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定要加载的类所在的文件目录</span><br><span class="hljs-comment">     * @param directory</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> MyFileClassLoader(String directory,ClassLoader parent)&#123;<br>        <span class="hljs-keyword">super</span>(parent);<br>        <span class="hljs-keyword">this</span>.directory = directory;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">Class</span>&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//把类名转换为目录</span><br>            String <span class="hljs-keyword">file</span> = directory+<span class="hljs-keyword">File</span>.separator+name.replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-keyword">File</span>.separator)+<span class="hljs-string">&quot;.class&quot;</span>;<br>            <span class="hljs-comment">//构建输入流</span><br>            InputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">file</span>);<br>            <span class="hljs-comment">//存放读取到的字节数据</span><br>            ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            <span class="hljs-keyword">byte</span> buf[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>((len=in.<span class="hljs-keyword">read</span>(buf))!=-<span class="hljs-number">1</span>)&#123;<br>                baos.<span class="hljs-keyword">write</span>(buf,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            <span class="hljs-keyword">byte</span> data[] = baos.toByteArray();<br>            in.close();<br>            baos.close();<br>            <span class="hljs-keyword">return</span> defineClass(name,data,<span class="hljs-number">0</span>,data.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br>        MyFileClassLoader myFileClassLoader = <span class="hljs-keyword">new</span> MyFileClassLoader(<span class="hljs-string">&quot;d:/&quot;</span>);<br>        <span class="hljs-keyword">Class</span> clazz = myFileClassLoader.loadClass(<span class="hljs-string">&quot;com.itheima.Demo&quot;</span>);<br>        clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="类的显式与隐式加载"><a href="#类的显式与隐式加载" class="headerlink" title="类的显式与隐式加载"></a><strong><em>类的显式与隐式加载</em></strong></h6><p>类的加载方式是指虚拟机将class文件加载到内存的方式。</p><ul><li>显式加载是指在java代码中通过调用ClassLoader加载class对象，比如Class.forName(String name)；this.getClass().getClassLoader().loadClass()加载类。</li><li>隐式加载指不需要在java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中。比如在加载某个class时，该class引用了另外一个类的对象，那么这个对象的字节码文件就会被虚拟机自动加载到内存中。</li></ul><h6 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a><strong><em>线程上下文类加载器</em></strong></h6><p>在Java中存在着很多的服务提供者接口SPI，全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，这些接口一般由第三方提供实现，常见的SPI有JDBC、JNDI等。这些SPI的接口（比如JDBC中的java.sql.Driver）属于核心类库，一般存在rt.jar包中，由根类加载器加载。<br>而第三方实现的代码一般作为依赖jar包存放在classpath路径下，由于SPI接口中的代码需要加载具体的第三方实现类并调用其相关方法，SPI的接口类是由根类加载器加载的，Bootstrap类加载器无法直接加载位于classpath下的具体实现类。<br>由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载SPI的具体实现类。在这种情况下，java提供了线程上下文类加载器用于解决以上问题。</p><p>线程上下文类加载器可以通过java.lang.Thread的getContextClassLoader()来获取，或者通过setContextClassLoader(ClassLoader cl)来设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader），在线程中运行的代码可以通过此类加载器来加载类或资源。</p><p>显然这种加载类的方式破坏了双亲委托模型，但它使得java类加载器变得更加灵活。<br><img src="/img/jvm/5.png" alt="github"><br>我们以JDBC中的类为例做一下说明。在JDBC中有一个类java.sql.DriverManager，它是rt.jar中的类，用来注册实现了java.sql.Driver接口的驱动类，而java.sql.Driver的实现类一般都是位于数据库的驱动jar包中的。</p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间.</p><div class="table-container"><table><thead><tr><th>堆分代</th><th></th><th></th></tr></thead><tbody><tr><td>年轻代</td><td>Dden</td><td>Survivor1</td><td>Survivor2</td></tr><tr><td>老年代</td><td>Tenured</td><td>Tenured</td><td>Tenured</td></tr><tr><td>永久代</td><td>Prem/MetaSpcae</td><td>Prem/MetaSpcae</td><td>Prem/MetaSpcae</td></tr></tbody></table></div><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><h6 id="1-G1算法"><a href="#1-G1算法" class="headerlink" title="1.G1算法"></a>1.G1算法</h6><p>1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的 增量式清理,以保证停顿时间不会过长<br>其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分 用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.<br>同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间. </p><p>年轻代回收:并行复制采用复制算法,并行收集,会StopTheWorld.<br>老年代回收:会对年轻代一并回收</p><p>初始标记完成堆root对象的标记,会StopTheWorld.<br>并发标记 GC线程和应用线程并发执行.<br>最终标记完成三色标记周期,会StopTheWorld.<br>复制/清楚会优先对可回收空间加大的区域进行回收</p><h6 id="2-ZGC算法"><a href="#2-ZGC算法" class="headerlink" title="2.ZGC算法"></a>2.ZGC算法</h6><p>前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间.</p><p>什么时候会触发FullGC<br>-<br>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p><h2 id="1-旧生代空间不足"><a href="#1-旧生代空间不足" class="headerlink" title="1. 旧生代空间不足"></a>1. 旧生代空间不足</h2><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误:java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p><h2 id="2-Permanet-Generation空间满"><a href="#2-Permanet-Generation空间满" class="headerlink" title="2. Permanet Generation空间满"></a>2. Permanet Generation空间满</h2><p>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较 多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经 过Full GC仍然回收不了，那么JVM会抛出如下错误信息:java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p><h2 id="3-CMS-GC时出现promotion-failed和concurrent-mode-failure"><a href="#3-CMS-GC时出现promotion-failed和concurrent-mode-failure" class="headerlink" title="3. CMS GC时出现promotion failed和concurrent mode failure"></a>3. CMS GC时出现promotion failed和concurrent mode failure</h2><p>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。<br>promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代 也放不下造成的;concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此 时旧生代空间不足造成的。 应对措施为:增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本 中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可 通过设置-XX:CMSMaxAbortablePrecleanTime=5(单位为ms)来避免。</p><h2 id="4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间"><a href="#4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间" class="headerlink" title="4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间"></a>4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</h2><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的 现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小 大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先 检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。 当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次 Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。 除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一 次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的 间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p><h2 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h2><ul><li>当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据 读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载 完成后，Class对象还不完整，所以此时的类还不可用。</li><li>当类被加载后就进入连接阶段，这一阶段包括 验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。</li><li>最后JVM对类进行初始化，包括:1)如果类存在直接的父类并且这个类还没有被初始化，那么就先 初始化父类;2)如果类中存在初始化语句，就依次执行这些初始化语句。 </li><li>类的加载是由类加载器完成的,类的加载首先请求父类加载器加载，父类加载器 无能为力时才由其子类加载器自行加载。</li></ul><h2 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h2><ul><li>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类(类加载过程在后边讲)</li><li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li><li>将除对象头外的对象内存空间初始化为0</li><li>对对象头进行必要设置</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>连接，连接又包含三块内容:验证、准备、初始化。 <ul><li>1)验证，文件格式、元数据、字节码、符号 引用验证; </li><li>2)准备，为类的静态变量分配内存，并将其初始化为默认值; </li><li>3)解析，把类中的符 号引用转换为直接引用</li></ul></li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><h2 id="Java的对象结构"><a href="#Java的对象结构" class="headerlink" title="Java的对象结构"></a>Java的对象结构</h2><p>Java对象由三个部分组成:对象头、实例数据、对齐填充。</p><ul><li>对象头由两部分组成，第一部分存储对象自身的运行时数据:哈希码、GC分代年龄、锁标识状态、线 程持有的锁、偏向线程ID(一般占32/64 bit)。第二部分是指针类型，指向对象的类元数据类型(即对 象代表哪个类)。如果是数组对象，则对象头中还有一部分用来记录数组长度。</li><li>实例数据用来存储对象真正的有效信息(包括父类继承下来的和自己定义的)</li><li>对齐填充:JVM要求对象起始地址必须是8字节的整数倍(8字节对齐)</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>GC最基础的算法有三种: 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p><ul><li>标记 -清除算法，“标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分为“标记”和“清除”两 个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li><li>复制算法，“复制”(Copying)的收集算法，它将可用内存按容量划分为大小相等的两块，每次只 使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已 使用过的内存空间一次清理掉。</li><li>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清 理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li><li>分代收集算法，“分代收集”(Generational Collection)算法，把Java堆分为新生代和老年代，这 样就可以根据各个年代的特点采用最适当的收集算法。</li></ul><h2 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h2><ul><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机 进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了 一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 </li><li>jstack，用于生成java虚拟机当前时刻的线程快照。</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><p>常用调优工具分为两类,jdk自带监控工具:jconsole和jvisualvm，第三方有:MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控 和管理控制台，用于对JVM中内存，线程和类等的监控 </li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照;监控内存变化、GC变化等。 </li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 </li><li>GChisto，一款专业分析gc日志的工具</li></ul><h2 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h2><p>设定堆内存大小 </p><ul><li>-Xmx:堆内存最大限制。<br>设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代 </li><li>-XX:NewSize:新生代大小</li><li>-XX:NewRatio 新生代和老生代占比 </li><li>-XX:SurvivorRatio:伊甸园空间和幸存者空间的占比</li></ul><p>设定垃圾回收器 年轻代用 </p><ul><li>-XX:+UseParNewGC </li></ul><p>年老代用</p><ul><li>-XX:+UseConcMarkSweepGC</li></ul><p>PermSpace 和 MetaSpace<br>-<br>JDK 1.8后用元空间替代了 Perm Space;字符串常量存放到堆内存中。<br>MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。</p><ul><li>-XX:MetaspaceSize:分配给类元数据空间(以字节计)的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark)。此值为估计值，MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。 </li><li>-XX:MaxMetaspaceSize:分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li></ul>]]></content>
    
    
    <summary type="html">jvm学习</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <link href="http://example.com/2023/06/09/lambada/"/>
    <id>http://example.com/2023/06/09/lambada/</id>
    <published>2023-06-09T09:22:35.000Z</published>
    <updated>2023-06-13T08:07:59.534Z</updated>
    
    <content type="html"><![CDATA[<p>在Java8支持Lambda表达式以后，为了满足Lambda表达式的一些典型使用场景，JDK为我们提供了大量常用的函数式接口。它们主要在 <code>java.util.function</code> 包中，下面简单介绍几个其中的接口及其使用示例。</p><h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><p>Supplier接口是对象实例的提供者，定义了一个名叫get的抽象方法，它没有任何入参，并返回一个泛型T对象。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> java.util.<span class="hljs-keyword">function</span>;<br><br>@FunctionalInterface<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T <span class="hljs-keyword">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">Supplier&lt;<span class="hljs-built_in">String</span>&gt; stringCallable = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><br>这里的<code>lambda</code>声明了一个<code>Supplier</code>的实例。<br>它提供了一个<code>get</code>方法，来获取里面得到数值。<br><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">String</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = stringCallable.get();</span><br></code></pre></td></tr></table></figure></p><h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><p><code>Consumer</code>接口是一个类似消费者的接口，定义了一个名叫<code>accept</code>的抽象方法，它的入参是一个泛型T对象，没有任何返回（void），主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">final Consumer&lt;<span class="hljs-built_in">String</span>&gt; stringConsumer = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> data)</span> -&gt;</span> &#123;&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><p><code>Predicate</code>接口是判断是与否的接口，定义了一个名叫<code>test</code>的抽象方法，它的入参是一个泛型T对象，并返回一个<code>boolean</code>类型，主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">final Predicate&lt;<span class="hljs-built_in">String</span>&gt; stringFilter = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> data)</span> -&gt;</span> data.isEmpty();<br></code></pre></td></tr></table></figure></p><h2 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h2><p><code>Function</code>接口是对实例进行处理转换的接口，定义了一个名叫<code>apply</code>的抽象方法，它的入参是一个泛型T对象，并返回一个泛型R对象，主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">final <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; stringIntegerFunction = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> data)</span> -&gt;</span> <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p><h2 id="BiFunction接口"><a href="#BiFunction接口" class="headerlink" title="BiFunction接口"></a>BiFunction接口</h2><p><code>Function</code>接口的入参只有一个泛型对象，JDK还为我们提供了两个泛型对象入参的接口：<code>BiFunction</code>接口，主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BiFunction</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t, U u)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">final</span> BiFunction&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>, <span class="hljs-keyword">Double</span>&gt; stringIntegerDoubleBiFunction = (<span class="hljs-keyword">String</span> data, <span class="hljs-keyword">Integer</span> item) -&gt; <span class="hljs-keyword">Double</span>.parseDouble(item.toString());<br></code></pre></td></tr></table></figure></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>以上介绍的几个常用的函数式接口入参和返回，都是泛型对象的，也就是必须为引用类型。当我们传入或获取的是基本数据类型时，将会发生自动装箱和自动拆箱，带来不必要的性能损耗。</p><p>JDK为我们提供相应的函数式接口，如<code>LongSupplier</code>接口，定义了一个名叫getAsLong的抽象方法，签名是<code>() -&gt; long</code>。</p><h3 id="Supplier相关的接口"><a href="#Supplier相关的接口" class="headerlink" title="Supplier相关的接口"></a>Supplier相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Supplier</td><td>get</td><td><code>() -&gt; T</code></td></tr><tr><td>BooleanSupplier</td><td>getAsBoolean</td><td><code>() -&gt; boolean</code></td></tr><tr><td>DoubleSupplier</td><td>getAsDouble</td><td><code>() -&gt; double</code></td></tr><tr><td>IntSupplier</td><td>getAsInt</td><td><code>() -&gt; int</code></td></tr><tr><td>LongSupplier</td><td>getAsLong</td><td><code>() -&gt; long</code></td></tr></tbody></table></div><h3 id="Consumer相关的接口"><a href="#Consumer相关的接口" class="headerlink" title="Consumer相关的接口"></a>Consumer相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Consumer</td><td>accept</td><td><code>(T) -&gt; void</code></td></tr><tr><td>DoubleConsumer</td><td>accept</td><td><code>(double) -&gt; void</code></td></tr><tr><td>IntConsumer</td><td>accept</td><td><code>(int) -&gt; void</code></td></tr><tr><td>LongConsumer</td><td>accept</td><td><code>(long) -&gt; void</code></td></tr><tr><td>ObjDoubleConsumer</td><td>accept</td><td><code>(T, double) -&gt; void</code></td></tr><tr><td>ObjIntConsumer</td><td>accept</td><td><code>(T, int) -&gt; void</code></td></tr><tr><td>ObjLongConsumer</td><td>accept</td><td><code>(T, long) -&gt; void</code></td></tr></tbody></table></div><h3 id="Predicate相关的接口"><a href="#Predicate相关的接口" class="headerlink" title="Predicate相关的接口"></a>Predicate相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Predicate</td><td>test</td><td><code>(T) -&gt; boolean</code></td></tr><tr><td>BiPredicate</td><td>test</td><td><code>(T, U) -&gt; boolean</code></td></tr><tr><td>DoublePredicate</td><td>test</td><td><code>(double) -&gt; boolean</code></td></tr><tr><td>IntPredicate</td><td>test</td><td><code>(int) -&gt; boolean</code></td></tr><tr><td>LongPredicate</td><td>test</td><td><code>(long) -&gt; boolean</code></td></tr></tbody></table></div><h3 id="Function相关的接口"><a href="#Function相关的接口" class="headerlink" title="Function相关的接口"></a>Function相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Function</td><td>apply</td><td><code>(T) -&gt; R</code></td></tr><tr><td>BiFunction</td><td>apply</td><td><code>(T, U) -&gt; R</code></td></tr><tr><td>DoubleFunction</td><td>apply</td><td><code>(double) -&gt; R</code></td></tr><tr><td>DoubleToIntFunction</td><td>applyAsInt</td><td><code>(double) -&gt; int</code></td></tr><tr><td>DoubleToLongFunction</td><td>applyAsLong</td><td><code>(double) -&gt; long</code></td></tr><tr><td>IntFunction</td><td>apply</td><td><code>(int) -&gt; R</code></td></tr><tr><td>IntToDoubleFunction</td><td>applyAsDouble</td><td><code>(int) -&gt; double</code></td></tr><tr><td>IntToLongFunction</td><td>applyAsLong</td><td><code>(int) -&gt; long</code></td></tr><tr><td>LongFunction</td><td>apply</td><td><code>(long) -&gt; R</code></td></tr><tr><td>LongToDoubleFunction</td><td>applyAsDouble</td><td><code>(long) -&gt; double</code></td></tr><tr><td>LongToIntFunction</td><td>applyAsInt</td><td><code>(long) -&gt; int</code></td></tr><tr><td>ToDoubleFunction</td><td>applyAsDouble</td><td><code>(T) -&gt; double</code></td></tr><tr><td>ToDoubleBiFunction</td><td>applyAsDouble</td><td><code>(T, U) -&gt; double</code></td></tr><tr><td>ToIntFunction</td><td>applyAsInt</td><td><code>(T) -&gt; int</code></td></tr><tr><td>ToIntBiFunction</td><td>applyAsInt</td><td><code>(T, U) -&gt; int</code></td></tr><tr><td>ToLongFunction</td><td>applyAsLong</td><td><code>(T) -&gt; long</code></td></tr><tr><td>ToLongBiFunction</td><td>applyAsLong</td><td><code>(T, U) -&gt; long</code></td></tr></tbody></table></div><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。</p><h2 id="Java8内置了一些常用的方法接口FunctionalInterface"><a href="#Java8内置了一些常用的方法接口FunctionalInterface" class="headerlink" title="Java8内置了一些常用的方法接口FunctionalInterface"></a>Java8内置了一些常用的方法接口FunctionalInterface</h2><p>这种接口只定义了一个抽象方法，并且用<code>@FunctionalInterface</code>注解标记，如Predicate,Consumer,Function,Supplier,Comparator等等，这些都属于<code>java.util.function</code>包中<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br><span class="hljs-comment">// 省略不贴了</span><br></code></pre></td></tr></table></figure><br>在使用时，传入<code>类名::实例方法名</code>实现的效果是等价的</p>]]></content>
    
    
    <summary type="html">lambda表达式</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java Stream管道数据处理操作</title>
    <link href="http://example.com/2023/06/09/javaStream/"/>
    <id>http://example.com/2023/06/09/javaStream/</id>
    <published>2023-06-09T09:22:35.000Z</published>
    <updated>2023-06-13T14:49:53.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-Stream管道数据处理操作"><a href="#Java-Stream管道数据处理操作" class="headerlink" title="Java Stream管道数据处理操作"></a>Java Stream管道数据处理操作</h2><p>在使用的过程中分为三个阶段。<br><img src="/img/JavaStream/0.png" alt="github"></p><ul><li>第一阶段(图中蓝色)：将集合、数组、或行文本文件转换为java Stream管道流</li><li>第二阶段(图中虚线部分)：管道流式数据处理操作，处理管道中的每一个元素。上一个管道中的输出元素作为下一个管道的输入元素。</li><li>第三阶段(图中绿色)：管道流结果处理操作。</li></ul><p>中间操作可分为：</p><ul><li>无状态（Stateless）操作：指元素的处理不受之前元素的影响</li><li>有状态（Stateful）操作：指该操作只有拿到所有元素之后才能继续下去</li></ul><p>终结操作可分为：</p><ul><li>短路（Short-circuiting）操作：指遇到某些符合条件的元素就可以得到最终结果</li><li>非短路（Unshort-circuiting）操作：指必须处理完所有元素才能得到最终结果</li></ul><p><img src="/img/JavaStream/1.png" alt="github"></p><h2 id="Stream-构成与创建"><a href="#Stream-构成与创建" class="headerlink" title="Stream 构成与创建"></a>Stream 构成与创建</h2><h3 id="java-util-Collection-stream-方法用集合创建流"><a href="#java-util-Collection-stream-方法用集合创建流" class="headerlink" title="java.util.Collection.stream() 方法用集合创建流"></a>java.util.Collection.stream() 方法用集合创建流</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">List&lt;<span class="hljs-keyword">String</span>&gt; list = Arrays.<span class="hljs-built_in">asList</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;stream&quot;</span>);<br><span class="hljs-comment">//创建顺序流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = list.<span class="hljs-built_in">stream</span>();<br><span class="hljs-comment">//创建并行流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; parallelStream = list.<span class="hljs-built_in">parallelStream</span>();<br></code></pre></td></tr></table></figure><h3 id="java-util-Arrays-stream-T-array-方法用数组创建流"><a href="#java-util-Arrays-stream-T-array-方法用数组创建流" class="headerlink" title="java.util.Arrays.stream(T[] array)方法用数组创建流"></a>java.util.Arrays.stream(T[] array)方法用数组创建流</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span>[] array = &#123;<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;;<br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; arrayStream = Arrays.<span class="hljs-built_in">stream</span>(array);<br></code></pre></td></tr></table></figure><h3 id="Stream的静态方法：of-、iterate-、generate"><a href="#Stream的静态方法：of-、iterate-、generate" class="headerlink" title="Stream的静态方法：of()、iterate()、generate()"></a>Stream的静态方法：of()、iterate()、generate()</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">Stream&lt;Integer&gt; stream1 = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br> <br>Stream&lt;Integer&gt; stream2 = Stream.iterate<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>)</span>.<span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">stream2</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(System.out::println)</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-title">Stream</span>&lt;<span class="hljs-title">Double</span>&gt; <span class="hljs-title">stream3</span> = <span class="hljs-title">Stream</span>.<span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-built_in">Math</span>::random)</span>.<span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">stream3</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(System.out::println)</span></span><br></code></pre></td></tr></table></figure><h3 id="stream和parallelStream的简单区分"><a href="#stream和parallelStream的简单区分" class="headerlink" title="stream和parallelStream的简单区分"></a>stream和parallelStream的简单区分</h3><p>tream是顺序流，由主线程按顺序对流执行操作，而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，需要注意使用并行流的前提是流中的数据处理没有顺序要求（会乱序，即使用了forEachOrdered）。</p><p>除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">Optional&lt;Integer&gt; findFirst = list.stream<span class="hljs-params">()</span><span class="hljs-string">.parallel</span><span class="hljs-params">()</span><span class="hljs-string">.filter</span><span class="hljs-params">(x-&gt;x&gt;4)</span><span class="hljs-string">.findFirst</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></p><h2 id="无状态（Stateless）操作"><a href="#无状态（Stateless）操作" class="headerlink" title="无状态（Stateless）操作"></a>无状态（Stateless）操作</h2><h3 id="filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。"><a href="#filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。" class="headerlink" title="filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。"></a>filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; filter(<span class="hljs-type">Predicate</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; predicate);<br></code></pre></td></tr></table></figure><h3 id="映射-map、flatMap、peek"><a href="#映射-map、flatMap、peek" class="headerlink" title="映射(map、flatMap、peek)"></a>映射(map、flatMap、peek)</h3><h5 id="map：一个元素类型为-T-的流转换成元素类型为-R-的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；"><a href="#map：一个元素类型为-T-的流转换成元素类型为-R-的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；" class="headerlink" title="map：一个元素类型为 T 的流转换成元素类型为 R 的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；"></a>map：一个元素类型为 T 的流转换成元素类型为 R 的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；</h5><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-keyword">map</span>(<span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> R&gt; mapper);<br></code></pre></td></tr></table></figure><h5 id="flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。"><a href="#flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。" class="headerlink" title="flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。"></a>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</h5><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">R</span>&gt;</span> Stream<span class="hljs-tag">&lt;<span class="hljs-name">R</span>&gt;</span> flatMap(Function</span><span class="php"><span class="hljs-meta">&lt;?</span> super T, ? <span class="hljs-keyword">extends</span> Stream<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> R&gt;&gt; mapper)</span><br></code></pre></td></tr></table></figure><p>例子：<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">List&lt;<span class="hljs-keyword">String</span>&gt; list1 = Arrays.asList(<span class="hljs-string">&quot;m,k,l,a&quot;</span>, <span class="hljs-string">&quot;1,3,5,7&quot;</span>);<br>List&lt;<span class="hljs-keyword">String</span>&gt; listNew = list1.stream().flatMap(s -&gt; &#123;<br>    <span class="hljs-comment">// 将每个元素转换成一个stream</span><br>    <span class="hljs-keyword">String</span>[] <span class="hljs-built_in">split</span> = s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>    Stream&lt;<span class="hljs-keyword">String</span>&gt; s2 = Arrays.stream(<span class="hljs-built_in">split</span>);<br>    <span class="hljs-keyword">return</span> s2;<br>&#125;).collect(Collectors.toList());<br></code></pre></td></tr></table></figure></p><h5 id="peek：peek-操作接收的是一个-Consumer-函数。顾名思义-peek-操作会按照-Consumer-函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。"><a href="#peek：peek-操作接收的是一个-Consumer-函数。顾名思义-peek-操作会按照-Consumer-函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。" class="headerlink" title="peek：peek 操作接收的是一个 Consumer 函数。顾名思义 peek 操作会按照 Consumer 函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。"></a>peek：peek 操作接收的是一个 Consumer<T> 函数。顾名思义 peek 操作会按照 Consumer<T> 函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。</h5><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; peek(<span class="hljs-type">Consumer</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; action);<br></code></pre></td></tr></table></figure><p>这里因为<code>peek</code>是中间操作层，因此如果以他结尾，则无法完成事件消费。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;felord.cn&quot;</span>);<br>stream.peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println);<br><br>Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;felord.cn&quot;</span>);<br>stream.peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure></p><h5 id="peek-AND-map"><a href="#peek-AND-map" class="headerlink" title="peek AND map"></a>peek AND map</h5><ul><li>peek 操作 一般用于不想改变流中元素本身的类型或者只想元素的内部状态时；</li><li>map 则用于改变流中元素本身类型，即从元素中派生出另一种类型的操作。</li></ul><h5 id="mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong"><a href="#mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong" class="headerlink" title="mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong"></a>mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong</h5><p>以上这些操作是map和flatMap的特例版，也就是针对特定的数据类型进行映射处理。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">IntStream map<span class="hljs-constructor">ToInt(ToIntFunction&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">mapper</span>)</span>;<br>LongStream map<span class="hljs-constructor">ToLong(ToLongFunction&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">mapper</span>)</span>; <br>DoubleStream map<span class="hljs-constructor">ToDouble(ToDoubleFunction&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">mapper</span>)</span>;<br>IntStream flat<span class="hljs-constructor">MapToInt(Function&lt;? <span class="hljs-params">super</span> T, ? <span class="hljs-params">extends</span> IntStream&gt; <span class="hljs-params">mapper</span>)</span>;<br>LongStream flat<span class="hljs-constructor">MapToLong(Function&lt;? <span class="hljs-params">super</span> T, ? <span class="hljs-params">extends</span> LongStream&gt; <span class="hljs-params">mapper</span>)</span>;<br>DoubleStream flat<span class="hljs-constructor">MapToDouble(Function&lt;? <span class="hljs-params">super</span> T, ? <span class="hljs-params">extends</span> DoubleStream&gt; <span class="hljs-params">mapper</span>)</span>;<br></code></pre></td></tr></table></figure></p><h3 id="无序化（unordered）"><a href="#无序化（unordered）" class="headerlink" title="无序化（unordered）"></a>无序化（unordered）</h3><p><code>unordered()</code>操作不会执行任何操作来显式地对流进行排序。它的作用是消除了流必须保持有序的约束，从而允许后续操作使用不必考虑排序的优化。</p><blockquote><p>对于顺序流，顺序的存在与否不会影响性能，只影响确定性。如果流是顺序的，则在相同的源上重复执行相同的流管道将产生相同的结果;<br>如果是非顺序流，重复执行可能会产生不同的结果。 对于并行流，放宽排序约束有时可以实现更高效的执行。<br>在流有序时, 但用户不特别关心该顺序的情况下，使用 unordered 明确地对流进行去除有序约束可以改善某些有状态或终端操作的并行性能。</p></blockquote><h2 id="有状态（Stateful）操作"><a href="#有状态（Stateful）操作" class="headerlink" title="有状态（Stateful）操作"></a>有状态（Stateful）操作</h2><h3 id="distinct：返回由该流的不同元素组成的流（根据-Object-equals-Object-）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。"><a href="#distinct：返回由该流的不同元素组成的流（根据-Object-equals-Object-）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。" class="headerlink" title="distinct：返回由该流的不同元素组成的流（根据 Object.equals(Object)）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。"></a>distinct：返回由该流的不同元素组成的流（根据 Object.equals(Object)）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">distinct</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><strong>就是去重</strong></p><h3 id="sorted：返回由该流的元素组成的流，并根据自然顺序排序"><a href="#sorted：返回由该流的元素组成的流，并根据自然顺序排序" class="headerlink" title="sorted：返回由该流的元素组成的流，并根据自然顺序排序"></a>sorted：返回由该流的元素组成的流，并根据自然顺序排序</h3><p>该接口有两种形式：无参和有参数<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(Comparator&lt;? super T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><br>那区别其实就在于：<code>传入比较器的参数，可以自定义这个比较器，即自定义比较规则。</code></p><h3 id="limit：获取流中n个元素返回的流"><a href="#limit：获取流中n个元素返回的流" class="headerlink" title="limit：获取流中n个元素返回的流"></a>limit：获取流中n个元素返回的流</h3><p>mysql的中的limit函数一样的效果，返回指定个数的元素流。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br></code></pre></td></tr></table></figure></p><h3 id="skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。"><a href="#skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。" class="headerlink" title="skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。"></a>skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。</h3><p>跳过第n个元素，返回其后面的元素流；<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure></p><h2 id="短路（Short-circuiting）操作"><a href="#短路（Short-circuiting）操作" class="headerlink" title="短路（Short-circuiting）操作"></a>短路（Short-circuiting）操作</h2><h3 id="anyMatch：Stream-中只要有一个元素符合传入的-predicate，返回-true"><a href="#anyMatch：Stream-中只要有一个元素符合传入的-predicate，返回-true" class="headerlink" title="anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true;"></a>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true;</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">anyMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="allMatch：Stream-中全部元素符合传入的-predicate，返回-true"><a href="#allMatch：Stream-中全部元素符合传入的-predicate，返回-true" class="headerlink" title="allMatch：Stream 中全部元素符合传入的 predicate，返回 true;"></a>allMatch：Stream 中全部元素符合传入的 predicate，返回 true;</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="noneMatch：Stream-中没有一个元素符合传入的-predicate，返回-true"><a href="#noneMatch：Stream-中没有一个元素符合传入的-predicate，返回-true" class="headerlink" title="noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true."></a>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true.</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">noneMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）"><a href="#findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）" class="headerlink" title="findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）"></a>findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Optional&lt;T&gt; findFirst()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）"><a href="#findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）" class="headerlink" title="findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）"></a>findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Optional&lt;T&gt; findAny()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>findAny会每次按顺序返回第一个元素。那这个时候，可能会认为findAny与findFirst方法是一样的效果。其实不然，findAny()操作，返回的元素是不确定的，对于同一个列表多次调用findAny()有可能会返回不同的值。使用findAny()是为了更高效的性能。如果是数据较少，串行地情况下，一般会返回第一个结果，如果是并行的情况，那就不能确保是第一个。</p><h2 id="非短路（Unshort-circuiting）操作"><a href="#非短路（Unshort-circuiting）操作" class="headerlink" title="非短路（Unshort-circuiting）操作"></a>非短路（Unshort-circuiting）操作</h2><h3 id="forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式"><a href="#forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式" class="headerlink" title="forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式"></a>forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>不同于普通的for循环，他在接收外部参数的时候，要求外部变量必须是最终的，不可变的，所以如果我们想要对其进行修改，那是不可能的！如果必须这么使用，可以将外部变量，移至表达式之中使用才行！<br>或者使用原子类来包装这些需要改变的外部参数。</p><h3 id="forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式"><a href="#forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式" class="headerlink" title="forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式"></a>forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEachOrdered</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>该功能其实和forEach是很相似的，也是循环操作！那唯一的区别，就在于forEachOrdered是可以保证循环时元素是按原来的顺序逐个循环的！</p><p>有的时候，forEachOrdered也是不能百分百保证有序！<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;AAA,&quot;</span>,<span class="hljs-string">&quot;BBB,&quot;</span>,<span class="hljs-string">&quot;CCC,&quot;</span>,<span class="hljs-string">&quot;DDD,&quot;</span>).parallel<span class="hljs-literal">()</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">print</span>)</span>;<br></code></pre></td></tr></table></figure><br>在并行流时，由于是多线程处理，其实还是无法保证有序操作的！</p><h3 id="toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组"><a href="#toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组" class="headerlink" title="toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组"></a>toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Object</span> <span class="hljs-selector-attr">[]</span> toArray();<br>&lt;<span class="hljs-selector-tag">A</span>&gt; <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[]</span> toArray(IntFunction&lt;<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[]</span>&gt; generator);<br></code></pre></td></tr></table></figure><h3 id="reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值"><a href="#reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值" class="headerlink" title="reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值"></a>reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</h3><figure class="highlight bnf"><table><tr><td class="code"><pre><code class="hljs bnf"><br>Optional<span class="hljs-attribute">&lt;T&gt;</span> reduce(BinaryOperator<span class="hljs-attribute">&lt;T&gt;</span> accumulator);<br> <br>T reduce(T identity, BinaryOperator<span class="hljs-attribute">&lt;T&gt;</span> accumulator);<br> <br><span class="hljs-attribute">&lt;U&gt;</span> U reduce(U identity,BiFunction<span class="hljs-attribute">&lt;U, ? super T, U&gt;</span> accumulator,BinaryOperator<span class="hljs-attribute">&lt;U&gt;</span> combiner);<br></code></pre></td></tr></table></figure><ul><li>1个参数：累加处理的纯函数</li><li>2个参数：基础上增加一个基础值</li><li>3个参数：在基础上，增加了一个针对并行流的一个纯函数，组合器的作用，是对参数2中的数据进行处理，产生的结果进行一次合并器处理。</li></ul><h3 id="collect：称为收集器，是一个终端操作-它接收的参数是将流中的元素累积到汇总结果的各种方式"><a href="#collect：称为收集器，是一个终端操作-它接收的参数是将流中的元素累积到汇总结果的各种方式" class="headerlink" title="collect：称为收集器，是一个终端操作,它接收的参数是将流中的元素累积到汇总结果的各种方式"></a>collect：称为收集器，是一个终端操作,它接收的参数是将流中的元素累积到汇总结果的各种方式</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">&lt;<span class="hljs-built_in">R</span>, A&gt; <span class="hljs-built_in">R</span> collect(Collector&lt;? super T, A, <span class="hljs-built_in">R</span>&gt; collector);<br> <br>&lt;<span class="hljs-built_in">R</span>&gt; <span class="hljs-built_in">R</span> collect(Supplier&lt;<span class="hljs-built_in">R</span>&gt; supplier,<br>                  BiConsumer&lt;<span class="hljs-built_in">R</span>, ? super T&gt; accumulator,<br>                  BiConsumer&lt;<span class="hljs-built_in">R</span>, <span class="hljs-built_in">R</span>&gt; combiner);<br></code></pre></td></tr></table></figure><p>第一种方式会比较经常使用到，也比较方便使用，现在先看一看里面常用的一些方法：</p><div class="table-container"><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>用于</th></tr></thead><tbody><tr><td>toList</td><td><code>List&lt;T&gt;</code></td><td>把流中所有元素收集到List中</td></tr><tr><td>toSet</td><td><code>Set&lt;T&gt;</code></td><td>把流中所有元素收集到Set中,删除重复项</td></tr><tr><td>toCollection</td><td><code>Collection&lt;T&gt;</code></td><td>把流中所有元素收集到给定的供应源创建的集合中</td></tr><tr><td>Counting</td><td>Long</td><td>计算流中元素个数</td></tr><tr><td>SummingInt</td><td>Integer</td><td>对流中元素的一个整数属性求和</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素integer属性的平均值</td></tr><tr><td>Joining</td><td>String</td><td>连接流中每个元素的toString方法生成的字符串</td></tr><tr><td>maxBy</td><td><code>Optional&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最大元素的optional。如果为空返回的是Optional.empty()</td></tr><tr><td>minBy</td><td><code>Optional&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最小元素的optional。如果为空返回的是Optional.empty()</td></tr><tr><td>Reducing</td><td>归约操作产生的类型</td><td>从一个作为累加器的初始值开始,利用binaryOperator与流中的元素逐个结合,从而将流归约为单个值</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个转换器,对其结果应用转换函数</td></tr><tr><td>groupingBy</td><td><code>Map&lt;K,List&lt;T&gt;&gt;</code></td><td>根据流中元素的某个值对流中的元素进行分组,并将属性值做为结果map的键</td></tr><tr><td>partitioningBy</td><td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td><td>根据流中每个元素应用谓语的结果来对项目进行分区</td></tr></tbody></table></div><p>第二种方式看起来跟reduce的三个入参的方法有点类似，也可以用来实现filter、map等操作！</p><ul><li>第一个参数：构建新数据结构用于后面使用</li><li>第二个参数：用于对循环stream数据的流循环处理，如果在并行是则会对每个数据分线程处理第一个参数数据</li><li>第三个参数：只有在并行流中调用。完成第二个参数调用后，就会调用该合并器，与reduce的三个参数一致。</li></ul><h3 id="max：根据提供的Comparator返回此流的最大元素"><a href="#max：根据提供的Comparator返回此流的最大元素" class="headerlink" title="max：根据提供的Comparator返回此流的最大元素"></a>max：根据提供的Comparator返回此流的最大元素</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-built_in">max</span>(<span class="hljs-type">Comparator</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; comparator);<br></code></pre></td></tr></table></figure><h3 id="min：根据提供的Comparator返回此流的最小元素"><a href="#min：根据提供的Comparator返回此流的最小元素" class="headerlink" title="min：根据提供的Comparator返回此流的最小元素"></a>min：根据提供的Comparator返回此流的最小元素</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-built_in">min</span>(<span class="hljs-type">Comparator</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; comparator);<br></code></pre></td></tr></table></figure><h3 id="count：返回此流中的元素计数"><a href="#count：返回此流中的元素计数" class="headerlink" title="count：返回此流中的元素计数"></a>count：返回此流中的元素计数</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>这是对<code>NullPointerException</code>的异常问题专门提供的方案，在许多语言中都会以不同的方式进行呈现。<br>Optional 只是一个容器，它可以保存一些类型的值或者null。</p><div class="table-container"><table><thead><tr><th>修饰符和类型</th><th>方法和说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td>empty()返回一个空Optional实例。</td></tr><tr><td>boolean</td><td>equals(Object obj) 指示其他某个对象是否“等于”此Optional。</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>filter(Predicate&lt;? super T&gt; predicate)</code>如果存在一个值，并且该值与给定的谓词匹配，则返回一个Optional描述值的描述，否则返回一个empty Optional。</td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td><code>flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</code>如果存在值，则将提供的Optional-bearing映射函数应用于该值，返回该结果，否则返回empty Optional。</td></tr><tr><td>T</td><td>get()如果此值存在Optional，则返回该值，否则抛出NoSuchElementException。</td></tr><tr><td>int</td><td>hashCode()返回当前值的哈希码值（如果有）；如果没有值，则返回0（零）。</td></tr><tr><td>void</td><td><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>如果存在值，请使用该值调用指定的使用者，否则不执行任何操作。</td></tr><tr><td>boolean</td><td>isPresent()true如果存在值，则返回，否则返回false。</td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td><code>map(Function&lt;? super T,? extends U&gt; mapper)</code>如果存在值，则将提供的映射函数应用于该值，如果结果为非null，则返回Optional描述结果的描述。</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td>of(T value)返回Optional具有指定的当前非空值的。</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td>ofNullable(T value)返回Optional描述指定值的描述，如果不为null，则返回null Optional。</td></tr><tr><td>T</td><td>orElse(T other)返回值（如果存在），否则返回other。</td></tr><tr><td>T</td><td><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>返回值（如果存在），否则调用other并返回该调用的结果。</td></tr><tr><td><code>&lt;X extends Throwable&gt;</code> / T</td><td><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>返回包含的值（如果存在），否则抛出异常，由提供的供应商创建。</td></tr><tr><td>String</td><td>toString()返回此Optional的非空字符串表示形式，适用于调试。</td></tr></tbody></table></div><h3 id="Optional使用场景"><a href="#Optional使用场景" class="headerlink" title="Optional使用场景"></a>Optional使用场景</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">String isocode = user.get<span class="hljs-constructor">Address()</span>.get<span class="hljs-constructor">Country()</span>.get<span class="hljs-constructor">Isocode()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br> <br><span class="hljs-comment">//将上面的代码进行判空处理</span><br><span class="hljs-keyword">if</span> (user != null) &#123;<br>    Address address = user.get<span class="hljs-constructor">Address()</span>;<br>    <span class="hljs-keyword">if</span> (address != null) &#123;<br>        Country country = address.get<span class="hljs-constructor">Country()</span>;<br>        <span class="hljs-keyword">if</span> (country != null) &#123;<br>            String isocode = country.get<span class="hljs-constructor">Isocode()</span>;<br>            <span class="hljs-keyword">if</span> (isocode != null) &#123;<br>                isocode = isocode.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以转换成如下写法：<br><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Optional</span><span class="hljs-selector-class">.ofNullable</span>(user)<br><span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">User</span>::getAddress)<br><span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">Address</span>::getCountry)<br><span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">Country</span>::getIsocode)<br><span class="hljs-selector-class">.ifPresent</span>(s-&gt; s.toUpperCase());<br></code></pre></td></tr></table></figure><br>不仅仅是美观，而是在数据整体的包装且进行数据流传递处理。</p><ul><li>当使用值为空的情况，并非源于报错时产生，可以使用Optional（因为有错误的情况，肯定是不正常的，需要处理的）</li><li>对于一个对象，我们需要做判空、过滤、某些校验的时候，可以使用Optional</li></ul><h3 id="常用方法使用"><a href="#常用方法使用" class="headerlink" title="常用方法使用"></a>常用方法使用</h3><h5 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h5><p>empty 方法返回一个不包含值的 Optional 实例, 注意不保证返回的 empty 是单例, 不要用 == 比较。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="of"><a href="#of" class="headerlink" title="of()"></a>of()</h5><p>返回一个 Optional 实例；代表指定的非空值, 如果传入 null 会立刻抛出空指针异常。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T value)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable()"></a>ofNullable()</h5><p>返回一个 Optional 实例, 如果指定非空值则实例包含非空值, 如果传入 null 返回不包含值的 empty<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">ofNullable</span><span class="hljs-params">(T value)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent()"></a>isPresent()</h5><p>isPresent 用来判断实例是否包含值, 如果不包含非空值返回 false, 否则返回 true<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPresent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>get 方法, 如果实例包含值则返回当前值, 否则抛出 NoSushElementException 异常<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> T <span class="hljs-keyword">get</span>();<br></code></pre></td></tr></table></figure></p><h5 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent()"></a>ifPresent()</h5><p>ifPresent 方法作用是当实例包含值时, 来执行传入的 Consumer, 比如调用一些其他方法<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; consumer)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><p>filter 方法用于过滤不符合条件的值, 接收一个 Predicate 参数, 如果符合条件返回代表值的 Optional 实例, 否则返回 empty</p><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><p>map 方法是链式调用避免空指针的核心方法, 当实例包含值时, 对值执行传入的 Function 逻辑, 并返回一个代表结果值的新的 Optional 实例；也就是将 optional 中的对象转成 其他对象，或者修改对象中的属性。</p><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h5><p>flatMap方法是将 optional 中的对象转成 optional 对象，或者修改对象中的属性；与map方法类似。<br>不同之处在于，前者返回的数据，后者返回的数据需要封装在Stream中。</p><h5 id="orElse"><a href="#orElse" class="headerlink" title="orElse()"></a>orElse()</h5><p>orElse方法是如果实例包含值, 那么返回这个值, 否则返回指定的默认值, 如null<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElse</span><span class="hljs-params">(T other)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet()"></a>orElseGet()</h5><p>orElseGet方法是如果实例包含值, 返回这个值；否则，它会执行作为参数传入的 Supplier(供应者) 函数式接口，并将返回其执行结果。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function">T <span class="hljs-title">orElseGet</span><span class="hljs-params">(Supplier&lt;? <span class="hljs-keyword">extends</span> T&gt; other)</span></span>;<br></code></pre></td></tr></table></figure></p><p>orElse与orElseGet不同之处：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public void given<span class="hljs-constructor">PresentValue_whenCompare_thenOk()</span> &#123;<br>    User user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">User(<span class="hljs-string">&quot;john@gmail.com&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>)</span>;<br>    logger.info(<span class="hljs-string">&quot;Using orElse&quot;</span>);<br>    User result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">user</span>)</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">Else(<span class="hljs-params">createNewUser</span>()</span>);<br>    logger.info(<span class="hljs-string">&quot;Using orElseGet&quot;</span>);<br>    User result2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">user</span>)</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">ElseGet(()</span> -&gt; create<span class="hljs-constructor">NewUser()</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow()"></a>orElseThrow()</h5><p>如果实例不包含值, 调用传入的 Supplier 参数, 生成一个异常实例并抛出.这个方法通常与全局异常处理器一起使用, 当参数或者其他情况获取不到值时, 抛出自定义异常, 由异常处理器处理成通用返回结果, 返回给前端。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">tempList</span>)</span><br>        .<span class="hljs-keyword">or</span><span class="hljs-constructor">ElseThrow(()</span> -&gt; runtimeException)<br>        .<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">t</span> -&gt; System.<span class="hljs-params">out</span>.<span class="hljs-params">println</span>(<span class="hljs-string">&quot;2:&quot;</span> + <span class="hljs-params">t</span>)</span>);<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java Stream管道数据处理操作</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>全局ID</title>
    <link href="http://example.com/2023/06/01/%E5%85%A8%E5%B1%80id/"/>
    <id>http://example.com/2023/06/01/%E5%85%A8%E5%B1%80id/</id>
    <published>2023-06-01T09:02:25.000Z</published>
    <updated>2023-06-06T03:59:10.919Z</updated>
    
    <content type="html"><![CDATA[<p>要求</p><ol><li>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li><li>在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li><li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li><li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li></ol><h2 id="常见方法介绍"><a href="#常见方法介绍" class="headerlink" title="常见方法介绍"></a>常见方法介绍</h2><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符。</p><p>优点：</p><ul><li>性能非常高：本地生成，没有网络消耗。</li><li>比较适合用于生成唯一的名字的标示比如文件的名字。</li></ul><p>缺点：</p><ul><li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li><li>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li><li>ID作为主键时在特定的环境会存在一些问题，36字符长度太长，他的无序性可能会引起数据位置频繁变动，性能受到影响。</li></ul><h2 id="snowflake方案"><a href="#snowflake方案" class="headerlink" title="snowflake方案"></a>snowflake方案</h2><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等。<br><img src="/img/ID/0.png" alt="github"><br><code>41-bit</code>的时间可以表示<code>（1L&lt;&lt;41）/(1000L*3600*24*365)=69</code>年的时间，<code>10-bit</code>机器可以分别表示<code>1024</code>台机器。</p><p>优点：</p><ul><li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li><li>可以根据自身业务特性分配bit位，非常灵活。</li></ul><p>缺点：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h2 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h2><p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">begin</span>;<br>REPLACE <span class="hljs-keyword">INTO</span> Tickets64 (stub) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">SELECT</span> LAST_INSERT_ID();<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure></p><p>优点：</p><ul><li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li><li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li></ul><p>缺点：</p><ul><li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li><li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li></ul><p>对于MySQL性能问题，每台机器设置不同的初始值，且步长和机器数相等。这种架构貌似能够满足性能的需求，但有以下几个缺点：</p><ul><li>系统水平扩展比较困难</li><li>ID没有了单调递增的特性，只能趋势递增</li><li>数据库压力还是很大</li></ul><h2 id="Leaf方案实现"><a href="#Leaf方案实现" class="headerlink" title="Leaf方案实现"></a>Leaf方案实现</h2><h4 id="Leaf-segment数据库方案"><a href="#Leaf-segment数据库方案" class="headerlink" title="Leaf-segment数据库方案"></a>Leaf-segment数据库方案</h4><p>在使用数据库的方案上，做了如下改变：</p><ul><li>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</li><li>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</li></ul><figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">+-------------+--------------+------+-----+-------------------+-----------------------------+<br>|<span class="hljs-string"> Field       </span>|<span class="hljs-string"> Type         </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default           </span>|<span class="hljs-string"> Extra                       </span>|<br>+-------------+--------------+------+-----+-------------------+-----------------------------+<br>|<span class="hljs-string"> biz_tag     </span>|<span class="hljs-string"> varchar(128) </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string">                   </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> max_id      </span>|<span class="hljs-string"> bigint(20)   </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> 1                 </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> step        </span>|<span class="hljs-string"> int(11)      </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL              </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> desc        </span>|<span class="hljs-string"> varchar(256) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL              </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> update_time </span>|<span class="hljs-string"> timestamp    </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> CURRENT_TIMESTAMP </span>|<span class="hljs-string"> on update CURRENT_TIMESTAMP </span>|<br>+-------------+--------------+------+-----+-------------------+-----------------------------+<br></code></pre></td></tr></table></figure><p>重要字段说明：biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1/step。</p><p>test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Begin</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">SET</span> max_id=max_id+step <span class="hljs-keyword">WHERE</span> biz_tag=xxx<br><span class="hljs-keyword">SELECT</span> tag, max_id, step <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> biz_tag=xxx<br><span class="hljs-keyword">Commit</span><br></code></pre></td></tr></table></figure></p><p>优点：</p><ul><li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li><li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li></ul><p>缺点：</p><ul><li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li><li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li><li>DB宕机会造成整个系统不可用。</li></ul><h4 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h4><p>对于第二个缺点，Leaf-segment做了一些优化，简单的说就是：<br>Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p><p>为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的TP999指标。</p><p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p><h4 id="Leaf-snowflake方案"><a href="#Leaf-snowflake方案" class="headerlink" title="Leaf-snowflake方案"></a>Leaf-snowflake方案</h4><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。面对这一问题，提供了 Leaf-snowflake方案。</p><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p><ol><li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li><li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li><li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li></ol><h4 id="弱依赖ZooKeeper"><a href="#弱依赖ZooKeeper" class="headerlink" title="弱依赖ZooKeeper"></a>弱依赖ZooKeeper</h4><p>除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。一定程度上提高了SLA。</p><h4 id="时钟问题"><a href="#时钟问题" class="headerlink" title="时钟问题"></a>时钟问题</h4><p>因为这种方案依赖时间，如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号，需要解决时钟回退的问题。<br><img src="/img/ID/1.png" alt="github"><br>服务启动时首先检查自己是否写过ZooKeeper leaf_forever节点：</p><ol><li>若写过，则用自身系统时间与<code>leaf_forever/$&#123;self&#125;</code>节点记录时间做比较，若小于<code>leaf_forever/$&#123;self&#125;</code>时间则认为机器时间发生了大步长回拨，服务启动失败并报警。</li><li>若未写过，证明是新服务节点，直接创建持久节点<code>leaf_forever/$&#123;self&#125;</code>并写入自身系统时间，接下来综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点(所有运行中的Leaf-snowflake节点)的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)/nodeSize。</li><li>若abs( 系统时间-sum(time)/nodeSize ) &lt; 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点<code>leaf_temporary/$&#123;self&#125;</code> 维持租约。</li><li>否则认为本机系统时间发生大步长偏移，启动失败并报警。</li><li>每隔一段时间(3s)上报自身系统时间写入<code>leaf_forever/$&#123;self&#125;</code>。</li></ol><p>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警。</p><h4 id="利用-redis-生成-id"><a href="#利用-redis-生成-id" class="headerlink" title="利用 redis 生成 id"></a>利用 redis 生成 id</h4><p>性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更 加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>]]></content>
    
    
    <summary type="html">全局ID</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM-工具</title>
    <link href="http://example.com/2023/05/23/JVM%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2023/05/23/JVM%E5%B7%A5%E5%85%B7/</id>
    <published>2023-05-23T08:02:25.000Z</published>
    <updated>2023-05-23T14:06:46.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps（Java Virtual Machine Process Status Tool）是JDK提供的一个可以列出正在运行的Java虚拟机的进程信息的命令行工具，它可以显示Java虚拟机进程的执行主类（Main Class，main()函数所在的类）名称、本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）等信息。另外，jps命令只能显示它有访问权限的Java进程的信息。<br>命令参数说明：</p><blockquote><p>-q：不显示主类名称、JAR文件名和传递给主方法的参数，只显示本地虚拟机唯一ID。<br>-mlvV：我们可以指定这些参数的任意组合。<br>-m：显示Java虚拟机启动时传递给main()方法的参数。<br>-l：显示主类的完整包名，如果进程执行的是JAR文件，也会显示JAR文件的完整路径。<br>-v：显示Java虚拟机启动时传递的JVM参数。<br>-V：不显示主类名称、JAR文件名和传递给主方法的参数，只显示本地虚拟机唯一ID。<br>hostid：指定的远程主机，可以是ip地址和域名, 也可以指定具体协议，端口。如果不指定，则显示本机的Java虚拟机的进程信息。<br>-help：显示jps命令的帮助信息。</p></blockquote><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat 是JDK中提供的一个命令行工具，主要用来打印JVM 性能数据相关的统计数据。主要包含以下几个方面：<br>垃圾回收(GC)方面数据<br>编译(Compilation)相关数据<br>类加载信息(Class Loader)</p><p>jstat 使用很简单，只要在命令行中执行如下命令：<br> jstat -gc -t 11256 10000 10<br>参数解释：</p><blockquote><p>-gc :打印相关的统计参数<br>-t:  在每行日志之前加上JVM的启动时间<br>11256 : 目标Java进程的ID<br>10000: jstat命令执行间隔时间(milliseconds)，10000表示每10s打印一行日志<br>10: jstat命令的执行次数，(和上面的时间间隔一起，表示jstat会每10s执行1次，总共执行10次).</p></blockquote><p>参数意义：</p><ul><li>time :  JVM启动时间(单位为秒)</li><li>S0C ：年轻代中S0区的容量 （字节）</li><li>S1C ：年轻代中S1区的容量 (字节)</li><li>S0U ：年轻代中S0区目前已使用空间 (字节)</li><li>S1U ：年轻代中S1区目前已使用空间 (字节)</li><li>EC ：年轻代中Eden区的容量 (字节)</li><li>EU ：年轻代中Eden区目前已使用空间 (字节)</li><li>OC ：老年代的容量 (字节)</li><li>OU ：老年代目前已使用空间 (字节)</li><li>YGC ：从应用程序启动到采样时年轻代中GC次数</li><li>YGCT ：从应用程序启动到采样时年轻代中GC所用时间(s)</li><li>FGC ：从应用程序启动到采样时老年代(全GC)GC次数</li><li>FGCT ：从应用程序启动到采样时老年代(全GC)GC所用时间(s)</li><li>GCT：从应用程序启动到采样时GC用的总时间(s)</li></ul><p><a href="https://img-blog.csdnimg.cn/aaa166818181449da9f695d45f8c5ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16">https://img-blog.csdnimg.cn/aaa166818181449da9f695d45f8c5ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16</a></p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>jmap是JDK自带的监控工具，在JDK的根目录中可以找到。主要用来查看Java进程对内存的使用情况<br>1、查看类列表，包含实例数、占用内存大小<br><code>jmap -histo[:live] pid</code><br>2、查看动态链接库的列表<br><code>jmap pid</code><br>3、查看Java堆的概要信息<br><code>jmap -heap pid</code><br>4、生成Java虚拟机的堆转储快照 dump文件<br><code>jmap -dump:[live,] format=b,file=./heap.hprof pid</code></p><blockquote><p>live参数是可选的，如果指定，则只转储堆中的活动对象；如果没有指定，则转储堆中的所有对象。<br>format=b表示以hprof二进制格式转储Java堆的内存。<br>file=用于指定快照dump文件的文件名。</p></blockquote><p>注意，如果是k8s中自启动的java项目的pid可能为1，导致无法找到这个默认进程。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>主要是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言。<br>使用jmap等方法生成java的堆文件后，使用其进行分析。</p><h2 id="第一步：导出堆"><a href="#第一步：导出堆" class="headerlink" title="第一步：导出堆"></a>第一步：导出堆</h2><p><code>jmap -dump:live,file=a.log pid</code><br>除了jmap还有以下方法获取</p><ol><li>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）、</li><li>虚拟机启动时如果指定了 -XX:+HeapDumpOnOutOfMemoryError 选项, 则在抛出 OutOfMemoryError 时, 会自动执行堆转储。</li><li>使用 hprof 命令</li></ol><h2 id="第二步：分析堆文件"><a href="#第二步：分析堆文件" class="headerlink" title="第二步：分析堆文件"></a>第二步：分析堆文件</h2><p><code>jhat -J-Xmx512M a1.log</code><br>说明：有时dump出来的堆很大，在启动时会报堆空间不足的错误，可加参数：jhat -J-Xmx512m 。这个内存大小可根据自己电脑进行设置。<br>解析Java堆转储文件,并启动一个 web server</p><h2 id="第三步：查看html"><a href="#第三步：查看html" class="headerlink" title="第三步：查看html"></a>第三步：查看html</h2><p><code>http://ip:7000/</code></p><p>对于jhat启动后显示的html页面中功能：</p><ul><li>（1）显示出堆中所包含的所有的类</li><li>（2）从根集能引用到的对象</li><li>（3）显示平台包括的所有类的实例数量</li><li>（4）堆实例的分布表</li><li>（5）执行对象查询语句</li></ul><p>当需要进行语句查询是：<br>输入内容如：<br><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#查询长度大于100的字符串</span><br><span class="hljs-keyword">select</span> s <span class="hljs-keyword">from</span> java.lang.String s <span class="hljs-keyword">where</span> s.<span class="hljs-keyword">count</span> &gt; <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照。<br>jstack 命令格式如下<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">jstack <span class="hljs-selector-attr">[ option ]</span> pid <br>jstack <span class="hljs-selector-attr">[ option ]</span> executable core <br>jstack <span class="hljs-selector-attr">[ option ]</span> <span class="hljs-selector-attr">[server-id@]</span>remote-hostname-or-IP <br></code></pre></td></tr></table></figure></p><p>option<br>选项    作用</p><ul><li>-F    当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-m    如果调用到本地方法的话，可以显示C/C++的堆栈</li><li>-l    除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</li></ul><p>Java语言定义了6种线程池状态：</p><ul><li>New：创建后尚未启动的线程处于这种状态，不会出现在Dump中。</li><li>RUNNABLE：包括Running和Ready。线程开启start（）方法，会进入该状态，在虚拟机内执行的。</li><li>Waiting：无限的等待另一个线程的特定操作。</li><li>Timed Waiting：有时限的等待另一个线程的特定操作。</li><li>阻塞（Blocked）：在程序等待进入同步区域的时候，线程将进入这种状态，在等待监视器锁。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul><p>Dump文件的线程状态一般其实就以下3种：</p><ul><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li></ul><p>Dump 文件分析关注重点</p><ul><li>runnable，线程处于执行中</li><li>deadlock，死锁（重点关注）</li><li>blocked，线程被阻塞 （重点关注）</li><li>Parked，停止</li><li>locked，对象加锁</li><li>waiting，线程正在等待</li><li>waiting to lock 等待上锁</li><li>Object.wait()，对象等待中</li><li>waiting for monitor entry 等待获取监视器（重点关注）</li><li>Waiting on condition，等待资源（重点关注），最常见的情况是线程在等待网络的读写</li></ul><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo命令用于打印指定Java进程或核心文件或远程调试服务器的Java配置信息。这些配置信息包括Java系统属性和Java虚拟机(JVM)命令行标志。<br>如果指定的进程运行在64位JVM上，则需要用：jinfo -J-d64 -sysprops pid命令。<br>jinfo命令可能会在之后的版本中删除。<br>语法<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jinfo </span>[ option ] pid 连接到正在运行的进程<br><span class="hljs-keyword">jinfo </span>[ option ] executable core 连接到核心文件<br><span class="hljs-keyword">jinfo </span>[ option ] [ servier-id ] remote-hostname-<span class="hljs-keyword">or-IP </span>要连接到远程<span class="hljs-built_in">DEBUG</span>服务器<br></code></pre></td></tr></table></figure></p><ul><li>executable：生成core dump的Java可执行文件</li><li>core：要打印内存映射的核心文件</li><li>server-id：服务器的ID。如果多个DEBUG服务器在同一个远程主机上运行，则各个服务器的ID必须唯一</li><li>remote-hostname：远程DEBUG服务器的主机名</li><li>IP：远程DEBUG服务器的IP</li></ul><p>参数说明</p><ul><li>no-option<br>打印命令行标志和系统属性的【name-value】对。</li><li>-flag name<br>打印指定命令行标志的【name-value】对。</li><li>-flag [+|-]name<br>启用或禁用指定的命令行标志。<br>表示启用，- 表示禁用。</li><li>-flag name=value<br>将指定的命令行标志设置为指定的值。<br>注意：不是所有的flag都可以通过命令行改变！！！</li><li>-flags<br>打印传递给JVM的命令行标志。</li><li>-sysprops<br>以【name-value】对的形式打印Java系统属性。</li><li>-h or -help<br>打印jinfo命令的帮助信息。</li></ul><h2 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h2><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对正在运行的环境进行查看。</p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>jdk自带全能工具，可以分析内存快照、线程快照;监控内存变化、GC变化等。<br><code>jvisualvm --openpid 44620</code></p><p>安装插件<br>在这里找到对应jdk版本号的地址<a href="https://visualvm.github.io/pluginscenters.html，复制到插件中心里面即可。">https://visualvm.github.io/pluginscenters.html，复制到插件中心里面即可。</a></p><h2 id="Memory-Analyzer-Tool"><a href="#Memory-Analyzer-Tool" class="headerlink" title="Memory Analyzer Tool"></a>Memory Analyzer Tool</h2><p>一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br>下载地址 <a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a><br>这里需要找对版本号。</p><h2 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h2><p>一款专业分析gc日志的工具<br>需要自己编译运行<br>git 地址<br><code>https://github.com/jewes/gchisto</code></p>]]></content>
    
    
    <summary type="html">JVM-工具</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>相机学习2-我的富士学习</title>
    <link href="http://example.com/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/"/>
    <id>http://example.com/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/</id>
    <published>2023-04-24T18:02:25.000Z</published>
    <updated>2023-04-26T14:02:32.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="曝光模式"><a href="#曝光模式" class="headerlink" title="曝光模式"></a>曝光模式</h1><h2 id="程序自动曝光P"><a href="#程序自动曝光P" class="headerlink" title="程序自动曝光P"></a>程序自动曝光P</h2><p>若要使快门速度和光圈均由照相机调整已获得理想曝光，请将快门速度和光圈设置为A。<br>若拍照对象位于照相机测光范围之外，快门速度和光圈将显示<code>---</code>。</p><p>如有需要，可旋转前指令拨盘选择快门和光圈的其他组合而不更改曝光。<br>程序切换在以下情况中不可用</p><ul><li>安装的闪光灯支持TTL自动</li><li>动态范围选择了自动</li><li>感光度拨盘旋转至A</li></ul><h2 id="快门优先AE-S"><a href="#快门优先AE-S" class="headerlink" title="快门优先AE S"></a>快门优先AE S</h2><p>将光圈设为A并使用快门速度拨盘，可手动调整快门速度而有照片相机选择光圈获得的理想曝光。</p><p>在180X以外的设定下，也可以通过旋转前指令拨盘以1/3EV为步长调整快门速度。即使在板块们按钮期间也可调整快门速度。</p><p>若无法在所选快门速度下达到正确的曝光，半按快门按钮时光圈将显示红色。<br>若拍摄对象位于测光范围之外，光圈将显示为<code>---</code>。</p><h2 id="光圈优先AE-A"><a href="#光圈优先AE-A" class="headerlink" title="光圈优先AE A"></a>光圈优先AE A</h2><p>将快门速度旋转至A并根据需要调整光圈，可手动调整光圈至由相机选择快门速度已获得理想曝光。</p><p>即使在半按快门按钮期间也可以调整光圈。</p><p>若无法在光圈下达到正常曝光，将显示红色。<br>若拍摄对象位于相机测光范围之外，快门速度将显示<code>---</code>。</p><p>手动曝光 M<br>-<br>将快门速度和光圈均设为A以外的值可改变照相机建议的曝光值。屏幕将显示M。</p><p>在180X以外的的设定下，也可以通过选择前指令拨盘以1/3EV为步长调整快门速度。<br>手动曝光显示包含曝光指示，当前设定下照片将会曝光不足或曝光过度的量通过最左侧的曝光指示提示。</p><h1 id="DRIVE拨盘"><a href="#DRIVE拨盘" class="headerlink" title="DRIVE拨盘"></a>DRIVE拨盘</h1><p>BKT：包围，在一些列照片中自动更改设定<br>CH：高速连拍<br>CL：低速连拍<br>S：单幅画面<br>多重曝光：创建由两次曝光组合的照片<br>创意滤镜：拍摄带滤镜效果的照片<br>全景：按照屏幕指南创建全景照片</p><h1 id="色彩相关"><a href="#色彩相关" class="headerlink" title="色彩相关"></a>色彩相关</h1><p><code>XT-1</code>只有<code>色彩</code>功能。</p><ol><li>色彩的加减即是整体饱和度的加减，影响全局饱和度</li><li>色彩的加减不会影响色相</li></ol><h1 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h1><p>一共三个档次，每一次提升都需要提升一档ISO。</p><ol><li>提高ISO会下降很小的画质，但是可以显著降低高光区域的曝光</li><li>不影响阴影区域的曝光</li><li>主要用于恢复高光细节</li></ol><h1 id="高光色调"><a href="#高光色调" class="headerlink" title="高光色调"></a>高光色调</h1><ol><li>高光加就是增强高光</li><li>高光减则是减轻高光</li></ol><h1 id="阴影色调"><a href="#阴影色调" class="headerlink" title="阴影色调"></a>阴影色调</h1><ol><li>加阴影则是增强阴影</li><li>减阴影则是减弱阴影</li></ol><h1 id="锐度"><a href="#锐度" class="headerlink" title="锐度"></a>锐度</h1><p>让整体画面更加锐利。</p><ol><li>人物一般降低锐度</li><li>静物一般增加锐度</li></ol><h1 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h1><p>一般情况是在ISO125开始工作，显著改善ISO下的噪点。</p><h1 id="长时间曝光降噪"><a href="#长时间曝光降噪" class="headerlink" title="长时间曝光降噪"></a>长时间曝光降噪</h1><p>一般指快门8s后开始工作，星空下效果很好。</p><h1 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h1><p>色温的高低会让画面呈现的冷暖不同。</p><h1 id="胶片模拟的底层逻辑"><a href="#胶片模拟的底层逻辑" class="headerlink" title="胶片模拟的底层逻辑"></a>胶片模拟的底层逻辑</h1><p>风格差异：</p><ol><li>色相/饱和度/亮度；高光与阴影的偏色</li><li>高光/阴影； 照片的反差与对比度</li></ol><p>最终成像：<br>同一种胶片模拟通过机内设置可产生完全不同的风格<br>白平衡与偏移的影响最为显著。</p><ul><li>PROVIA/标准：基础拍摄</li><li>Velvia/鲜艳：色彩饱和、对比度高，用于自然风景</li><li>ASTIA/柔和：增加用于肖像颜色范围，同时保留天空蓝色，适合户外肖像</li><li>PRO Neg.Hi：提供的对比度在n.s.下提供的稍多，在户外进行肖像拍摄时推荐</li><li>PRO Neg.Std：色调柔和，增加用于肤色的色相范围，适合摄影棚肖像</li><li>黑白：标准黑白</li><li>黑白+黄滤镜：对比度稍强，并稍微降低天空的亮度</li><li>黑白+红滤镜：对比度增强，大幅降低天空的亮度</li><li>黑白+绿滤镜：柔化黑白肖像的肤色</li><li>棕褐色：棕褐色照片</li></ul><h1 id="一些使用参数"><a href="#一些使用参数" class="headerlink" title="一些使用参数"></a>一些使用参数</h1><h2 id="晴天"><a href="#晴天" class="headerlink" title="晴天"></a>晴天</h2><ol><li>胶片 c.n.</li><li>色温5200K</li><li>色调H-2，S-2</li><li>动态范围 400</li><li>色彩+3 锐度+4</li></ol><h2 id="温柔黄昏胶片滤镜"><a href="#温柔黄昏胶片滤镜" class="headerlink" title="温柔黄昏胶片滤镜"></a>温柔黄昏胶片滤镜</h2><ol><li>胶片c.c.</li><li>色彩+4</li><li>锐度0</li><li>高ISO降噪-4</li><li>色温6050K red3，blue0</li><li>ISO最高6400</li><li>动态范围自动</li><li>曝光补偿0-2/3</li><li>色调 H+1，S-2</li></ol><h2 id="日系清新胶片滤镜"><a href="#日系清新胶片滤镜" class="headerlink" title="日系清新胶片滤镜"></a>日系清新胶片滤镜</h2><ol><li>胶片n.c.</li><li>色彩+2</li><li>锐度+2</li><li>高ISO降噪 关</li><li>白平衡 日光，red-2，blue-2</li><li>ISO最高6400</li><li>动态范围自动</li><li>曝光补偿+2/3</li><li>色调 H-0.5，S-0.5</li></ol><h2 id="夜色复古胶片滤镜"><a href="#夜色复古胶片滤镜" class="headerlink" title="夜色复古胶片滤镜"></a>夜色复古胶片滤镜</h2><ol><li>胶片c.c.</li><li>色彩+2</li><li>白平衡 阴天 red-2，blue-2</li><li>动态范围 100</li><li>色调H-1，S+2</li><li>降噪-1</li></ol><h2 id="电影扫街胶片滤镜"><a href="#电影扫街胶片滤镜" class="headerlink" title="电影扫街胶片滤镜"></a>电影扫街胶片滤镜</h2><p>胶片c.c.<br>白平衡 5500K<br>锐度+3<br>动态范围400<br>色调 H+2，S+2<br>降噪-2</p><h2 id="静谧氛围胶片滤镜"><a href="#静谧氛围胶片滤镜" class="headerlink" title="静谧氛围胶片滤镜"></a>静谧氛围胶片滤镜</h2><p>胶片c.c.<br>色彩 +1<br>锐度 +1<br>白平衡 日光 red+2，blue-3<br>ISO最高6400<br>动态范围400<br>色调H-1，S+2<br>降噪-2</p>]]></content>
    
    
    <summary type="html">相机</summary>
    
    
    
    <category term="相机" scheme="http://example.com/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>相机学习1-基础部分</title>
    <link href="http://example.com/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/"/>
    <id>http://example.com/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/</id>
    <published>2023-04-09T08:59:25.000Z</published>
    <updated>2023-04-25T06:06:52.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h1><p>光圈越大，亮度越高。<br>光圈数值和大小相反，数值越小，光圈越大。</p><h1 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h1><p>快门越快，亮度越小。<br>一般使用分数来表示，数值越大，快门越小。</p><h1 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h1><p>ISO相当于在cmos上加上一个亮片，ISO越高，亮度越高，但是照片质量会降低，增加颗粒感，因为它是靠电子信号来发光。<br>iso并非越低越好，而是越接近原生iso越好，比如有的相机原生iso在400那么这时iso100的画质不如iso400，再比如有的iso可以低至50，而尼康D850的iso可以低至64，但由于iso50是拓展的iso画质是不如D850的iso64的。</p><h1 id="景深和虚化"><a href="#景深和虚化" class="headerlink" title="景深和虚化"></a>景深和虚化</h1><p>光圈的大小不仅仅会影响亮度，还会影响景深和虚化。</p><h1 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h1><p>大光圈导致浅景深，小光圈导致深景深。</p><h1 id="虚化"><a href="#虚化" class="headerlink" title="虚化"></a>虚化</h1><p>大光圈导致虚化强，小光圈导致虚化弱。</p><h1 id="动态模糊"><a href="#动态模糊" class="headerlink" title="动态模糊"></a>动态模糊</h1><p>快门的快慢不仅仅会影响亮度，还会影响动态模糊。<br>在亮度不够使，自动快门会导致快门时间过长，导致手抖可能发生照片模糊，测试需要将快门变慢，如果要保持自动，则需要设置其他的功能提高亮度。<br>但是慢快门可以让照片好看，即慢速快门。慢速快门拍摄技巧，可用于拍摄光绘，星轨，车流，火花可使用三脚架保持相机稳定，防止糊掉。</p><p>大太阳下，如何既有虚化（大光圈，浅景深，模糊背景），又有动态模糊（慢快门，让光在CMOS上运动）？<br>既有虚化，又有运动模糊，可以拍摄出一种运动感、速度感。引入  ND滤镜    （控光工具，可理解为相机用墨镜🕶可以降低画面亮度，有可变和固定参数两种。）</p><h1 id="相机档位"><a href="#相机档位" class="headerlink" title="相机档位"></a>相机档位</h1><p>Aperture 光圈<br>Shutter 快门<br>Program 程序（辅助）<br>Manual 全手动</p><div class="table-container"><table><thead><tr><th>档位</th><th>光圈</th><th>快门</th><th>ISO</th></tr></thead><tbody><tr><td>A</td><td>你</td><td>相机</td><td>你</td></tr><tr><td>S</td><td>相机</td><td>你</td><td>你</td></tr><tr><td>P</td><td>相机</td><td>相机</td><td>你</td></tr><tr><td>M</td><td>你</td><td>你</td><td>你</td></tr></tbody></table></div><h1 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h1><p>若IOS为手动挡</p><div class="table-container"><table><thead><tr><th>档位</th><th>光圈</th><th>快门</th><th>ISO</th></tr></thead><tbody><tr><td>A</td><td>你</td><td>曝光补偿</td><td>你</td></tr><tr><td>S</td><td>曝光补偿</td><td>你</td><td>你</td></tr><tr><td>P</td><td>曝光补偿</td><td>曝光补偿</td><td>你</td></tr><tr><td>M</td><td>你</td><td>你</td><td>你</td></tr></tbody></table></div><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>亮度说明图<br>左侧为偏暗<br>右侧为偏暗<br>中间表示明暗过渡的部分</p><h1 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h1><h1 id="除杂物"><a href="#除杂物" class="headerlink" title="除杂物"></a>除杂物</h1><p>保持画面干净整洁</p><ol><li>手动清除杂物</li><li>调整取景角度</li><li>大光圈虚化，或者放大画面规避</li></ol><h1 id="视角独特"><a href="#视角独特" class="headerlink" title="视角独特"></a>视角独特</h1><ol><li>低角度往上拍，突显高贵</li><li>高角度往下拍，娇小可爱，邻家感觉</li><li>远拍，距离感</li><li>近拍，感觉亲和</li><li>广角拍摄，纳入更多环境元素</li><li>特写拍摄:代入感强</li></ol><p>空间拍摄技巧，让画面更具纵深感和层次感<br>在空间上找可以延伸的最远方向<br>利用引导线<br>多个平面堆叠<br>添置前景遮挡</p><h1 id="突出主题（影明暗，色彩强弱，空间虚实）"><a href="#突出主题（影明暗，色彩强弱，空间虚实）" class="headerlink" title="突出主题（影明暗，色彩强弱，空间虚实）"></a>突出主题（影明暗，色彩强弱，空间虚实）</h1><ol><li>光影明暗</li><li>色彩强弱</li><li>空间虚实</li><li>明显的引导线</li></ol><h1 id="平衡主体"><a href="#平衡主体" class="headerlink" title="平衡主体"></a>平衡主体</h1><p>平衡画面重心，不要过于强调画面主体<br>画面元素，明暗占比会影响画面重心。色彩艳丽占比。<br>保证脸部光线要均匀。</p><h1 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h1><p>没有经过压缩的原始文件</p><h1 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h1><p>黑白颜色标准，推算别的颜色，白平衡则是告诉相机那一个是白色。<br>具备功能都会指明场景，晴天、雨天、灯下等。</p><h1 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h1><p>全局测光<br>中央测光<br>点测光</p><h1 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h1><p>光圈变小，将对焦范围变大<br>手动扭动对焦环，设置对焦距离</p><p>单次自动对焦:AF-S<br>连续自动对焦:AF-C（拍摄运动物体）<br>手动对焦:mf（手拧对焦环对焦）<br>自动手动混合:DMF（在相机自动对焦后，仍可以手拧对焦环微调）</p>]]></content>
    
    
    <summary type="html">相机</summary>
    
    
    
    <category term="相机" scheme="http://example.com/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NginxProxyManager增加ssl</title>
    <link href="http://example.com/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/"/>
    <id>http://example.com/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-30T09:01:12.209Z</updated>
    
    <content type="html"><![CDATA[<p>NginxProxyManager增加custom ssl<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">openssl genrsa -out root.key <span class="hljs-number">1024</span><br><br>openssl req -<span class="hljs-keyword">new</span> -out root.csr -key root.key<br><br>openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days <span class="hljs-number">3650</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">NginxProxyManager增加ssl</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
</feed>
