<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小杨的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-07T09:06:32.758Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中Unsafe</title>
    <link href="http://example.com/2023/08/05/UnSafe/"/>
    <id>http://example.com/2023/08/05/UnSafe/</id>
    <published>2023-08-05T08:31:32.000Z</published>
    <updated>2023-08-07T09:06:32.758Z</updated>
    
    
    <summary type="html">Java中Unsafe</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://example.com/2023/07/31/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2023/07/31/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2023-07-31T20:11:01.000Z</published>
    <updated>2023-08-07T08:44:19.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>历史上，红黑树是AVL树的一个变种。对红黑树的操作在最坏情况下花费<code>O(long N)</code>时间，并且可以看到（对于插入操作的）一种审慎的非递归实现可以相对容易的完成（与AVL数相比）。</p><h2 id="红黑树规则特点"><a href="#红黑树规则特点" class="headerlink" title="红黑树规则特点"></a>红黑树规则特点</h2><ol><li>每一个节点为红色，或者黑色。</li><li>根是黑色的。</li><li>如果一个节点是攻色那么子节点必是黑色。</li><li>从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点。</li></ol><p>着色法则的一个结论是，红黑树的高度最多是<code>2log(N+1)</code>。因此，查找操作保证是一种对数的操作。</p><p>困难在于将一个新项插入到树中。通常把新项作为树叶放到树中。如果将它涂成黑色那么会违反条件4，因为将会建立一条更长的黑节点路径。因此这一项必须涂成红色。<br>如果他的父节点是黑色的，则插入完成。如果他的父节点是红色的，那么得到了连续的红色节点，这就违反了条件3。<br>此时我们必须要调整该树。用于完成这项任务的基本操作是颜色的改变和树旋转。</p><h2 id="自底向上的插入"><a href="#自底向上的插入" class="headerlink" title="自底向上的插入"></a>自底向上的插入</h2><p>如果新插入的项的父节点是黑色的，那么插入完成。因此将25插入到图中的树中是简单的操作。<br><img src="/img/RedBlackTree/0.png" alt="github"></p><p>如果父节点是红色的，那么有几种情况（每种都有一个镜像对称）需要考虑。<br>首先，假设这个父节点的兄弟是褐色的（我们采纳规定：null节点都是黑色的）。<br>这对于插入3或8是适用的，但对插入99不适用。令X是新添加的树叶，P是他的父节点，S是父节点的兄弟（若存在），G是祖父节点。<br>在这种情形只有X和P是红色的，G是黑色的，否则就会在插入前有两个相连的红色节点，违反规则。<br>采用伸展树的术语，X、P和G可以形成一个一字形链或之字形链（两个方向中的任意个方向）。</p><p>下图指出P是一个左儿子时我们应该如何旋转该树。即使X是一片树叶，我们还是画出较一般的情形，使得X在树的中间。后面我们将用到这个较一般的旋转。<br><img src="/img/RedBlackTree/1.png" alt="github"><br>如果S是黑色，则单旋转和之字形旋转有效</p><p>第一种情形对应P和G之间的单旋转，而第二种情形对应双旋转，该双旋转首先在X和P之间进行，然后在X和G之间进行。当编写程序时，必须记录父节点、祖父节点，以及为了重新连接还要记录曾祖节点。<br>在这两种情形下，子树的新根均被涂为黑色，因此，即使原来的曾祖时红色，我们也排除了两个相邻红色节点的可能性。同样重要的是，这些旋转的结果是通过A，B和C诸路径上的黑色节点个数保持不变。</p><h2 id="自顶向下的红黑树"><a href="#自顶向下的红黑树" class="headerlink" title="自顶向下的红黑树"></a>自顶向下的红黑树</h2><p>上面的实现需要用到一个栈或用一些父链保存路径。我们看到，如果使用一个自顶向下的过程，则伸展树会更有效，事实上我们可以对红黑树应用自顶向下的过程而保证S不会是红色的。<br>这个过程在概念上非常容易。在向下的过程中功能当看到一个节点X有两个红儿子的时候，可使X呈红色而他的两个儿子是黑色的。（如果X是根，则在颜色旋转后他将是红色的，但是为恢复性质2可以直接着成黑色）<br>下图显示这种颜色反转的现象，只有当X的父节点P也是红色的时候这种反转将破坏红黑的法则。<br><img src="/img/RedBlackTree/2.png" alt="github"><br><strong>颜色翻转：只有当X的父节点是红色的时候我们才能继续旋转。</strong><br><img src="/img/RedBlackTree/4.png" alt="github"><br>此时可以进行适当的旋转。如果X的父节点的兄弟是红色会怎样，这周可能已经被从顶向下过程中的行动所排出，因此X的父节点的兄弟不可能是红色。特别的，如果在延树向下的过程中我们看到一个节点Y有两个红儿子，那么我们知道Y的孙子必然是黑的，由于Y的儿子也要变成黑的，升职在可能发生的旋转之后，因此我们将不会看到两层上另外的红节点。这样我们看到X，若X的父节点是红色的，则X的父节点的兄弟不可能也是红色的。</p><p>例如，假设要将45插入到下面的树中。在延树向下的过程中，我们看到50有两个红儿子。因此我们执行一次颜色翻转，使50位红的，40和55为黑的。<br>现在50和60都是红的，在60和70之间执行单旋转，使得60时30的右子树的黑根，而70和50都是红的。<br>如果我们在路径上看到另外的含有两个红儿子的节点，那么我们继续执行统一的操作。当我们达到树叶时，把45作为红节点插入，由于父节点使黑的，因此插入完成得到最后的结果。<br><img src="/img/RedBlackTree/3.png" alt="github"><br>最后得到了平衡的红黑树。红黑树的优点是执行插入所需要的开销相对较低，另外就是实践中发生的旋转相对较少。（相较于AVL树）</p><p>红黑树的具体实现时很复杂的，这不仅因为有大量可能的旋转，而且还因为一些子树可能是空的，以及处理根的特殊的情况（尤其是根没有父亲）。<br>因此，我们使用两个标记节点：一个是根，一个是NulNode，他的作用像在伸展树中那样指示一个null引用。根标记将存储关键字∞和一个只想真正的根的右链。<br>为此，查找和输出过程均需要调整。递归的历程都很巧妙。下面代码中指出如何重新编写中序遍历<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public void print<span class="hljs-constructor">Tree()</span> &#123;<br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Empty()</span>)<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;empty tree&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        print<span class="hljs-constructor">Tree(<span class="hljs-params">header</span>.<span class="hljs-params">right</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> void print<span class="hljs-constructor">Tree(RedBlackNode&lt;AnyType&gt; <span class="hljs-params">t</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (t != nullNode) &#123;<br>        print<span class="hljs-constructor">Tree(<span class="hljs-params">t</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(t.element);<br>        print<span class="hljs-constructor">Tree(<span class="hljs-params">t</span>.<span class="hljs-params">right</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>下面代码显示RedBlackTree架构（省去了其中的一些成员方法）以及构造方法。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">RedBlackTree</span>&lt;<span class="hljs-symbol">AnyType</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Comparable</span>&lt;? <span class="hljs-symbol">super</span> <span class="hljs-symbol">AnyType</span>&gt;&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> RedBlackNode&lt;AnyType&gt; header;<br>    <span class="hljs-keyword">private</span> RedBlackNode&lt;AnyType&gt; <span class="hljs-literal">null</span>Node;<br>    <br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> BLACK = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> RED = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> RedBlackTree() &#123;<br>        <span class="hljs-literal">null</span>Node = new RedBlackTree&lt;AnyType&gt;(<span class="hljs-literal">null</span>);<br>        <span class="hljs-literal">null</span>Node.left = <span class="hljs-literal">null</span>Node.right = <span class="hljs-literal">null</span>Node;<br>        header = new RedBlackTree&lt;AnyType&gt;(<span class="hljs-literal">null</span>);<br>        header.left = header.right = <span class="hljs-literal">null</span>Node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> <span class="hljs-symbol">RedBlackNode</span>&lt;<span class="hljs-symbol">AnyType</span>&gt; &#123;<br>        <span class="hljs-comment">// 数值</span><br>        AnyType element;<br>        <span class="hljs-comment">// 左节点</span><br>        RedBlackNode&lt;AnyType&gt; left;<br>        <span class="hljs-comment">// 右节点</span><br>        RedBlackNode&lt;AnyType&gt; right;<br>        <span class="hljs-comment">// 颜色</span><br>        <span class="hljs-built_in">int</span> color;<br>    <br>        RedBlackNode(AnyType theElement) &#123;<br>            <span class="hljs-keyword">this</span>(theElement, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>    <br>        RedBlackNode(AnyType theElement, RedBlackNode&lt;AnyType&gt; lt, RedBlackNode&lt;AnyType&gt; rg) &#123;<br>            element = theElement; left = lt; right = rt; color = RedBlackTree.BLACK;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>下面则显示执行一次单旋转的例子，因为所得到的数必须要附接到一个父节点上，所以rotate把父节点作为一个参数。我们把item作为一个参数传递而不是在延树下行时记录旋转的类型。<br>由于期望在插入过程中进行很少的旋转，因此使用这个这种方式实际上不仅更简单，而且还更快。rotate直接返回执行一次适当的单旋转的结果。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> RedBlackNode&lt;AnyType&gt; rotate(AnyType item, RedBlackNode&lt;AnyType&gt; parent) &#123;<br>    <span class="hljs-keyword">if</span> (compare(item, parent) &lt; <span class="hljs-number">0</span>) <br>        return parent.left = compare(item, parent.left) &lt; <span class="hljs-number">0</span> ?<br>            rotate<span class="hljs-constructor">WithLeftChild(<span class="hljs-params">parent</span>.<span class="hljs-params">left</span>)</span> : <br>            rotate<span class="hljs-constructor">WithRightChild(<span class="hljs-params">parent</span>.<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-keyword">else</span><br>        return parent.right = compare(item, parent.right) &lt; <span class="hljs-number">0</span> ?<br>            rotate<span class="hljs-constructor">WithLeftChild(<span class="hljs-params">parent</span>.<span class="hljs-params">right</span>)</span> : <br>            rotate<span class="hljs-constructor">WithRightChild(<span class="hljs-params">parent</span>.<span class="hljs-params">right</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> final <span class="hljs-built_in">int</span> compare(AnyType item, RedBlackNode&lt;AnyType&gt; t) &#123;<br>    <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>header)<br>        return <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        return item.compare<span class="hljs-constructor">To(<span class="hljs-params">t</span>.<span class="hljs-params">element</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>下面则给出了插入过程。handleReorient当我们遇到带有两个红儿子的节点时被调用，在我们插入一片树叶时他也被调用。最为复杂的部分时，一个双旋转实际上是两个单旋转，而且只有当通向X的分值（在insert方法中由current表示）去相反方向时才进行。正如我们在较早的讨论中提到的，当延树向下进行的时候，insert必须记录父亲、祖父和曾祖。<br>由于这些量要由handleReorient共享，因此让他们时类成员。<br>注意，在一次旋转之后，存储在祖父和饿曾祖父节点中的值将不再正确。不会肯定到下一次在需要他们的时候他将被修复。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; current;<br><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; parent;<br><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; grand;<br><span class="hljs-keyword">private</span> RedBlack&lt;AnyType&gt; great;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> handleReorient(AnyType item) &#123;<br>    current.<span class="hljs-built_in">color</span> = RED;<br>    current.left.<span class="hljs-built_in">color</span> = BLACK;<br>    current.right.<span class="hljs-built_in">color</span> = BLACK;<br>    <span class="hljs-keyword">if</span> (parent.<span class="hljs-built_in">color</span> == RED) &#123;<br>        grand.<span class="hljs-built_in">color</span> = RED;<br>        <span class="hljs-comment">// 双旋转中的单旋转</span><br>        <span class="hljs-comment">// 判断添加为下面情况则需要进行双旋转</span><br>        <span class="hljs-comment">//          GP</span><br>        <span class="hljs-comment">//        /</span><br>        <span class="hljs-comment">//      P</span><br>        <span class="hljs-comment">//    /    \</span><br>        <span class="hljs-comment">//   C    (item)</span><br>        <span class="hljs-keyword">if</span> ((compare(item, grand) &lt; <span class="hljs-number">0</span>) != (compare(item, parent) &lt; <span class="hljs-number">0</span>))<br>            parent = <span class="hljs-built_in">rotate</span>(item, great);<br>        <span class="hljs-comment">// 单旋转</span><br>        current = <span class="hljs-built_in">rotate</span>(item, great);<br>        current.<span class="hljs-built_in">color</span> = BLACK;<br>    &#125;<br>    header.right.<span class="hljs-built_in">color</span> = BLACK;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> insert(AnyType item) &#123;<br>    current = parent = grand = header;<br>    nullNode.element = item;<br>    <br>    <span class="hljs-keyword">while</span>(compare(item, current) != <span class="hljs-number">0</span>) &#123;<br>        great = grand;<br>        grand = parent;<br>        parent = current;<br>        current = compare(item, current) &lt; <span class="hljs-number">0</span>? current.left : current.right;<br>        <br>        <span class="hljs-comment">// 两个儿子为红色</span><br>        <span class="hljs-keyword">if</span> (current.left.<span class="hljs-built_in">color</span> == RED &amp;&amp; current.right.<span class="hljs-built_in">color</span> == RED)<br>            handleReorient(item);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (current != nullNode) <br>        <span class="hljs-keyword">return</span>;<br>    current = <span class="hljs-keyword">new</span> RedBlackNode&lt;AnyType&gt;(item, nullNode, nullNode);<br>    <br>    <span class="hljs-keyword">if</span> (compare(item, parent) &lt; <span class="hljs-number">0</span>)<br>        parent.left = current;<br>    <span class="hljs-keyword">else</span><br>        parent.right = current;<br>    <span class="hljs-comment">// 单旋转</span><br>    handleReorient(item);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="自顶向下的删除"><a href="#自顶向下的删除" class="headerlink" title="自顶向下的删除"></a>自顶向下的删除</h2><p>红黑树中的删除也可以自顶向下进行。每一件工作都归结于能够删除树叶。这是因为，要删除一个带有两个儿子的节点，用右子树上的最小节点代替他；该节点必然最多有一个儿子，然后将该节点删除。只有一个右儿子的节点可以用相同的方式删除，而只有一个左儿子的节点通过用其左子树上最大节点替换而被删除，然后再将该节点删除。<br>注意，对于红黑树，我们不要使用绕过带有一个儿子的节点的情形的方法，因为这可能在树的中部连接两个红色节点，增加红黑条件实现的困难。</p><p>当然，红色树叶的删除很简单。但是如果一片黑色树叶，那么删除操作会复杂多，因为黑色节点的删除会破坏规则4.解决方法是保证从上到下删除期间树叶是红色的。<br>在整个讨论中，令X为当前节点，T是他的兄弟，P是他们的父亲。开始时我们把树的根涂成红色。当延树向下遍历时，我们设法保证X是红色的。当到达一个新的节点时，我们要确信P是红色的并且X和T是黑色的。这存在两个主要的情况。</p><p>首先，设定X右两个黑儿子。此时有三种子情况，如下图</p><ol><li>如果T也有两个黑儿子，那么可以翻转X、T和P的颜色来保持这种不变形。<br><img src="/img/RedBlackTree/5.png" alt="github"></li><li>T的儿子之一是红的，根据哪个儿子是红的需要区分哪种旋转，需要特别注意，这种情形对于树叶是适用的，因为nullNode为黑。<br><img src="/img/RedBlackTree/6.png" alt="github"></li></ol><p>其次，X的儿子之一是红的，在这种情形下，我们落到下一层上，得到新的X、T和P。<br>如果幸运，X落在的红儿子上，则我们可以继续向前进行。如果不是，那么我们就知道T将是红的，而X和P都将是黑的。我们就可以旋转T和P，使得X的新父亲是红的；<br><img src="/img/RedBlackTree/7.png" alt="github"></p><ol><li>下坠</li><li>变换</li><li>旋转</li><li>根据规则变色</li><li>颜色反转</li><li>删除</li></ol><h2 id="确定性跳跃表"><a href="#确定性跳跃表" class="headerlink" title="确定性跳跃表"></a>确定性跳跃表</h2><p>用于红黑树的一些想法可以应用到跳跃表以保证对数最坏情况操作。这里我们描述所得到数据结构的最简单的实现方法，1-2-3确定性跳跃表。<br>跳跃表中的节点随机指定了高度。高度为h的节点包含h个前向链p1,p2,p3…Ph,Pi链接到高度为i或更大的下一个节点。一个节点具有高度h的概率为0.5^h(为了实现时/空交换，0.5可以用0到1.0之间的任何数来代替)。因此，我们期望只处理一些前向链直到下降一层；由于有大约logN层，因此我们得到每次操作花费O(logN)的期望运行时间。<br>为使这个界称为最坏情形的界，我们需要保证只有常数个前向链从一个元素指向另一个元素。<br><strong>定义1：两个元素称为是链接的，如果至少存在一个链从一个元素指向另一个元素。</strong><br><strong>定义2：两个在高度h上连接的元素间的间隙容量等于他们之间高度为h-1的元素数量</strong></p><p>1-2-3确定性跳跃表满足一下性质：每一个间隙（除在头和尾之间）的容量为1、2或3。<br>例如下图，显示了一个1-2-3确定性跳跃表。该表有两个容量为3的间隙；第一个是35和45之间有高度为1的三个元素，第二个是在表头和表尾之间有高度为2的三个元素。尾节点包含∞，他的出现简化了算法并使得定义表终端间隙的概念更容易。<br><img src="/img/RedBlackTree/8.png" alt="github"></p><p>显然，沿任一层行进仅仅通过常数个链就可以下降到低一层。因此，在最坏的情形下查找的时间是O(log N)。<br>为了执行插入，我们必须保证当一个高度为h的新节点加入进来不会产生具有4个高度为h的节点间隙。实际上很简单，我们采用类似于在红黑树中所做的自顶向下的策略即可。</p><p>设我们在L层上，并正要降到下一层去。如果要降到的间隙容量是3，那么我们提高该间隙的中间项使其高度为L，从而形成两个容量为1的间隙。由于这使得朝向插入的道路上消除了容量为3的间隙，因此插入是安全的。</p><p>例如下面将27插入到表中。<br><img src="/img/RedBlackTree/10.png" alt="github"></p><ol><li>从第三层降到第二层</li><li>由于降落到容量为3的间隙，因此这里需要将中间项上升到3的高度，并在表中拼接。</li><li>下降到第一层，又见到容量为3的间隙，因此把35提升到高度2</li><li>最后插入到表中。</li></ol><p>删除的困难是出现在间隙容量为1的情况。当我们看到将要下降到一个容量为1的间隙时，我们要把这个间隙放大，或者是通过从相邻间隙（如果容量不为1）借来的方式，或者通过将该间隙与邻间隙分开的节点的高度降低的方式。由于这两个都是容量为1的间隙，因此结果变成容量为3的间隙。由于有几种情况要处理，因此程序比我们的描述稍微复杂一点。<br>第一个重要的细节是，当我们将一个高h的节点提升到高h+1的时候，我们不能花费时间O(h)用来奖h个链拷贝到一个新数组。否则插入的时间就要成为O(log^2 N)。一种方法是用一个链表来表示高度为h的节点中的h个前向链。由于我们是沿着各层向下进行，因此一个节点的链表是以第h层前向链开始并以第一层前向链结束<br>第二个优化更复杂且可能占用更多的空间。我们不是把节点作为一项和前向链的链表来存储，而且是存储前向链和前向项对的链表。理解其含义的最容易的方法是下图，我们将使用术语<strong>抽象</strong>或<strong>逻辑</strong>来表示。<br><img src="/img/RedBlackTree/11.png" alt="github"></p><p>注意，除了尾节点被删除外，抽象表示和实际实现二者的地平线是一样的。我们的实现中，每一个节点都留有使我们下降一层的链，指向同层上的下一个节点的链以及逻辑上存储在下一项中的项。<br>有些项的出现是多于一次的。例如25出现了三个地方。事实上，如果一个节点在抽象表示中的高度为h，那么他的项在实际实现中就会出现h个地方。部分重要的结论和结果需要在实现方法后进行解释。<br>基本节点由一个项和两个链组成。为了使编程更快更简单，我们使用了尾节点。如果不能够或不希望赋值♾，那么就必须使用其他方式。</p><p>我们对头节点和底层节点都有一个标记以代替null链。SkipNode类和DSL构造方法如下：<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DSL&lt;AnyType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable&lt;?</span> <span class="hljs-title">super</span> <span class="hljs-title">AnyType&gt;&gt;</span> </span>&#123;<br>    public <span class="hljs-type">DSL</span>(<span class="hljs-type">AnyType</span> inf) &#123;<br>        infinity = inf;<br>        bottom = <span class="hljs-keyword">new</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt;(<span class="hljs-literal">null</span>);<br>        bottom.right = bottom.down = bottom;<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt;(infinity);<br>        tail.right = tail;<br>        header = <span class="hljs-keyword">new</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt;(infinity, tail, bottom);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipNode&lt;AnyType&gt;</span> </span>&#123;<br>        <span class="hljs-type">SkipNode</span>(<span class="hljs-type">AnyType</span> theElement) &#123;<br>            <span class="hljs-keyword">this</span>(theElement, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <br>        <span class="hljs-type">SkipNode</span>(<span class="hljs-type">AnyType</span> theElement, <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; rt, <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; dt) &#123;<br>            element = theElement;<br>            right = rt;<br>            down = dt;<br>        &#125;<br>        <br>        <span class="hljs-type">AnyType</span> element;<br>        <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; right;<br>        <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; down;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AnyType</span> infinity;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; header;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; bottom = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SkipNode</span>&lt;<span class="hljs-type">AnyType</span>&gt; tail = <span class="hljs-literal">null</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p><p>查找函数与随机化跳跃表的查找函数相同。下面代码中如果我们得不到匹配的项，那么或者向下进行，或者向右进行，这依赖于比较的结果。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> contains(AnyType x) &#123;<br>    SkipNode&lt;AnyType&gt; <span class="hljs-keyword">current</span> = <span class="hljs-keyword">header</span>;<br>    bottom.element = x;<br>    <span class="hljs-keyword">for</span>( ; ; ) &#123;<br>        <span class="hljs-type">int</span> compareResult = x.compareTo(<span class="hljs-keyword">current</span>.element);<br>        <span class="hljs-keyword">if</span> (compareResult &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.down<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareResult &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.right<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span> != bottom<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>下面则是插入操作，由于标记的引入而大大的得到简化。利用某些繁琐的链跟踪可以看到，如果对每一个链是否是null进行测试，那么可能将代码扩大三倍。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">insert</span>(AnyType x) &#123;<br>    SkipNode&lt;AnyType&gt; <span class="hljs-keyword">current</span> = <span class="hljs-keyword">header</span>;<br>    <br>    bootom.element = x;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != bottom) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>.element.compareTo(x) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.right;<br>            <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span>.down.right.right.element.compareTo(<span class="hljs-keyword">current</span>.elemenmt) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">current</span>.right = <span class="hljs-built_in">new</span> SkipNode&lt;AnyType&gt;(<span class="hljs-keyword">current</span>.element, <span class="hljs-keyword">current</span>.right, <span class="hljs-keyword">current</span>.down.right.right);<br>            <span class="hljs-keyword">current</span>.element = <span class="hljs-keyword">current</span>.down.right.element;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.down;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">header</span>.right != tail)<br>        <span class="hljs-keyword">header</span> = <span class="hljs-built_in">new</span> SkipNode&lt;AnyType&gt;(<span class="hljs-keyword">infinity</span>, tail, <span class="hljs-keyword">header</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>确定性跳跃表插入过程的程序多少要短一些，考虑的情况比红黑树少得多。我们所付出的代价只有空间：在最坏情况下我们有2N个节点，每一个节点包含两个链和一个项。<br>对于红黑树，我们有N个节点，每一个节点包含两个链、一项以及一个颜色位。因此我们可能要用两倍多的空间。经验指出确定性跳跃表平均使用1.57N个节点，其次某些情况下，确定性跳跃表实际使用的空间少于红黑树。</p><p>有一个适用于C/C++的实际例子。在32位机器上，链和整数是4个字节。对于某些系统，包括某些UNIX，内存时按块(chunk)来培植的，他们通常是2的幂，但存储管理程序使用4个字节的块。于是对于12个字节的请求将得到一个16字节块，即12个字节用户使用而剩下4个字节作为系统开销。<br>但是对于13个字节的需求则必须提供一个32字节块。因此，这种情况下，确定性跳跃表每个节点使用16个字节，而平均有1.57个N，因此总数一般有25N个字节。可是红黑树却使用32N个字节。这说明在某些机器上一个附加位(bit)是非常昂贵的。这是自组织结构的吸引力之一。</p><p><img src="/img/RedBlackTree/12.png" alt="github"><br>确定性跳跃表的性能似乎比红黑树要强。当寻找插入时间的改进时，下面代码包含有逻辑测试：<br><code>if (current.down.right.right.element.compareTo(current.elemenmt) &lt; 0)</code><br>如果我们把一些项存储在最多三个元素的一个数组中，那么对于第三项的访问可以直接进行，而不用再通过两个right链。上面图中所表示的结构，具有讽刺意味的是，这个结构很像B-树。称之为1-2-3确定性跳跃表的水平数组实现。</p>]]></content>
    
    
    <summary type="html">红黑树</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2023/07/25/HashMap/"/>
    <id>http://example.com/2023/07/25/HashMap/</id>
    <published>2023-07-25T22:31:46.000Z</published>
    <updated>2023-07-31T08:10:07.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在 JDK1.8 中，HashMap 是由 数组+链表+红黑树构成(1.7版本是数组+链表)<br><img src="/img/HashMap/0.png" alt="github"><br>当一个值中要存储到HashMap中的时候会根据Key的值来计算出他的hash，通过hash值来确认存放到数组中的位置，如果发生hash冲突就以链表的形式存储，当链表过长的话，HashMap会把这个链表转换成红黑树来存储。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 默认初始容量大小：2的4次方 16 0</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">//最大容量：2的30次方,Integer.MAX_VALUE</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">//默认加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-comment">//计数阈值至少为8转化为使用树而不是列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">//计数阈值小于6反树化，即红黑树转为列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">//可对桶进行树化的最小表容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-comment">//表在第一次使用时初始化，大小调整为必要的。在分配时，长度总是2的幂。在某些操作中，我们也允许长度为零。目前不需要的引导机制。) </span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">//保存缓存的entrySet()</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">//包含的键值映射的元素数量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;<br><br><span class="hljs-comment">//HashMap在结构上被修改的次数，用于快速失败机制</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">// 调整大小的阈值(容量*负载因子)</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">//哈希表扩容使用的负载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></td></tr></table></figure><blockquote><p>这里需要注意的一点是table数组并不是在构造方法里面初始化的，它是在resize(扩容)方法里进行初始化的。</p></blockquote><h2 id="Node的数据结构"><a href="#Node的数据结构" class="headerlink" title="Node的数据结构"></a>Node的数据结构</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; <span class="hljs-keyword">next</span>;<br><br>    Node(<span class="hljs-built_in">int</span> hash, K key, V value, Node&lt;K,V&gt; <span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Node的数据结构是一个链表结构，红黑树也是基于Node的数据结构构建得到。<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">TreeNode<span class="hljs-tag">&lt;K,V&gt;</span> replacementTreeNode(<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; p, <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; next) &#123;<br>    return new TreeNode<span class="hljs-tag">&lt;&gt;</span>(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params">int initialCapacity, float loadFactor</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">// 根据tableSizeFor获取扩容阈值</span><br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params">int initialCapacity</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashMap</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当初始容量initialCapacity大于最大容量MAXIMUM_CAPACITY大小时，设置成最大容量MAXIMUM_CAPACITY大小，防止溢出。</li></ul><p>根据tableSizeFor获取扩容阈值。<br><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>对任意十进制数转换为2的整数幂，结果是这个数本身的最高有效位的前一位变成1，最高有效位以及其后的位都变为0。</p><p>核心思想是，先将最高有效位以及其后的位都变为1，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是如何将最高有效位后面都变为1。</p><p>此时这里的阈值threshold不是初始容量*负载因子，不必在意，这只是临时的，真正设置threshold在后面put方法中。</p><p>当数组长度为2的幂次方时，可以使用位运算来计算元素在数组中的下标。<br>HashMap是通过<code>index=hash&amp;(table.length-1)</code>这条公式来计算元素在table数组中存放的下标，就是把元素的hash值和数组长度减1的值做一个与运算，即可求出该元素在数组中的下标，这条公式其实等价于<code>hash%length</code>，也就是对数组长度求模取余，<code>只不过只有当数组长度为2的幂次方时，hash&amp;(length-1)才等价于hash%length</code>，使用位运算可以提高效率。</p><p>另外增加hash值的随机性，减少hash冲突。<br>如果 length 为 2 的幂次方，则 length-1 转化为二进制必定是 11111……的形式，这样的话可以使所有位置都能和元素hash值做与运算，如果是如果 length 不是2的次幂，比如length为15，则length-1为14，对应的二进制为1110，在和hash 做与运算时，最后一位永远都为0 ，浪费空间。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    // 调用putVal方法， hash(<span class="hljs-built_in">key</span>)-计算<span class="hljs-built_in">key</span>的hash值<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里分别调用了两个方法。</p><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-built_in">int</span> h;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算key.hashCode()并将哈希的高位数扩展到低位数。</p><ul><li>key.hashCode()获取key的hashCode值</li><li>key的hashCode值与其无符号右移16位值进行异或^。从而让Hash值分布更均匀，右移16位就能让低16位和高16位进行异或，将高位的碰撞影响向下扩散，为了增加hash值的随机性。</li></ul><h2 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">final</span> V putVal(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    <span class="hljs-comment">// 指向hash数组</span><br>    Node&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// 初始化为table中第一个节点</span><br>    Node&lt;K,V&gt; p; <br>    <span class="hljs-comment">// n为数组长度</span><br>    <span class="hljs-comment">// i为索引</span><br>    <span class="hljs-built_in">int</span> n, i;<br>    <span class="hljs-comment">// 如果数组为空，进行 resize() 初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash相当于取模，获取数组的索引位置</span><br>    <span class="hljs-comment">// 如果计算的位置上Node不存在，直接创建节点插入</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果计算的位置上Node 存在，链表或者红黑树处理</span><br>        <span class="hljs-comment">// 果要插入的key-value已存在，用e指向该节点</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果已存在的key和传入的key一模一样，则需要覆盖</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 如果是红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 将元素put到红黑树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, <span class="hljs-built_in">key</span>, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则如果是链表的情况，对链表进行遍历，并统计链表长度binCount</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 如果节点链表的next为空</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 找到节点链表中next为空的节点，创建新的节点插入</span><br>                    p.next = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 如果节点链表中数量超过TREEIFY_THRESHOLD（8）个，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">// 树化</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断节点链表中的key和传入的key是否一样</span><br>                <span class="hljs-comment">// 如果要插入的key-value已存在则终止遍历，否则向后遍历</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    <span class="hljs-comment">// 如果一样的话，退出</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果e不为null说明要插入的key-value已存在</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">// 设置新的值</span><br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧的结果</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 当前大小大于临界大小，扩容</span><br>    <span class="hljs-keyword">if</span> (++<span class="hljs-built_in">size</span> &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>putVal</code>方法总结归纳主要做了如下几件事：</p><ol><li>当桶数组 table 为空时，通过扩容的方式初始化 table。</li><li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值。</li><li>如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树。</li><li>判断键值对数量是否大于阈值，大于的话则进行扩容操作。</li></ol><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">final Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">// 现有容量的大小，等于数组的长度，如果数组为空，返回0</span><br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    <span class="hljs-comment">// 现有的扩容阈值</span><br>    int oldThr = threshold;<br>    <span class="hljs-comment">// newCap表示新的容量，newThr新的扩容阈值</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果现有容量大于0，表示已经初始化过了</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果现有容量已经大于最大容量。结束扩容，直接返回</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>         <span class="hljs-comment">// 否则，如果扩大两倍之后的容量小于最大容量，且现有容量大于等于初始容量16    </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>             <span class="hljs-comment">// 新的扩容阀值扩大为两倍，左移&lt;&lt;1 相当于乘以2</span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 若数组未被初始化，而threshold&gt;0说明调用了HashMap(initialCapacity)和HashMap(initialCapacity, loadFactor)构造器</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)<br>         <span class="hljs-comment">// 进入这里，新的容量等于当前的扩容阈值，</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-comment">// 若table数组未被初始化，且threshold为0说明调用HashMap()构造方法</span><br>    <span class="hljs-keyword">else</span> &#123;               <br>        <span class="hljs-comment">// 新的容量等于默认容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-comment">// 新的扩容阈值等于默认负载因子0.75*默认容量16=12</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 如果新的扩容阈值等于0</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 设置新的扩容阈值等于新的容量*负载因子</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?<br>                  (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// 设置hashmap对象的扩容阈值位新的扩容阈值</span><br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    @SuppressWarnings(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>    <span class="hljs-comment">// 初始化数组     </span><br>    Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    <span class="hljs-comment">// 设置hashmap对象的桶数组为newTab</span><br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-comment">// 下面是rehash的过程</span><br>    <span class="hljs-comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历老的数组</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-comment">// 如果数组索引位置不为空</span><br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果节点下面没有链表或者红黑树，只链接一个节点</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 用新数组容量取模，设置到新数组中</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果节点是红黑树    </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 需要对红黑树进行拆分</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-comment">// 如果节点是链表 </span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                     <span class="hljs-comment">// 遍历链表，并将链表节点按原顺序根据高低位分组</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 使用的是：e.hash &amp; oldCap，若为0则索引位置不变，不为0则新索引=原索引+旧数组长度</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                     <span class="hljs-comment">// 将分组后的链表映射到新桶中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>resize</code>方法大致做了如下的事情：</p><ol><li>计算新桶数组的容量 newCap 和新阈值 newThr。</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的。</li><li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通链表节点，则节点按原顺序进行分组。</li></ol><p><strong>通过hash &amp; oldCap的值来判断，若为0则索引位置不变，不为0则新索引=原索引+旧数组长度</strong><br>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap</p><p>把链表转换成红黑树，树化需要满足以下两个条件：</p><ul><li>链表长度大于等于8</li><li>table数组长度大于等于64</li></ul><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h2><figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">final Node&lt;K,V&gt; getNode(<span class="hljs-type">int</span> hash, Object <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-comment">// 指向hash数组</span><br>    Node&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// first指向hash数组链接的第一个节点，e指向下一个节点</span><br>    Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; <br>    <span class="hljs-comment">// n:hash数组长度</span><br>    <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 定位键值对所在桶的位置</span><br>    if ((tab = table) != <span class="hljs-built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">//(n - 1)&amp; hash相当于取模运算，算出桶的在桶数组中的位置</span><br>        (<span class="hljs-built_in">first</span> = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-built_in">null</span>) &#123;<br>        <span class="hljs-comment">//根据hash算法找到对应位置的第一个数据，如果是指定的key，则直接返回</span><br>        if (<span class="hljs-built_in">first</span>.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            return <span class="hljs-built_in">first</span>;<br>        if ((e = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>) &#123;<br>            <span class="hljs-comment">//如果该节点为红黑树，则通过树进行查找</span><br>            if (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                return ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(hash, <span class="hljs-built_in">key</span>);<br>            <span class="hljs-comment">//如果该节点是链表，则遍历查找到数据</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                if (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    return e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-built_in">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致逻辑如下：</p><ol><li>根据hash值查找到指定位置的数据。</li><li>校验指定位置第一个节点的数据是key是否为传入的key，如果是直接返回第一个节点，否则继续查找第二个节点。</li><li>如果数据是TreeNode（红黑树结构），直接通过红黑树查找节点数据并返回。</li><li>如果是链表结构，循环查找所有节点，返回数据。</li><li>如果没有找到符合要求的节点，返回null。</li></ol><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V remove(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="removeNode方法"><a href="#removeNode方法" class="headerlink" title="removeNode方法"></a>removeNode方法</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">final <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) &#123;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;[] tab; <br>    <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; p; <br>    int n, index;<br>    //定位元素桶位置<br>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != null) &#123;<br>        <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt; <span class="hljs-keyword">node</span> <span class="hljs-title">= null</span>, e; <br>        K k; <br>        V v;<br>        // 如果键的值与链表第一个节点相等，则将 <span class="hljs-keyword">node</span> <span class="hljs-title">指向该节点</span><br><span class="hljs-title">        if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">node</span> <span class="hljs-title">= p</span>;<br>        else if ((e = p.next) != null) &#123;  <br>            // 如果是红黑树类型，调用红黑树的查找逻辑定位待删除节点<br>            if (p instanceof TreeNode)<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= ((TreeNode</span><span class="hljs-tag">&lt;K,V&gt;</span>)p).getTreeNode(hash, key);<br>            else &#123;<br>                // 遍历链表，找到待删除节点<br>                do &#123;<br>                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;<br>                        <span class="hljs-keyword">node</span> <span class="hljs-title">= e</span>;<br>                        break;<br>                    &#125;<br>                    p = e;<br>                &#125; while ((e = e.next) != null);<br>            &#125;<br>        &#125;        <br>        //删除节点，并修复链表或红黑树<br>        if (<span class="hljs-keyword">node</span> <span class="hljs-title">!= null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123;<br>            if (<span class="hljs-keyword">node</span> <span class="hljs-title">instanceof</span> TreeNode)<br>                ((TreeNode<span class="hljs-tag">&lt;K,V&gt;</span>)<span class="hljs-keyword">node</span><span class="hljs-title">).removeTreeNode</span>(this, tab, movable);<br>            else if (<span class="hljs-keyword">node</span> <span class="hljs-title">== p</span>)<br>                tab[index] = node.next;<br>            else<br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">            return</span> <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        &#125;</span><br><span class="hljs-title">    &#125;</span><br><span class="hljs-title">    return</span> null;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅需三个步骤即可完成。</p><ol><li>定位桶位置</li><li>遍历链表找到相等的节点</li><li>第三步删除节点</li></ol>]]></content>
    
    
    <summary type="html">HashMap</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用JNI构建环境</title>
    <link href="http://example.com/2023/07/25/Java_JNI/"/>
    <id>http://example.com/2023/07/25/Java_JNI/</id>
    <published>2023-07-25T19:22:35.000Z</published>
    <updated>2023-07-25T03:07:33.439Z</updated>
    
    <content type="html"><![CDATA[<p>如果熟悉Android的朋友应该会有影响，Gradle会帮我们把Java和JNI进行捆绑，方便开发。而Java则会复杂一点，gradle的工作都需要我们来做。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>macos X86_64<br>java 1.8<br>模拟环境 springboot<br>包结构<br><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">project<br>    +-build<br>    +-src<br>    <span class="hljs-string">|  +-main</span><br>    <span class="hljs-string">|     +-cpp</span><br>    <span class="hljs-string">|     +-java</span><br>    <span class="hljs-string">|     +-resources</span><br>    <span class="hljs-string">|           +JniLibs</span><br>    <span class="hljs-string">|</span><br>    +-CMakeLists.txt<br>    +-pom.xml<br></code></pre></td></tr></table></figure><br>可以看到<code>cpp</code>中存放我们的c/c++代码，java中有我们的业务功能以及匹配<code>cpp</code>的jni接口文件，<code>resources</code>中的<code>JniLibs</code>存放的是生成的静态、动态库文件。<br><code>CMakeList.txt</code>则是我们c/c++代码的管理包，这里面需要配置本地的编译环境及生产静态、动态库的库管理。<br>最后<code>build</code>是我们在打包动态链接库的时候生成的临时文件夹。</p><p>开发工具：IDEA、CLION<br>这里推荐Clion是方便开发c/c++代码。</p><h2 id="准备JNI-Java部分代码"><a href="#准备JNI-Java部分代码" class="headerlink" title="准备JNI Java部分代码"></a>准备JNI Java部分代码</h2><p>首先是构建java开发环境及工程，这里就略过了。然后在<code>java</code>文件夹中，创建与C沟通的JNI接口文件:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNative</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;PrintNative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><code>static</code>让其在加载类的时候同时加载本地的资源<code>PrintNative</code>文件。但是目前还没有，我们后续在建。</p><p>接下来，需要对这个文件进行编译，转为头文件：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">cd <span class="hljs-keyword">project</span><span class="hljs-regexp">/src/m</span>ain/java<br><br>javac com<span class="hljs-regexp">/xx/</span>x/PrintNative.java<br>javah com.xx.x.PrintNative<br></code></pre></td></tr></table></figure><br>完成后会生成对应的class文件和头文件，class文件可以删除掉，我们需要的是<code>.h</code>的头文件。我们需要将头文件移动到<code>src/main/cpp/include</code>文件夹下面。</p><h2 id="构建C-C-项目"><a href="#构建C-C-项目" class="headerlink" title="构建C/C++项目"></a>构建C/C++项目</h2><p>首先创建<code>CMakeLists.txt</code>文件，根据上面的路径创建，填入下面内容:<br><figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span>.<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-keyword">add_definitions</span>(-std=c++<span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">set</span>(java_home <span class="hljs-string">&quot;xxxxx/jdk1.8.0_101.jdk/Contents/Home/&quot;</span>)<br><span class="hljs-keyword">set</span>(jdk_home <span class="hljs-string">&quot;xxxxxx/jdk1.8.0_101.jdk/Contents/Home/&quot;</span>)<br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;jdk_home&#125;</span>/<span class="hljs-keyword">include</span>/<br>                    <span class="hljs-variable">$&#123;jdk_home&#125;</span>/<span class="hljs-keyword">include</span>/darwin/<br>                    src/main/cpp/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">add_library</span>(<br>        PrintNative<br>        SHARED<br>        src/main/cpp/print-native.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(PrintNative)<br></code></pre></td></tr></table></figure><br>首先建立了cmake版本、项目的名称、c++版本。<br>然后创建了两个path路径，这里需要根据自己电脑来获取。<br>接下来需要指定include文件夹路径，这里我们需要三个，前两个是java中的头文件路径，最后一个是我们项目中的头文件路径。<br>最后就是建立当前库名称、动态/静态、cpp文件进行打包、链接，这里我们并没有其他的库添加到项目中，因此比较简单。</p><p>上面我们添加了一个cpp文件，因此我们就在这个目录下创建这个文件即可。</p><h2 id="编写测试用的cpp文件"><a href="#编写测试用的cpp文件" class="headerlink" title="编写测试用的cpp文件"></a>编写测试用的cpp文件</h2><p>下面是我们创建的头文件<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span><br><span class="hljs-comment">/* Header for class xx_xx_x_PrintNative */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _Included_xx_xx_x_PrintNative</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _Included_xx_xx_x_PrintNative</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Class:     xx_xx_x_PrintNative</span><br><span class="hljs-comment"> * Method:    print</span><br><span class="hljs-comment"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="hljs-comment"> */</span><br>JNIEXPORT <span class="hljs-keyword">void</span> JNICALL Java_xx_xx_x_PrintNative_print<br>  (JNIEnv *, jobject);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br>需要注意，在使用clion打开这个文件的时候，如果cmake配置错误，头文件第二行的<code>jni.h</code>库引用失败导致编译报错。</p><p>接下来就需要将这个定义的jni接口函数，复制到cpp中，并配置好括号即可。<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#include &quot;Java_xx_xx_xx_PrintNative.h&quot;</span><br><br><span class="hljs-keyword">JNIEXPORT </span>void <span class="hljs-keyword">JNICALL </span><span class="hljs-keyword">Java_xx_xx_x_PrintNative_print</span><br><span class="hljs-keyword"> </span> (<span class="hljs-keyword">JNIEnv </span>*, <span class="hljs-keyword">jobject) </span>&#123;<br>      <br>  &#125;<br></code></pre></td></tr></table></figure><br>这里引用了我们加入的头文件，以及对应的Jni接口函数。<br>接下来就可以进行编写工作。</p><h2 id="打包动态库"><a href="#打包动态库" class="headerlink" title="打包动态库"></a>打包动态库</h2><p>完成工作后，我们就需要开始打包。<br>首先在<code>CMakeLists.txt</code>文件的同级目录下，创建<code>build</code>文件夹。<br>然后在<code>build</code>文件的目录下运行下面的指令：<br><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">cmake -DCMAKE_BUILD_TYPE=Release ..<br><br>cmake --build .<br></code></pre></td></tr></table></figure><br>此时就会在该目录下生成动态链接库了，注意如果报错，部分问题可能是代码错误，部分问题可能是<code>CMakeLists.txt</code>配置错误。<br>由于我的电脑是mac环境，因此生产的文件是<code>libPrintNative.dylib</code>。因此将它复制到resources<code>中的</code>JniLibs`即可。</p><h2 id="java调用动态链接库"><a href="#java调用动态链接库" class="headerlink" title="java调用动态链接库"></a>java调用动态链接库</h2><p>最后我们就需要在java调用了。<br>首先需要修改<code>PrintNative</code>中的代码：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PrintNative &#123;<br><br>    static &#123;<br>        URL url = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PrintNative</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.get<span class="hljs-constructor">Resource(<span class="hljs-string">&quot;jniLibs/libPrintNative.dylib&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>load(url.get<span class="hljs-constructor">Path()</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><br>这里看到是根据路径进行添加，此时是为了我们后续更好的兼容其他版本的架构，因为并不可能只支持x86（假如）也有arm等架构需要支持，此时就需要在<code>jniLibs</code>文件夹下增加一层文件夹，命名就是架构名称，当服务启动时，首先需要检查当前架构名称，然后对该字符串进行拼接得到正确的链接库地址，进行链接即可。<br>修改完成后，就可以编写一个main来进行测试啦。</p><h2 id="特殊bug"><a href="#特殊bug" class="headerlink" title="特殊bug"></a>特殊bug</h2><p>需要注意在运行时可能会出现下面的异常<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">Caused by: java.lang.UnsatisfiedLinkError: <span class="hljs-regexp">/xxx/</span>target<span class="hljs-regexp">/classes/</span>lib<span class="hljs-regexp">/xxx.so: dlopen(/</span>xxx<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/lib/</span>xxx.so, <span class="hljs-number">1</span>): no suitable image found.  Did <span class="hljs-keyword">find</span>:<br><span class="hljs-regexp">/xxx/</span>target<span class="hljs-regexp">/classes/</span>lib/xxx.so: unknown <span class="hljs-keyword">file</span> type, first eight bytes: <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF<br><span class="hljs-regexp">/xxx/</span>target<span class="hljs-regexp">/classes/</span>lib/xxx.so: unknown <span class="hljs-keyword">file</span> type, first eight bytes: <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF <span class="hljs-number">0</span>xBD <span class="hljs-number">0</span>xEF <span class="hljs-number">0</span>xBF<br></code></pre></td></tr></table></figure><br>这需要注意，使用idea编译代码后，由于将二进制文件从resource拷贝到输出路径可能会导致文件格式被破坏。<br>因此需要在pom下提示：<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">nonFilteredFileExtensions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span>so<span class="hljs-tag">&lt;/<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span>dylib<span class="hljs-tag">&lt;/<span class="hljs-name">nonFilteredFileExtension</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">nonFilteredFileExtensions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><br>重新编译即可。</p>]]></content>
    
    
    <summary type="html">Java中使用JNI构建环境</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JNI 一</title>
    <link href="http://example.com/2023/07/25/JNI_1/"/>
    <id>http://example.com/2023/07/25/JNI_1/</id>
    <published>2023-07-25T12:00:01.000Z</published>
    <updated>2023-07-26T06:04:34.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JNI概述"><a href="#JNI概述" class="headerlink" title="JNI概述"></a>JNI概述</h2><p>JNI(Java Native Interface)意为JAVA本地调用，它允许Java代码和其他语言写的代码进行交互，简单的说，一种在Java虚拟机控制下执行代码的标准机制。<br>Android NDK（Native Development Kit ）是一套工具集合，允许你用像C/C++语言那样实现应用程序的一部分。</p><p>JNI和NDK的区别？</p><ul><li>从工具上说，NDK其实多了一个把.so和.apk打包的工具，而JNI开发并没有打包，只是把.so文件放到文件系统的特定位置。</li><li>从编译库说，NDK开发C/C++只能能使用NDK自带的有限的头文件，而使用JNI则可以使用文件系统中带的头文件。</li><li>从编写方式说，它们一样。</li></ul><h2 id="JNI-元素"><a href="#JNI-元素" class="headerlink" title="JNI 元素"></a>JNI 元素</h2><h2 id="JNI组织结构"><a href="#JNI组织结构" class="headerlink" title="JNI组织结构"></a>JNI组织结构</h2><p>JNI函数表的组成就像C++的虚函数表，虚拟机可以运行多张函数表。<br>JNI接口指针仅在当前线程中起作用，指针不能从一个线程进入另一个线程，但可以在不同的线程中调用本地方法。</p><p><img src="/img/JNI/0.png" alt="github"></p><h2 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h2><p>jobject 对象引用类型<br><img src="/img/JNI/1.png" alt="github"></p><div class="table-container"><table><thead><tr><th>Java类型</th><th>本地类型（JNI）</th><th>描述</th></tr></thead><tbody><tr><td>boolean（布尔型）</td><td>jboolean</td><td>无符号8个比特</td></tr><tr><td>byte(字节型)</td><td>jbyte</td><td>有符号8个比特</td></tr><tr><td>char(字符型)</td><td>jchar</td><td>无符号16个比特</td></tr><tr><td>short(短整型)</td><td>jshort</td><td>有符号16个比特</td></tr><tr><td>int(整型)</td><td>jint</td><td>有符号32个比特</td></tr><tr><td>long(长整型)</td><td>jlong</td><td>有符号64个比特</td></tr><tr><td>float(浮点型)</td><td>jfloat</td><td>32个比特</td></tr><tr><td>double(双精度浮点型)</td><td>jdouble</td><td>64个比特</td></tr><tr><td>void(空型)</td><td>void</td><td>N/A</td></tr></tbody></table></div><h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><div class="table-container"><table><thead><tr><th>函数</th><th>Java 数组类型</th><th>本地类型</th><th>说明        </th></tr></thead><tbody><tr><td>GetBooleanArrayElements</td><td>jbooleanArray</td><td>jboolean</td><td>ReleaseBooleanArrayElements 释放</td></tr><tr><td>GetByteArrayElements</td><td>jbyteArray</td><td>jbyte</td><td>ReleaseByteArrayElements 释放</td></tr><tr><td>GetCharArrayElements</td><td>jcharArray</td><td>jchar</td><td>ReleaseShortArrayElements 释放</td></tr><tr><td>GetShortArrayElements</td><td>jshortArray</td><td>jshort</td><td>ReleaseBooleanArrayElements 释放</td></tr><tr><td>GetIntArrayElements</td><td>jintArray</td><td>jint</td><td>ReleaseIntArrayElements 释放</td></tr><tr><td>GetLongArrayElements</td><td>jlongArray</td><td>jlong</td><td>ReleaseLongArrayElements 释放</td></tr><tr><td>GetFloatArrayElements</td><td>jfloatArray</td><td>jfloat</td><td>ReleaseFloatArrayElements 释放</td></tr><tr><td>GetDoubleArrayElements</td><td>jdoubleArray</td><td>jdouble</td><td>ReleaseDoubleArrayElements 释放</td></tr><tr><td>GetObjectArrayElement</td><td>自定义对象</td><td>object</td><td></td></tr><tr><td>SetObjectArrayElement</td><td>自定义对象</td><td>object</td><td></td></tr><tr><td>GetArrayLength</td><td></td><td></td><td>获取数组大小</td></tr><tr><td><code>New&lt;Type&gt;Array</code></td><td></td><td></td><td>创建一个指定长度的原始数据类型的数组</td></tr><tr><td>GetPrimitiveArrayCritical</td><td></td><td></td><td>得到指向原始数据类型内容的指针，该方法可能使垃圾回收不能执行，该方法可能返回数组的拷贝，因此必须释放此资源。</td></tr><tr><td>ReleasePrimitiveArrayCritical</td><td></td><td></td><td>释放指向原始数据类型内容的指针，该方法可能使垃圾回收不能执行，该方法可能返回数组的拷贝，因此必须释放此资源。</td></tr><tr><td>NewStringUTF</td><td></td><td></td><td>jstring类型的方法转换</td></tr><tr><td>GetStringUTFChars</td><td></td><td></td><td>jstring类型的方法转换</td></tr><tr><td>DefineClass</td><td></td><td></td><td>从原始类数据的缓冲区中加载类</td></tr><tr><td>FindClass</td><td></td><td></td><td>该函数用于加载本地定义的类。它将搜索由CLASSPATH 环境变量为具有指定名称的类所指定的目录和 zip文件</td></tr><tr><td>GetObjectClass</td><td></td><td></td><td>通过对象获取这个类。该函数比较简单，唯一注意的是对象不能为NULL，否则获取的class肯定返回也为NULL</td></tr><tr><td>GetSuperclass</td><td></td><td></td><td>获取父类或者说超类 。 如果 clazz 代表类class而非类 object，则该函数返回由 clazz 所指定的类的超类。 如果 clazz指定类 object 或代表某个接口，则该函数返回NULL</td></tr><tr><td>IsAssignableFrom</td><td></td><td></td><td>确定 clazz1 的对象是否可安全地强制转换为clazz2</td></tr><tr><td>Throw</td><td></td><td></td><td>抛出 java.lang.Throwable 对象</td></tr><tr><td>ThrowNew</td><td></td><td></td><td>利用指定类的消息（由 message 指定）构造异常对象并抛出该异常</td></tr><tr><td>ExceptionOccurred</td><td></td><td></td><td>确定是否某个异常正被抛出。在平台相关代码调用 ExceptionClear() 或 Java 代码处理该异常前，异常将始终保持抛出状态</td></tr><tr><td>ExceptionDescribe</td><td></td><td></td><td>将异常及堆栈的回溯输出到系统错误报告信道（例如 stderr）。该例程可便利调试操作</td></tr><tr><td>ExceptionClear</td><td></td><td></td><td>清除当前抛出的任何异常。如果当前无异常，则此例程不产生任何效果</td></tr><tr><td>FatalError</td><td></td><td></td><td>抛出致命错误并且不希望虚拟机进行修复。该函数无返回值</td></tr><tr><td>NewGlobalRef</td><td></td><td></td><td>创建 obj 参数所引用对象的新全局引用。obj 参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef() 来显式撤消。</td></tr><tr><td>DeleteGlobalRef</td><td></td><td></td><td>删除 globalRef 所指向的全局引用</td></tr><tr><td>DeleteLocalRef</td><td></td><td></td><td>删除 localRef所指向的局部引用</td></tr><tr><td>AllocObject</td><td></td><td></td><td>分配新 Java 对象而不调用该对象的任何构造函数。返回该对象的引用。clazz 参数务必不要引用数组类。</td></tr><tr><td>getObjectClass</td><td></td><td></td><td>返回对象的类</td></tr><tr><td>IsSameObject</td><td></td><td></td><td>测试两个引用是否引用同一 Java 对象</td></tr><tr><td>NewString</td><td></td><td></td><td>利用 Unicode 字符数组构造新的 java.lang.String 对象</td></tr><tr><td>GetStringLength</td><td></td><td></td><td>返回 Java 字符串的长度（Unicode 字符数）</td></tr><tr><td>GetStringChars</td><td></td><td></td><td>返回指向字符串的 Unicode 字符数组的指针。该指针在调用 ReleaseStringchars() 前一直有效</td></tr><tr><td>ReleaseStringChars</td><td></td><td></td><td>通知虚拟机平台相关代码无需再访问 chars。参数chars 是一个指针，可通过 GetStringChars() 从 string 获得</td></tr><tr><td>NewStringUTF</td><td></td><td></td><td>利用 UTF-8 字符数组构造新 java.lang.String 对象</td></tr><tr><td>GetStringUTFLength</td><td></td><td></td><td>以字节为单位返回字符串的 UTF-8 长度</td></tr><tr><td>GetStringUTFChars</td><td></td><td></td><td>返回指向字符串的 UTF-8 字符数组的指针。该数组在被ReleaseStringUTFChars() 释放前将一直有效</td></tr><tr><td>ReleaseStringUTFChars</td><td></td><td></td><td>通知虚拟机平台相关代码无需再访问 utf。utf 参数是一个指针，可利用 GetStringUTFChars() 获得</td></tr><tr><td>NewObjectArray</td><td></td><td></td><td>构造新的数组，它将保存类 elementClass 中的对象。所有元素初始值均设为 initialElement</td></tr><tr><td><code>Set&lt;PrimitiveType&gt;ArrayRegion</code></td><td></td><td></td><td>将基本类型数组的某一区域从缓冲区中复制回来的一组函数</td></tr><tr><td>GetFieldID</td><td></td><td></td><td>返回类的实例（非静态）域的属性 ID。该域由其名称及签名指定。访问器函数的<code>Get&lt;type&gt;Field</code> 及 <code>Set&lt;type&gt;Field</code>系列使用域 ID 检索对象域。GetFieldID() 不能用于获取数组的长度域。应使用GetArrayLength()。</td></tr><tr><td><code>Get&lt;type&gt;Field</code></td><td></td><td></td><td>该访问器例程系列返回对象的实例（非静态）域的值。要访问的域由通过调用GetFieldID() 而得到的域 ID 指定。 </td></tr><tr><td><code>Set&lt;type&gt;Field</code></td><td></td><td></td><td>该访问器例程系列设置对象的实例（非静态）属性的值。要访问的属性由通过调用SetFieldID() 而得到的属性 ID指定。</td></tr><tr><td><code>GetStaticFieldID</code>  <code>GetStatic&lt;type&gt;Field</code> <code>SetStatic&lt;type&gt;Field</code></td><td></td><td></td><td>同上，只不过是静态属性。</td></tr><tr><td>GetMethodID</td><td></td><td></td><td>返回类或接口实例（非静态）方法的方法 ID。方法可在某个 clazz 的超类中定义，也可从 clazz 继承。该方法由其名称和签名决定。 GetMethodID() 可使未初始化的类初始化。要获得构造函数的方法 ID，应将<init> 作为方法名，同时将void (V) 作为返回类型。</td></tr><tr><td>CallVoidMethod</td><td></td><td></td><td></td></tr><tr><td>CallObjectMethod</td><td></td><td></td><td></td></tr><tr><td>CallBooleanMethod</td><td></td><td></td><td></td></tr><tr><td>CallByteMethod</td><td></td><td></td><td></td></tr><tr><td>CallCharMethod</td><td></td><td></td><td></td></tr><tr><td>CallShortMethod</td><td></td><td></td><td></td></tr><tr><td>CallIntMethod</td><td></td><td></td><td></td></tr><tr><td>CallLongMethod</td><td></td><td></td><td></td></tr><tr><td>CallFloatMethod</td><td></td><td></td><td></td></tr><tr><td>CallDoubleMethod</td><td></td><td></td><td></td></tr><tr><td>GetStaticMethodID</td><td></td><td></td><td>调用静态方法</td></tr><tr><td><code>Call&lt;type&gt;Method</code></td><td></td><td></td><td></td></tr><tr><td>RegisterNatives</td><td></td><td></td><td>向 clazz 参数指定的类注册本地方法。methods 参数将指定 JNINativeMethod 结构的数组，其中包含本地方法的名称、签名和函数指针。nMethods 参数将指定数组中的本地方法数。</td></tr><tr><td>UnregisterNatives</td><td></td><td></td><td>取消注册类的本地方法。类将返回到链接或注册了本地方法函数前的状态。该函数不应在常规平台相关代码中使用。相反，它可以为某些程序提供一种重新加载和重新链接本地库的途径。    </td></tr></tbody></table></div><h2 id="域描述符"><a href="#域描述符" class="headerlink" title="域描述符"></a>域描述符</h2><div class="table-container"><table><thead><tr><th>域</th><th>Java 语言</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double</td></tr></tbody></table></div><ul><li>引用类型则为 L + 该类型类描述符。</li><li>数组，其为 :  [ + 其类型的域描述符。</li><li>多维数组则是 n个[ +该类型的域描述符, N代表的是几维数组。<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">String类型的域描述符为 Ljava<span class="hljs-regexp">/lang/</span>String;    <br>  <br>[ + 其类型的域描述符 + ;  <br><span class="hljs-keyword">int</span>[]     其描述符为[I  <br><span class="hljs-keyword">float</span>[]   其描述符为[F  <br>String[]  其描述符为[Ljava<span class="hljs-regexp">/lang/</span>String;  <br>Object[]类型的域描述符为[Ljava<span class="hljs-regexp">/lang/</span>Object;  <br><span class="hljs-keyword">int</span>  [][] 其描述符为[[I  <br><span class="hljs-keyword">float</span>[][] 其描述符为[[F  <br></code></pre></td></tr></table></figure></li></ul><p>将参数类型的域描述符按照申明顺序放入一对括号中后跟返回值类型的域描述符，规则如下： (参数的域描述符的叠加)返回类型描述符。对于没有返回值的，用V(表示void型)表示。<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">Java层方法                                               JNI函数签名  <br><span class="hljs-keyword">String</span> test ()                                          Ljava/lang/<span class="hljs-keyword">String</span>;  <br><span class="hljs-built_in">int</span> f (<span class="hljs-built_in">int</span> i, <span class="hljs-keyword">Object</span> object)                            (ILjava/lang/<span class="hljs-keyword">Object</span>;)I  <br><span class="hljs-keyword">void</span> <span class="hljs-built_in">set</span> (<span class="hljs-built_in">byte</span>[] bytes)                                ([B)V  <br></code></pre></td></tr></table></figure></p><h2 id="JNIEnv与JavaVM"><a href="#JNIEnv与JavaVM" class="headerlink" title="JNIEnv与JavaVM"></a>JNIEnv与JavaVM</h2><p>JNIEnv 概念 : 是一个线程相关的结构体, 该结构体代表了 Java 在本线程的运行环境 ; </p><p>JNIEnv 与 JavaVM : 注意区分这两个概念; </p><ul><li>JavaVM : JavaVM 是 Java虚拟机在 JNI 层的代表, JNI 全局只有一个;</li><li>JNIEnv : JavaVM 在线程中的代表, 每个线程都有一个, JNI 中可能有很多个 JNIEnv;</li></ul><p>JNIEnv 体系结构<br>线程相关 : JNIEnv 是线程相关的, 即 在 每个线程中 都有一个 JNIEnv 指针, 每个JNIEnv 都是线程专有的, 其它线程不能使用本线程中的 JNIEnv, 线程 A 不能调用 线程 B 的 JNIEnv。</p><p>JNIEnv 不能跨线程 : </p><ul><li>当前线程有效 : JNIEnv 只在当前线程有效, JNIEnv 不能在线程之间进行传递, 在同一个线程中, 多次调用 JNI层方法, 传入的 JNIEnv 是相同的;</li><li>本地方法匹配多JNIEnv : 在 Java 层定义的本地方法, 可以在不同的线程调用, 因此可以接受不同的 JNIEnv;</li></ul><p>JNIEnv 结构 :<br>由上面的代码可以得出, JNIEnv 是一个指针,  指向一个线程相关的结构, 线程相关结构指向 JNI 函数指针 数组, 这个数组中存放了大量的 JNI 函数指针, 这些指针指向了具体的 JNI 函数; </p><p>UTF-8编码<br>JNI使用改进的UTF-8字符串来表示不同的字符类型。Java使用UTF-16编码。UTF-8编码主要使用于C语言，因为它的编码用\u000表示为0xc0，而不是通常的0×00。非空ASCII字符改进后的字符串编码中可以用一个字节表示。</p><p>异常<br>JNI允许用户使用Java异常处理。大部分JNI方法会返回错误代码但本身并不会报出异常。因此，很有必要在代码本身进行处理，将异常抛给Java。在JNI内部，首先会检查调用函数返回的错误代码，之后会调用ExpectOccurred()返回一个错误对象。</p><h2 id="JNI函数实战"><a href="#JNI函数实战" class="headerlink" title="JNI函数实战"></a>JNI函数实战</h2><h2 id="so的入口函数"><a href="#so的入口函数" class="headerlink" title="so的入口函数"></a>so的入口函数</h2><p><code>JNI_OnLoad()</code>与<code>JNI_OnUnload()</code></p><p>当VM(Virtual Machine)执行到System.loadLibrary()函数时，首先会去执行C组件里的JNI_OnLoad()函数。</p><ul><li>告诉VM此C组件使用那一个JNI版本。如果你的*.so档没有提供JNI_OnLoad()函数，VM会默认该*.so档是使用最老的JNI 1.1版本。由于新版的JNI做了许多扩充，如果需要使用JNI的新版功能，例如JNI 1.4的java.nio.ByteBuffer,就必须藉由JNI_OnLoad()函数来告知VM。</li><li>由于VM执行到System.loadLibrary()函数时，就会立即先呼叫JNI_OnLoad()，所以C组件的开发者可以藉由JNI_OnLoad()来进行C组件内的初期值之设定(Initialization) 。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h4 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h4><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">native</span> <span class="hljs-built_in">String</span> <span class="hljs-built_in">print</span>();<br><br><br>jstring res = env-&gt;NewStringUTF(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><h4 id="返回数组"><a href="#返回数组" class="headerlink" title="返回数组"></a>返回数组</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native List&lt;String&gt; add<span class="hljs-constructor">List()</span>;<br><br>jobjectArray pArray = env-&gt;<span class="hljs-constructor">NewObjectArray(4, <span class="hljs-params">env</span>-&gt;FindClass(<span class="hljs-string">&quot;java/lang/String&quot;</span>)</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>    jstring s = env-&gt;<span class="hljs-constructor">NewStringUTF(<span class="hljs-string">&quot;A&quot;</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetObjectArrayElement(<span class="hljs-params">pArray</span>, <span class="hljs-params">i</span>, <span class="hljs-params">s</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回自定义对象"><a href="#返回自定义对象" class="headerlink" title="返回自定义对象"></a>返回自定义对象</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native TestInfo create<span class="hljs-constructor">Test(<span class="hljs-params">int</span> <span class="hljs-params">data1</span>, String <span class="hljs-params">data2</span>)</span>;<br><br><span class="hljs-comment">// 构建TestInfo对象</span><br>jclass pJclass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/xx/xxxx/test/entity/TestInfo&quot;</span>)</span>;<br>jmethodID method_init = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>jfieldID nameField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>)</span>;<br>jfieldID dataField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/Integer;&quot;</span>)</span>;<br>jobject obj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">pJclass</span>, <span class="hljs-params">method_init</span>)</span>;<br><br><span class="hljs-comment">// 构建Integer对象及其字段</span><br>jclass integerClass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;java/lang/Integer&quot;</span>)</span>;<br>jmethodID integerMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">integerClass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>)</span>;<br>jobject integerObj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">integerClass</span>, <span class="hljs-params">integerMethod</span>, <span class="hljs-params">d1</span>)</span>;<br>env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">dataField</span>, <span class="hljs-params">integerObj</span>)</span>;<br><br><span class="hljs-comment">// 构建String字段</span><br>env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">nameField</span>, <span class="hljs-params">env</span>-&gt;NewStringUTF(<span class="hljs-string">&quot;Data&quot;</span>)</span>);<br>return obj;<br></code></pre></td></tr></table></figure><h4 id="返回自定义对象的数组"><a href="#返回自定义对象的数组" class="headerlink" title="返回自定义对象的数组"></a>返回自定义对象的数组</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native List&lt;TestInfo&gt; add<span class="hljs-constructor">List(<span class="hljs-params">int</span> <span class="hljs-params">data1</span>, String <span class="hljs-params">data2</span>)</span>;<br><br>jclass arrClass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;Ljava/util/ArrayList;&quot;</span>)</span>;<br>jmethodID arrMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">arrClass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>jobject arrObj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">arrClass</span>, <span class="hljs-params">arrMethod</span>)</span>;<br><br>jmethodID addMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">arrClass</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Z&quot;</span>)</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    jobject item = create<span class="hljs-constructor">Item(<span class="hljs-params">env</span>, <span class="hljs-params">d1</span>, <span class="hljs-params">d2</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">CallBooleanMethod(<span class="hljs-params">arrObj</span>, <span class="hljs-params">addMethod</span>, <span class="hljs-params">item</span>)</span>;<br>&#125;<br><br>return arrObj;<br></code></pre></td></tr></table></figure><p>这里的<code>createItem</code>是对返回自定义对象功能的一个封装函数:<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">jobject create<span class="hljs-constructor">Item(JNIEnv <span class="hljs-operator">*</span><span class="hljs-params">env</span>, <span class="hljs-params">jint</span> <span class="hljs-params">d1</span>, <span class="hljs-params">jstring</span> <span class="hljs-params">d2</span>)</span> &#123;<br>    jclass pJclass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/hy/modules/test/entity/TestInfo&quot;</span>)</span>;<br>    jmethodID method_init = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>    jfieldID nameField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>)</span>;<br>    jfieldID dataField = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/Integer;&quot;</span>)</span>;<br><br>    jobject obj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">pJclass</span>, <span class="hljs-params">method_init</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">nameField</span>, <span class="hljs-params">env</span>-&gt;NewStringUTF(<span class="hljs-string">&quot;Data&quot;</span>)</span>);<br><br>    jclass integerClass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;java/lang/Integer&quot;</span>)</span>;<br>    jmethodID integerMethod = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">integerClass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>)</span>;<br>    jobject integerObj = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">integerClass</span>, <span class="hljs-params">integerMethod</span>, <span class="hljs-params">d1</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">dataField</span>, <span class="hljs-params">integerObj</span>)</span>;<br>    return obj;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="操作Java层的类"><a href="#操作Java层的类" class="headerlink" title="操作Java层的类"></a>操作Java层的类</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native void test<span class="hljs-constructor">ThisObjField(TestInfo <span class="hljs-params">info</span>)</span>;<br><br>jclass pJclass = env-&gt;<span class="hljs-constructor">GetObjectClass(<span class="hljs-params">obj</span>)</span>;<br>jfieldID fieldId = env-&gt;<span class="hljs-constructor">GetFieldID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>)</span>;<br><br><span class="hljs-comment">// 获得该属性的值</span><br>jstring data = (jstring)env-&gt;<span class="hljs-constructor">GetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">fieldId</span>)</span>;<br>const <span class="hljs-built_in">char</span> *datas = env-&gt;<span class="hljs-constructor">GetStringUTFChars(<span class="hljs-params">data</span>, NULL)</span>;<br><span class="hljs-comment">// 释放局部引</span><br>env-&gt;<span class="hljs-constructor">ReleaseStringUTFChars(<span class="hljs-params">data</span>, <span class="hljs-params">datas</span>)</span>;<br><br><span class="hljs-built_in">char</span><span class="hljs-operator"> * </span>new_data = <span class="hljs-string">&quot;aaabbb&quot;</span>;<br>jstring pJstring = env-&gt;<span class="hljs-constructor">NewStringUTF(<span class="hljs-params">new_data</span>)</span>;<br>env-&gt;<span class="hljs-constructor">SetObjectField(<span class="hljs-params">obj</span>, <span class="hljs-params">fieldId</span>, <span class="hljs-params">pJstring</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="回调Java层方法"><a href="#回调Java层方法" class="headerlink" title="回调Java层方法"></a>回调Java层方法</h4><p>这里分为两种</p><ol><li>在jni中找到类，创建对象，调用该对象函数</li><li>将接口为参数给jni函数，jni调用该接口中的函数，完成接口回调功能</li></ol><p>首先是第一个：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native void test<span class="hljs-constructor">CallBackToMethod()</span>;<br><br>jclass pJclass = env-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/hy/modules/jni/PrintNative&quot;</span>)</span>;<br>jmethodID pJmethodId = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>)</span>;<br>jobject pJobject = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">pJclass</span>, <span class="hljs-params">pJmethodId</span>)</span>;<br><br>jmethodID testMethodId = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">pJclass</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(I)I&quot;</span>)</span>;<br>jint i = env-&gt;<span class="hljs-constructor">CallIntMethod(<span class="hljs-params">pJobject</span>, <span class="hljs-params">testMethodId</span>, 2)</span>;<br>printf(<span class="hljs-string">&quot;%d&quot;</span>, i);<br></code></pre></td></tr></table></figure><br>这里只是简单调用了对象中的函数</p><p>下面就是接口回调函数<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public native void test<span class="hljs-constructor">CallBack(CallBack <span class="hljs-params">callBack</span>)</span>;<br><br>jclass callback_cls = env-&gt;<span class="hljs-constructor">GetObjectClass(<span class="hljs-params">callback</span>)</span>;<br>jmethodID callback_mth = env-&gt;<span class="hljs-constructor">GetMethodID(<span class="hljs-params">callback_cls</span>, <span class="hljs-string">&quot;callback&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>)</span>;<br>env-&gt;<span class="hljs-constructor">CallVoidMethod(<span class="hljs-params">callback</span>, <span class="hljs-params">callback_mth</span>, <span class="hljs-params">env</span>-&gt;NewStringUTF(<span class="hljs-string">&quot;aabbcc&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><br>可以看到她不需要找类，创建新的对象，直接找到需要调用的函数名称并调用即可。</p><blockquote><p>注意，上面是在主进程中使用，如果在jni中的线程中单独使用，则需要特殊处理</p></blockquote><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">JavaVM *g_VM;<br>env-&gt;<span class="hljs-constructor">GetJavaVM(&amp;<span class="hljs-params">g_VM</span>)</span>;<br><br>...<br><br>JNIEnv *env;<br><span class="hljs-comment">//获取当前native线程是否有没有被附加到jvm环境中</span><br><span class="hljs-built_in">int</span> getEnvStat = g_VM-&gt;<span class="hljs-constructor">GetEnv((<span class="hljs-params">void</span> <span class="hljs-operator">**</span>)</span> &amp;env,JNI_VERSION_1_6);<br><br><span class="hljs-keyword">if</span> (getEnvStat<span class="hljs-operator"> == </span>JNI_EDETACHED) &#123;<br>    <span class="hljs-comment">// 关联线程</span><br>    <span class="hljs-keyword">if</span> (g_VM-&gt;<span class="hljs-constructor">AttachCurrentThread(&amp;<span class="hljs-params">env</span>, NULL)</span> != <span class="hljs-number">0</span>) &#123;<br>        return;<br>    &#125;<br>    mNeedDetach = JNI_TRUE;<br>&#125;<br><span class="hljs-comment">//通过jcallback 获取到要回调的类</span><br>jclass javaClass = env-&gt;<span class="hljs-constructor">GetObjectClass(<span class="hljs-params">callback</span>)</span>;<br><br>g_VM-&gt;<span class="hljs-constructor">DetachCurrentThread()</span>;<br></code></pre></td></tr></table></figure><h4 id="jbytearray转c-byte数组"><a href="#jbytearray转c-byte数组" class="headerlink" title="jbytearray转c++byte数组"></a>jbytearray转c++byte数组</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">jbyte</span> * arrayBody = env-&gt;<span class="hljs-type">GetByteArrayElements</span>(<span class="hljs-class"><span class="hljs-keyword">data</span>,0);</span><br><span class="hljs-title">jsize</span> theArrayLengthJ = env-&gt;<span class="hljs-type">GetArrayLength</span>(<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br><span class="hljs-type">BYTE</span> * starter = (<span class="hljs-type">BYTE</span> *)arrayBody;<br></code></pre></td></tr></table></figure><h4 id="jbyteArray-转-c-中的BYTE"><a href="#jbyteArray-转-c-中的BYTE" class="headerlink" title="jbyteArray 转 c++中的BYTE[]"></a>jbyteArray 转 c++中的BYTE[]</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jbyte </span>* olddata = (<span class="hljs-keyword">jbyte*)env-&gt;GetByteArrayElements(strIn, </span><span class="hljs-number">0</span>);<br><span class="hljs-keyword">jsize </span> oldsize = env-&gt;GetArrayLength(strIn);<br><span class="hljs-keyword">BYTE* </span><span class="hljs-keyword">bytearr </span>= (<span class="hljs-keyword">BYTE*)olddata;</span><br><span class="hljs-keyword">int </span>len = (int)oldsize;<br></code></pre></td></tr></table></figure><h4 id="C-中的BYTE-转jbyteArray"><a href="#C-中的BYTE-转jbyteArray" class="headerlink" title="C++中的BYTE[]转jbyteArray"></a>C++中的BYTE[]转jbyteArray</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jbyte </span>*<span class="hljs-keyword">by </span>= (<span class="hljs-keyword">jbyte*)pData;</span><br><span class="hljs-keyword">jbyteArray </span><span class="hljs-keyword">jarray </span>= env-&gt;NewByteArray(nOutSize);<br>env-&gt;SetByteArrayRegin(<span class="hljs-keyword">jarray, </span><span class="hljs-number">0</span>, nOutSize, <span class="hljs-keyword">by);</span><br></code></pre></td></tr></table></figure><h4 id="jbyteArray-转-char"><a href="#jbyteArray-转-char" class="headerlink" title="jbyteArray 转 char *"></a>jbyteArray 转 char *</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">char</span>* <span class="hljs-class"><span class="hljs-keyword">data</span> = (<span class="hljs-title">char</span>*)env-&gt;<span class="hljs-type">GetByteArrayElements</span>(<span class="hljs-title">strIn</span>, 0);</span><br></code></pre></td></tr></table></figure><h4 id="char-转jstring"><a href="#char-转jstring" class="headerlink" title="char* 转jstring"></a>char* 转jstring</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jstring str</span> = env-&gt;GetStringUTFChars(char_data, NULL);<br></code></pre></td></tr></table></figure><h4 id="jstring-转char"><a href="#jstring-转char" class="headerlink" title="jstring 转char*"></a>jstring 转char*</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *char_data = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(jstring_data, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JNI 一</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型 关于 ? extends super</title>
    <link href="http://example.com/2023/07/19/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2023/07/19/%E6%B3%9B%E5%9E%8B/</id>
    <published>2023-07-19T20:14:22.000Z</published>
    <updated>2023-07-19T12:32:17.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>? extends T：声明上界，表示参数化的类型可能是所指定的 T 类型，或者是此类型的任意子类型。最终子类型：未知。</li><li>? super T：声明下界，表示参数化的类型可能是所指定的 T 类型，或者是此类型的任意父类型。最终父类型：已知——Object。</li><li>Java 中泛型不变：假设有 A extends B，但 List<A> 和 List<B> 不存在型变关系。</li></ul><h2 id="泛型的简单使用"><a href="#泛型的简单使用" class="headerlink" title="泛型的简单使用"></a>泛型的简单使用</h2><h2 id="泛型不变"><a href="#泛型不变" class="headerlink" title="泛型不变"></a>泛型不变</h2><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><span class="hljs-type">List</span>&lt;<span class="hljs-type">A</span>&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<span class="hljs-comment">// 泛型不变</span><br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>());<br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-type">B</span>());<br><span class="hljs-type">A</span> a = list1.get(<span class="hljs-number">1</span>);<br><span class="hljs-type">List</span>&lt;<span class="hljs-type">A</span>&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">B</span>&gt;();<span class="hljs-comment">// 编译错误，泛型不变，也就不支持协变（类似多态）</span><br></code></pre></td></tr></table></figure><h2 id="extends-泛型协变"><a href="#extends-泛型协变" class="headerlink" title="extends 泛型协变"></a>extends 泛型协变</h2><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; &#125;<br><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">B</span>&gt;();<span class="hljs-comment">// 协变——父类引用指向子类</span><br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>());  <span class="hljs-comment">// 错误，容器不可写，不能放入任何值（null 除外）</span><br><span class="hljs-type">A</span> a = list1.get(<span class="hljs-number">1</span>);<span class="hljs-comment">// work 可读，且有泛型</span><br></code></pre></td></tr></table></figure><p>集合可读、不可写，集合泛型协变。</p><h2 id="super-泛型逆变"><a href="#super-泛型逆变" class="headerlink" title="super 泛型逆变"></a>super 泛型逆变</h2><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">B</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<span class="hljs-comment">// 逆变——子类引用指向父类</span><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>());  <span class="hljs-comment">// 编译错误，集合中放入的元素类型只能为 B 及 B 子类型</span><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-type">B</span>());    <span class="hljs-comment">// work</span><br><span class="hljs-type">Object</span> b = list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// work 可读，但无类型都是 Object</span><br></code></pre></td></tr></table></figure><p>集合可读 Object 、可写，集合泛型逆变。</p><h2 id="结束说明"><a href="#结束说明" class="headerlink" title="结束说明"></a>结束说明</h2><ul><li>? extends T：针对返回值泛型使用（如，只读的消费者集合泛型），指定的 T 为集合元素的通用父类型，用于限定取出类型为 T 的子类型、打破泛型不变。</li><li>? super T：针对方法参数泛型使用（如，只写的生产者集合泛型），指定的 T 为集合元素的通用父类型，用于限定放入类型为 T 的子类型、打破泛型不变。</li></ul><p>可以看出，感觉到extends 与 super 功能互补。extends 用于方法返回值，super 用于方法参数。</p><h2 id="逆变协变优点"><a href="#逆变协变优点" class="headerlink" title="逆变协变优点"></a>逆变协变优点</h2><p>我们用 Java 对现实世界的水果进行简单的抽象，水果抽象为 Fruit，Apple等于 Fruit 存在继承关系。盛放水果的盘子 plate 被抽象为 List。</p><p>于是我们 OOP 代码抽象得到：<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watermelon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;<br><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; plate1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Apple</span>&gt;();      <span class="hljs-comment">// 编译错误</span><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; plate2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Banana</span>&gt;();     <span class="hljs-comment">// 编译错误</span><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; plate3 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Watermelon</span>&gt;(); <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><br>编译错误：</p><blockquote><p>Java 中类型存在协变关系<br>但是 Java 中类型上泛型不存在协变关系，即 List<Fruit> != ArrayList<Apple>，因此编译器提示泛型协变的编译错误。</p></blockquote><p>我们利用上面学到的 ? extends 、? super 打破泛型不变的特性，提供泛型协变，提高代码的复用性：<br><figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><br><span class="hljs-comment">// 协变，用作只读型容器————集合中元素都是 A 或 A 子类型</span><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; plate1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; plate2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">B</span>&gt;();<br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>&gt; plate3 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">C</span>&gt;();<br><span class="hljs-comment">// 逆变，用作只写型容器————集合中元素都是 B 或 B 父类型</span><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">B</span>&gt; plate4 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">A</span>&gt;();<br><br><span class="hljs-comment">// 上述结果</span><br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">Fruit</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Apple</span>&gt;();<br><span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">Apple</span>&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Fruit</span>&gt;();<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java锁</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://example.com/2023/07/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2023/07/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-07-11T19:22:35.000Z</published>
    <updated>2023-07-19T14:04:43.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/ThreadPool/3.png" alt="github"></p><h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul><li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。</li><li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。</li><li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序。</li><li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池。</li><li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池。</li><li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li><li>ThreadPoolExecutor：手动创建线程池的方式，它创建时最多可以设置 7 个参数。</li></ul><p>线程池的创建推荐使用最后一种 ThreadPoolExecutor 的方式来创建，因为使用它可以明确线程池的运行规则，规避资源耗尽的风险。 </p><h2 id="线程池七个参数含义"><a href="#线程池七个参数含义" class="headerlink" title="线程池七个参数含义"></a>线程池七个参数含义</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,<br>                          <span class="hljs-keyword">int</span> maximumPoolSize,<br>                          <span class="hljs-keyword">long</span> keepAliveTime,<br>                          TimeUnit unit,<br>                          BlockingQueue&lt;Runnable&gt; workQueue,<br>                          ThreadFactory threadFactory,<br>                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程数。</li><li>maximumPoolSize：最大线程数。</li><li>keepAliveTime：空闲线程存活时间。</li><li>TimeUnit：时间单位。</li><li>BlockingQueue：线程池任务队列。</li><li>ThreadFactory：创建线程的工厂。</li><li>RejectedExecutionHandler：拒绝策略。</li></ul><p>详细如下</p><h2 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h2><p>核心线程数：是指线程池中长期存活的线程数。</p><h2 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h2><p>最大线程数：线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。</p><p>最大线程数 maximumPoolSize 的值不能小于核心线程数 corePoolSize，否则在程序运行时会报 IllegalArgumentException 非法参数异常。</p><h2 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h2><p>空闲线程存活时间，当线程池中没有任务时，会销毁一些线程，销毁的线程数=maximumPoolSize（最大线程数）-corePoolSize（核心线程数）。</p><h2 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h2><p>时间单位：空闲线程存活时间的描述单位，此参数是配合参数 3 使用的。</p><ul><li>TimeUnit.DAYS：天</li><li>TimeUnit.HOURS：小时</li><li>TimeUnit.MINUTES：分</li><li>TimeUnit.SECONDS：秒</li><li>TimeUnit.MILLISECONDS：毫秒</li><li>TimeUnit.MICROSECONDS：微妙</li><li>TimeUnit.NANOSECONDS：纳秒</li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列：线程池存放任务的队列，用来存储线程池的所有待执行任务</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li></ul><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>线程工厂：线程池创建线程时调用的工厂方法，通过此方法可以设置线程的优先级、线程命名规则以及线程类型（用户线程还是守护线程）等。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建线程工厂</span><br>    ThreadFactory threadFactory = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">ThreadFactory</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-function"><span class="hljs-title">newThread</span>(<span class="hljs-params">Runnable r</span>)</span> &#123;<br>            <span class="hljs-comment">// 创建线程池中的线程</span><br>            Thread thread = <span class="hljs-keyword">new</span> Thread(r);<br>            <span class="hljs-comment">// 设置线程名称</span><br>            thread.setName(<span class="hljs-string">&quot;Thread-&quot;</span> + r.hashCode());<br>            <span class="hljs-comment">// 设置线程优先级（最大值：10）</span><br>            thread.setPriority(Thread.MAX_PRIORITY);<br>            <span class="hljs-comment">//......</span><br>            <span class="hljs-keyword">return</span> thread;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 创建线程池</span><br>    ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>,<br>                                                                   TimeUnit.SECONDS,<br>                                                             <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<br>                                                                   threadFactory); <span class="hljs-comment">// 使用自定义的线程工厂</span><br>    threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            Thread thread = Thread.currentThread();<br>            System.out.println(<span class="hljs-built_in">String</span>.format(<span class="hljs-string">&quot;线程：%s，线程优先级：%d&quot;</span>,<br>                                             thread.getName(), thread.getPriority()));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h2><p>拒绝策略：当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。</p><ul><li>AbortPolicy：拒绝并抛出异常。</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务。</li><li>DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。</li><li>DiscardPolicy：忽略并抛弃当前任务。</li></ul><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><h2 id="线程池的五种状态"><a href="#线程池的五种状态" class="headerlink" title="线程池的五种状态"></a>线程池的五种状态</h2><div class="table-container"><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>处于RUNNING状态下的线程池能够接收新的任务以及处理阻塞队列中的任务。</td></tr><tr><td>SHUTDOWN</td><td>处于SHUTDOWN状态下的线程池，不再接收新到来的任务，但是依然能够处理阻塞队列中的任务。</td></tr><tr><td>STOP</td><td>处于STOP状态下的线程池，不再接收新到来的任务，但是依然能够处理阻塞队列中的任务。</td></tr><tr><td>TIDYING</td><td>所有任务已经终止，有效线程数为0， 线程转换到TIDYING状态对运行terminated钩子方法</td></tr><tr><td>TERMINATED</td><td>terminated方法执行完成后进入terminated状态</td></tr></tbody></table></div><p><img src="/img/ThreadPool/0.png" alt="github"></p><h2 id="ThreadPoolExecutor中表示线程池状态设计"><a href="#ThreadPoolExecutor中表示线程池状态设计" class="headerlink" title="ThreadPoolExecutor中表示线程池状态设计"></a>ThreadPoolExecutor中表示线程池状态设计</h2><p><img src="/img/ThreadPool/2.png" alt="github"></p><p>在ThreadPoolExecutor中使用一个AtomicInteger类型的ctl字段来描述线程池地运行状态和线程数量，通过ctl的高3位来表示线程池的5种状态，低29位表示线程池中现有的线程数量。使用最少的变量来减少锁竞争，提高并发效率。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicInteger</span>(<span class="hljs-built_in">ctlOf</span>(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 线程池线程数地bit数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 线程池中最大线程容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = <span class="hljs-number">-1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 获取线程池地运行状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-comment">// 获取有效工作线程地数量</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-comment">// 组装线程数量和线程池状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure></p><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><ul><li>如果工作线程 小于 核心线程，那么就会创建线程执行提交的任务。</li><li>如果工作线程 大于 核心线程，并且阻塞队列未满，那么就会添加至阻塞队列，等待后续线程来执行提交地任务。</li><li>如果工作线程 大于 核心线程，并且工作线程 小于 最大线程数，并且阻塞队列已满，那么就会创建非核心线程执行提交的任务。</li><li>如果工作线程 大于等于 最大线程数，并且阻塞队列已满，那么就会执行拒绝策略。</li></ul><p><img src="/img/ThreadPool/1.png" alt="github"></p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public void execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command<span class="hljs-operator"> == </span>null)<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">NullPointerException()</span>;<br>    <span class="hljs-built_in">int</span> c = ctl.get<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 如果工作线程 小于 核心线程</span><br>    <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">c</span>)</span> &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (add<span class="hljs-constructor">Worker(<span class="hljs-params">command</span>, <span class="hljs-params">true</span>)</span>)<br>            return;<br>        c = ctl.get<span class="hljs-literal">()</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果工作线程 大于 核心线程</span><br>    <span class="hljs-comment">// 线程池处于运行状态，加入队列</span><br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Running(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;<br>        <span class="hljs-built_in">int</span> recheck = ctl.get<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// 两次获取ctl</span><br>        <span class="hljs-comment">// 在往阻塞队列中添加任务地时候，有可能阻塞队列已满，需要等待其他的任务移出队列，在这个过程中，线程池的状态可能会发生变化</span><br>        <span class="hljs-comment">// 如果在往阻塞队列中添加任务地时候，线程池地状态发生变化，则需要将任务remove</span><br>        <span class="hljs-keyword">if</span> (! is<span class="hljs-constructor">Running(<span class="hljs-params">recheck</span>)</span><span class="hljs-operator"> &amp;&amp; </span>remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">recheck</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>            add<span class="hljs-constructor">Worker(<span class="hljs-params">null</span>, <span class="hljs-params">false</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!add<span class="hljs-constructor">Worker(<span class="hljs-params">command</span>, <span class="hljs-params">false</span>)</span>)<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="addWorker-创建线程加入线程池"><a href="#addWorker-创建线程加入线程池" class="headerlink" title="addWorker 创建线程加入线程池"></a>addWorker 创建线程加入线程池</h2><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> addWorker(Runnable firstTask, <span class="hljs-built_in">boolean</span> core) &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">int</span> c = ctl.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-built_in">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// 线程池状态处于非RUNNING状态，添加worker失败</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 判断线程池中线程数量是否处于该线程池允许的最大线程数量，如果允许创建线程，则cas更新线程池中线程数量，并退出循环检查，执行下面创建线程地逻辑</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-built_in">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.<span class="hljs-built_in">get</span>();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-built_in">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建线程</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">int</span> rs = runStateOf(ctl.<span class="hljs-built_in">get</span>());<br>                <span class="hljs-comment">// 如果线程池处于RUNNING状态，并且线程已经启动则提前抛出线程异常启动异常</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">// 将线程加入已创建地线程集合，更新用于追踪线程池中线程数量largestPoolSize字段</span><br>                    workers.<span class="hljs-built_in">add</span>(w);<br>                    <span class="hljs-built_in">int</span> s = workers.<span class="hljs-built_in">size</span>();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 启动线程执行任务</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 启动线程会调用Worker中地runWorker()来执行任务</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>将一个任务Runnable提交给线程池执行时，主要分三步：</p><ul><li><ol><li>如果线程池中的线程数（workCount）&lt; 线程池大小（corePoolSize），则创建一个线程，执行这个任务，并把这个线程放入线程池。添加任务时会对线程池状态进行检查，以防止线程池状态为关闭时还添加线程。</li></ol></li><li><ol><li>如果线程池中的线程数（workCount）&gt;= 线程池大小（corePoolSize），或者上一步添加任务最后失败，将任务放入缓存队列中。当任务成功加入缓存队列，仍需要对线程池状态进行二次检查，防止线程池状态改为关闭或线程池中已经没有可以运行的线程。</li></ol></li><li><ol><li>如果上一步将任务放入缓存队列失败，试着去增加一个新的线程来执行它（超过线程池大小的额外线程）。如果添加新线程失败（可能是线程数已到达maximumPoolSize），则抛出异常拒绝执行该任务。</li></ol></li></ul><h2 id="runWorker执行任务"><a href="#runWorker执行任务" class="headerlink" title="runWorker执行任务"></a>runWorker执行任务</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">final void run<span class="hljs-constructor">Worker(Worker <span class="hljs-params">w</span>)</span> &#123;<br>    <span class="hljs-comment">// 获取执行任务线程</span><br>    Thread wt = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-comment">// 获取执行任务</span><br>    Runnable task = w.firstTask;<br>    <span class="hljs-comment">// 将worker中的任务置空</span><br>    w.firstTask = null;<br>    <span class="hljs-comment">// 这里不是解锁操作，这里是为了设置state = 0 以及 ExclusiveOwnerThread = null，因为起始状态state = -1, 不允许任何线程抢占锁，这里就是初始化操作。</span><br>    w.unlock<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 表示是否突然退出标志位，</span><br>    <span class="hljs-comment">// true-&gt;  发生异常了，当前线程突然退出，后面会做处理</span><br>    <span class="hljs-comment">// false-&gt; 正常退出</span><br>    boolean completedAbruptly = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 核心逻辑，这里 task 就是从队列里面取出一个runnable跑</span><br>        <span class="hljs-comment">// 条件1：</span><br>        <span class="hljs-comment">// task != null 指的就是firstTask是不是null，不是null执行循环体</span><br>        <span class="hljs-comment">// 条件2：</span><br>        <span class="hljs-comment">// getTask()方法就是当前线程从BlockingQueue中获取任务，此方法会阻塞</span><br>        <span class="hljs-comment">// getTask() == null 说明当前线程需要执行结束逻辑</span><br>        <span class="hljs-keyword">while</span> (task != null<span class="hljs-operator"> || </span>(task = get<span class="hljs-constructor">Task()</span>) != null) &#123;<br>            w.lock<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 1.线程池处于STOP/TIDYING/TERMINATION状态时需要设置线程的中断标志位</span><br>            <span class="hljs-comment">// 2.强制刷新标志位为false，通过Thread.interrupted()方法，因为有可能上一次执行task时，当前线程的中断标志位被设置为了true，且没有处理，这里就需要强制刷新一下，不会影响到后面的task。</span><br>            <span class="hljs-keyword">if</span> ((run<span class="hljs-constructor">StateAtLeast(<span class="hljs-params">ctl</span>.<span class="hljs-params">get</span>()</span>, STOP) <span class="hljs-pattern-match"><span class="hljs-operator">||</span></span><br><span class="hljs-pattern-match">                 (<span class="hljs-constructor">Thread</span>.interrupted() <span class="hljs-operator">&amp;&amp;</span></span><br><span class="hljs-pattern-match">                  run<span class="hljs-constructor">StateAtLeast(<span class="hljs-params">ctl</span>.<span class="hljs-params">get</span>()</span>, <span class="hljs-constructor">STOP</span>))) <span class="hljs-operator">&amp;&amp;</span></span><br><span class="hljs-pattern-match">                !wt.is<span class="hljs-constructor">Interrupted()</span>)</span><br><span class="hljs-pattern-match">                wt.interrupt();</span><br><span class="hljs-pattern-match">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="hljs-pattern-match">                <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 前置执行任务钩子函数</span><br><span class="hljs-pattern-match">                before<span class="hljs-constructor">Execute(<span class="hljs-params">wt</span>, <span class="hljs-params">task</span>)</span>;</span><br><span class="hljs-pattern-match">                <span class="hljs-constructor">Throwable</span> thrown = null;</span><br><span class="hljs-pattern-match">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="hljs-pattern-match">                    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 执行当前任务</span><br><span class="hljs-pattern-match">                    task.run();</span><br><span class="hljs-pattern-match">                &#125; catch (<span class="hljs-constructor">RuntimeException</span> x) &#123;</span><br><span class="hljs-pattern-match">                    thrown = x; throw x;</span><br><span class="hljs-pattern-match">                &#125; catch (<span class="hljs-constructor">Error</span> x) &#123;</span><br><span class="hljs-pattern-match">                    thrown = x; throw x;</span><br><span class="hljs-pattern-match">                &#125; catch (<span class="hljs-constructor">Throwable</span> x) &#123;</span><br><span class="hljs-pattern-match">                    thrown = x; throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-params">x</span>)</span>;</span><br><span class="hljs-pattern-match">                &#125; finally &#123;</span><br><span class="hljs-pattern-match">                    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 后置只sing任务钩子函数</span><br><span class="hljs-pattern-match">                    after<span class="hljs-constructor">Execute(<span class="hljs-params">task</span>, <span class="hljs-params">thrown</span>)</span>;</span><br><span class="hljs-pattern-match">                &#125;</span><br><span class="hljs-pattern-match">            &#125; finally &#123;</span><br><span class="hljs-pattern-match">                task = null;</span><br><span class="hljs-pattern-match">                w.completed<span class="hljs-constructor">Tasks</span><span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">                w.unlock();</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        completed<span class="hljs-constructor">Abruptly</span> = <span class="hljs-literal">false</span>;</span><br><span class="hljs-pattern-match">    &#125; finally &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 回收线程</span><br><span class="hljs-pattern-match">        process<span class="hljs-constructor">WorkerExit(<span class="hljs-params">w</span>, <span class="hljs-params">completedAbruptly</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>线程池有个内部类 Worker，它实现了 Runnable接口，它自己要 run 起来。 然后它会在合适的时候获取我们提交的 Runnable 任务，然后调用任务的 run()接口。 一个 Worker 不终止的话可以不断执行任务。<br>Worker 继承了AQS，用的是非公平锁，独占锁（不可重入）。</p><ul><li>Worker执行任务时获得锁，执行完毕释放锁。</li><li>Worker具有不可重入特性，目的是为了防止worker刚好在运行途中，线程池控制类操作（比如setCorePoolSize)时获得锁，这样的话，因为重入性，setCorePoolSize会执行中断操作，会把正在运行的任务中断掉。在空闲时可以响应中断，在执行任务时不可被中断</li></ul><blockquote><p>比如进行shutdown()优雅停机的时候，要进行w.tryLock方法，没有获取到锁，说明正在运行或者干其他事情，是不会被其他事情打断掉的。</p></blockquote><p>实现了runnable来达到具备线程功能。</p><p>“线程池中的线程”，其实就是 Worker；等待队列中的元素，是我们提交的 Runnable 任务。每一个 Worker 在创建出来的时候，会调用它本身的 run()方法，实现是 runWorker(this)，这个实现的核心是一个 while 循环，这个循环不结束， Worker 线程就不会终止，就是这个基本逻辑。</p><ul><li>在这个 while 条件中，有个 getTask()方法是核心中的核心，它所做的事情就是从等待队列中取出任务来执行</li></ul><h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">private Runnable getTask() &#123;<br>    <span class="hljs-regexp">//</span> 表示当前线程获取任务是否超时，默认是false，true表示已超时<br>    boolean timedOut = false;<br><br>    <span class="hljs-regexp">//</span> 自旋<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        int c = ctl.get();<br>        <span class="hljs-regexp">//</span> 获取线程池当前运行状态<br>        int rs = runStateOf(c);<br><br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">1</span>：rs &gt;= SHUTDOWN 条件成立：说明当前线程池是非RUNNING状态，可能是SHUTDOWN/STOP...<br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">2</span>：(rs &gt;= STOP || workQueue.isEmpty())<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span> rs &gt;= STOP 成立说明：当前的状态最低也是STOP状态，一定要返回null了<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2.2</span> 前置条件：状态是SHUTDOWN(因为 rs &gt;= SHUTDOWN 且 rs &gt;= STOP 不成立，所以当前状态只能为SHUTDOWN)<br>        <span class="hljs-regexp">//</span>     workQueue.isEmpty()条件成立：说明当前线程池状态为SHUTDOWN状态 且 任务队列已空，此时一定返回null<br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            <span class="hljs-regexp">//</span> 使用CAS + 自旋将ctl值-<span class="hljs-number">1</span><br>            decrementWorkerCount();<br>            <span class="hljs-regexp">//</span> runWorker方法就会将返回null的线程执行线程退出线程池的逻辑。<br>            return null;<br>        &#125;<br><br>        <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.线程池是Running状态<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.线程池是SHUTDOWN状态，但是队列中还有任务(此时可以创建线程)<br>        <br>        <span class="hljs-regexp">//</span> 获取线程池中的线程数量<br>        int wc = workerCountOf(c);<br><br>        <span class="hljs-regexp">//</span> timed == true<br>        <span class="hljs-regexp">//</span> 表示当前这个线程获取task时是支持超时机制的，使用queue.poll(xx, xx); 第一个参数是时间，第二个参数是时间单位。当获取task超时的情况下，下一次自旋就可能返回null了。<br>        <span class="hljs-regexp">//</span> timed == false<br>        <span class="hljs-regexp">//</span> 表示当前这个线程 获取 task 时 是不支持超时机制的，当前线程会使用 queue.take();<br>        <span class="hljs-regexp">//</span> 情况<span class="hljs-number">1</span>：allowCoreThreadTimeOut == true 表示核心线程数量内的线程 也可以被回收。所有线程 都是使用queue.poll(xx, xx) 超时机制这种方式获取task<br>        <span class="hljs-regexp">//</span> 情况<span class="hljs-number">2</span>：allowCoreThreadTimeOut == false 表示当前线程池会维护核心数量内的线程<br>        <span class="hljs-regexp">//</span> wc &gt; corePoolSize<br>        <span class="hljs-regexp">//</span> 条件成立：当前线程池中的线程数量是大于核心线程数的，此时让所有路过这里的线程(救急线程)，都使用poll(xx,xx)支持超时的方式去获取任务<br>        <span class="hljs-regexp">//</span> 这样，就会可能有一部分线程获取不到任务，获取不到任务 返回null，然后runWorker会执行线程退出逻辑。<br>        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">1</span>：(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">1.1</span>：wc &gt; maximumPoolSize 为什么会成立？setMaximumPoolSize()方法，可能外部线程将线程池最大线程数设置为比初始化时的要小<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">1.2</span>: (timed &amp;&amp; timedOut) 条件成立：前置条件，当前线程使用poll方式获取task。上一次循环时 使用poll方式获取任务时，超时了<br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">1</span> 为true表示 线程可以被回收，达到回收标准，当确实需要回收时再回收。<br>        <span class="hljs-regexp">//</span> <br>        <span class="hljs-regexp">//</span> 条件<span class="hljs-number">2</span>：(wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span>: wc &gt; <span class="hljs-number">1</span> 条件成立，说明当前线程池中还有其他线程，当前线程可以直接回收，返回null<br>        <span class="hljs-regexp">//</span> workQueue.isEmpty() 前置条件 wc == <span class="hljs-number">1</span>， 条件成立：说明当前任务队列 已经空了，最后一个线程，也可以放心的退出。<br>        <span class="hljs-regexp">//</span> 判断当前线程是否达到了回收的标准，<br>        <span class="hljs-regexp">//</span> 当获取任务超时并且核心线程可以被回收并且 当前线程池线程数量大于<span class="hljs-number">1</span>并且队列中没有任务了，当前线程就达到回收标准了，<br>        <span class="hljs-regexp">//</span> 当确实需要回收时才会被回收。<br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-regexp">//</span> 使用CAS机制 将ctl值-<span class="hljs-number">1</span>，减<span class="hljs-number">1</span>成功的线程，返回null<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                return null;<br>            <span class="hljs-regexp">//</span> 如果CAS失败，再次自旋，timed就有可能是false了，因为当前线程CAS失败，<br>            <span class="hljs-regexp">//</span> 很有可能是因为其他线程成功退出导致的，再次自旋时检查发现，当前线程就可能不属于回收范围了<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        try &#123;<br>            <span class="hljs-regexp">//</span> 根据timed的值，判断去队列中获取任务是使用带超时时间的还是不带超时时间的(注意：如果获取不到任务都会阻塞)<br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != null)<br>                return r;<br>            <span class="hljs-regexp">//</span> 说明当前线程超时了 继续进行自旋<br>            timedOut = true;<br>        &#125; catch (InterruptedException retry) &#123;<br>            timedOut = false;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果没有达到 corePoolSize，则创建的 Worker 在执行完它承接的任务后，会用workQueue.take()取任务，这个接口是阻塞接口，如果取不到任务， Worker线程一直阻塞。</li><li>如果超过了 corePoolSize，或者allowCoreThreadTimeOut，一个Worker 在空闲了之后，会用 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)取任务。注意，这个接口只阻塞等待 keepAliveTime 时间，超过这个时间返回 null，则Worker 的 while 循环执行结束，则被终止了。</li></ul><p>核心线程（Worker）即使一直空闲也不终止，是通过workQueue.take()实现的，它会一直阻塞到从等待队列中取到新的任务。 非核心线程空闲指定时间后终止是通过workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)实现的，一个空闲的 Worker 只等待 keepAliveTime，如果还没有取到任务则循环终止，线程也就运行结束了。</p><p>另外，这里针对<code>allowCoreThreadTimeOut</code>是否允许核心线程超时（被清理）有大量的使用。也可以通过设置这个字段来达到不被清理的效果。</p><h2 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit()"></a>processWorkerExit()</h2><p>runWorker() 的收尾方法。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// completedAbruptly</span><br><span class="hljs-comment">// true表示当前worker是因为任务出异常退出的</span><br><span class="hljs-comment">// false表示当前worker是因为没有获取到任务</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        <span class="hljs-comment">// 使用CAS + 自旋将ctl的值-1</span><br>        <span class="hljs-built_in">decrementWorkerCount</span>();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将当前worker完成的任务总数累加到全局总数上</span><br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">// 将当前worker从线程池(workers就是一个HashSet)移除</span><br>        workers.<span class="hljs-built_in">remove</span>(w);<br>    &#125; finally &#123;<br>        mainLock.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">tryTerminate</span>();<br><br>    <span class="hljs-keyword">int</span> c = ctl.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-comment">// 条件成立：当前线程池状态为RUNNING 或者 SHUTDOWN状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">runStateLessThan</span>(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>                    <span class="hljs-comment">// min表示线程池最低可以持有的线程数量</span><br>            <span class="hljs-comment">// allowCoreThreadTimeOut == true =&gt; 说明核心线程数内的线程，也会超时被回收 =&gt; min == 0</span><br>            <span class="hljs-comment">// allowCoreThreadTimeOut == false =&gt; min == corePoolSize</span><br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <br>            <span class="hljs-comment">// 线程池状态：RUNNING SHUTDOWN</span><br>            <span class="hljs-comment">// 条件1：假设mid == 0成立</span><br>            <span class="hljs-comment">// 条件2：队列不为空</span><br>            <span class="hljs-comment">// 说明队列中还有任务，起码得留一个线程</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.<span class="hljs-built_in">isEmpty</span>())<br>                min = <span class="hljs-number">1</span>;<br>                <br>            <span class="hljs-comment">// 条件成立： 线程池中还拥有足够的线程时，后续就不需要调用addWorker()了</span><br>            <span class="hljs-comment">// 考虑一个问题： workerCountOf(c) &gt;= min -&gt; (0 &gt;= 0) ？</span><br>            <span class="hljs-comment">// 当线程池中的核心线程数是可以被回收的情况下，会出现这种情况，这种情况下，</span><br>            <span class="hljs-comment">// 当前线程池中的线程数会变为0，下次在提交任务时，会再创建线程。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">workerCountOf</span>(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 来到这里的情况</span><br>        <span class="hljs-comment">// 1.completedAbruptly为true，表示当前线程在执行task时发生异常退出了，这里一定要创建一个新worker顶上去</span><br>        <span class="hljs-comment">// 2.当队列中还有任务时，起码留一个线程，这里就会创建一个线程(worker)</span><br>        <span class="hljs-comment">// 3.当前线程数 &lt; corePoolSize，此时会创建线程，维护线程池数量在corePoolSize个</span><br>        <span class="hljs-built_in">addWorker</span>(null, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后可以看到无论是否为核心线程，都会执行<code>remove</code>的操作，来销毁该线程。</p><h2 id="allowCoreThreadTimeOut-boolean-value"><a href="#allowCoreThreadTimeOut-boolean-value" class="headerlink" title="allowCoreThreadTimeOut(boolean value)"></a>allowCoreThreadTimeOut(boolean value)</h2><p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//允许核心线程池超时之后回收。</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">allowCoreThreadTimeOut</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Core threads must have nonzero keep alive times&quot;</span>);<br>    <span class="hljs-keyword">if</span> (value != allowCoreThreadTimeOut) &#123;<br>        allowCoreThreadTimeOut = value;<br>        <span class="hljs-comment">//能回收</span><br>        <span class="hljs-keyword">if</span> (value)<br>            interruptIdleWorkers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看到<code>allowCoreThreadTimeOut</code>字段在之前也出现过。</p><h2 id="线程池的阻塞队列"><a href="#线程池的阻塞队列" class="headerlink" title="线程池的阻塞队列"></a>线程池的阻塞队列</h2><h2 id="1-有界队列"><a href="#1-有界队列" class="headerlink" title="1.有界队列"></a>1.有界队列</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//基于数组的先进先出（FIFO）队列，支持公平锁和非公平锁，有界</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//基于链表的先进先出（FIFO）队列，默认长度为 Integer.MaxValue 有OOM危险，有界</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;&gt;();<br><br><span class="hljs-comment">//一个由链表结构组成的,双向阻塞队列，有界</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingDeque</span>();<br></code></pre></td></tr></table></figure><h2 id="2-无界队列"><a href="#2-无界队列" class="headerlink" title="2.无界队列"></a>2.无界队列</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//支持优先级排序的无限队列，默认自然排序，可以实现 compareTo()方法指定排序规则，不能保证同优先级元素的顺序，无界。</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">PriorityBlockingQueue</span>();<br><br><span class="hljs-comment">//一个使用优先级队列（PriorityQueue）实现的无界延时队列，在创建时可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">DelayQueue</span>();<br><br><span class="hljs-comment">//一个由链表结构组成的,无界阻塞队列</span><br>workQueue = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedTransferQueue</span>();<br></code></pre></td></tr></table></figure><h2 id="3-同步移交队列"><a href="#3-同步移交队列" class="headerlink" title="3.同步移交队列"></a>3.同步移交队列</h2><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">workQueue</span> = new SynchronousQueue&lt;&gt;()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>无缓冲的等待队列，队列不存元素，每个put操作必须等待take操作，否则无法添加元素，支持公平非公平锁，无界。workQueue 不要使用无界队列，尽量使用有界队列。 避免大量任务等待，造成 OOM。</p><h2 id="线程池四类拒绝策略"><a href="#线程池四类拒绝策略" class="headerlink" title="线程池四类拒绝策略"></a>线程池四类拒绝策略</h2><p>当线程池中的线程和阻塞队列中的任务已经处于饱和状态，线程池则需要执行给定的拒绝策略来拒绝正在提交的任务，ThreadPoolExecutor主要提供了一下四种拒绝策略来拒绝任务。</p><h2 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h2><p>抛出RejectedExecutionException异常拒绝任务提交<br><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">RejectedExecutionHandler</span></span> </span>&#123;<br>    <span class="hljs-keyword">public</span> void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h2><p>什么也不做，直接丢弃任务<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h2><p>将阻塞队列中的任务poll出来，然后执行当前任务<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h2><p>让提交任务的线程来执行任务<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="Excutors的四类线程"><a href="#Excutors的四类线程" class="headerlink" title="Excutors的四类线程"></a>Excutors的四类线程</h2><h2 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1.newCachedThreadPool"></a>1.newCachedThreadPool</h2><p>创建一个可缓存的无界线程池，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程，核心线程数为0。当线程池中的线程空闲时间超过60s，则会自动回收该线程，当任务超过线程池的线程数则创建新的线程，线程池的大小上限为Integer.MAX_VALUE,可看作无限大。</p><p>缺点：使用多少个最大线程，用户是无法控制的。</p><h2 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2.newFixedThreadPool"></a>2.newFixedThreadPool</h2><p>创建一个指定大小的线程池，可控制线程的最大并发数，超出的线程会在LinkedBlockingQueue阻塞队列中等待。</p><h2 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3.newScheduledThreadPool"></a>3.newScheduledThreadPool</h2><p>创建一个定长的线程池，可以指定线程池核心线程数，支持定时及周期性任务的执行。</p><p>方法：</p><ul><li>schedule(Runnable command, long delay, TimeUnit unit)，延迟一定时间后执行Runnable任务；</li><li>schedule(Callable callable, long delay, TimeUnit unit)，延迟一定时间后执行Callable任务；</li><li>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)，延迟一定时间后，以间隔period时间的频率周期性地执行任务；</li><li>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)，与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔。</li></ul><h2 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4.newSingleThreadExecutor"></a>4.newSingleThreadExecutor</h2><p>创建一个单线程化的线程池，它只有一个线程，用仅有的一个线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO，优先级）执行，所有的任务都保存在队列LinkedBlockingQueue中，等待唯一的单线程来执行任务。该方法无参数，所有任务都保存队列LinkedBlockingQueue中，核心线程数为1，线程空闲时间为0。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container"><table><thead><tr><th>工厂方法</th><th>corePoolSize</th><th>maximumPoolSize</th><th>keepAliveTime</th><th>workQueue </th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>60s</td><td>SynchronousQueue</td></tr><tr><td>newFixedThreadPool</td><td>nThreads</td><td>nThreads</td><td>0</td><td>LinkedBlockingQueue</td></tr><tr><td>newScheduledThreadPool</td><td>1</td><td>1</td><td>0</td><td>LinkedBlockingQueue</td></tr><tr><td>newSingleThreadExecutor</td><td>corePoolSize</td><td>Integer.MAX_VALUE</td><td>0</td><td>DelayedWorkQueue</td></tr></tbody></table></div><p>其他参数都相同，其中线程工厂的默认类为DefaultThreadFactory，线程饱和的默认策略为ThreadPoolExecutor.AbortPolicy。</p><h2 id="合理设置线程池参数"><a href="#合理设置线程池参数" class="headerlink" title="合理设置线程池参数"></a>合理设置线程池参数</h2><h2 id="CPU-密集型任务-N-1"><a href="#CPU-密集型任务-N-1" class="headerlink" title="CPU 密集型任务(N+1)"></a>CPU 密集型任务(N+1)</h2><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><h2 id="I-O-密集型任务-2N"><a href="#I-O-密集型任务-2N" class="headerlink" title="I/O 密集型任务(2N)"></a>I/O 密集型任务(2N)</h2><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。 </p><h2 id="如何判断是-CPU-密集任务还是-IO-密集任务？"><a href="#如何判断是-CPU-密集任务还是-IO-密集任务？" class="headerlink" title="如何判断是 CPU 密集任务还是 IO 密集任务？"></a>如何判断是 CPU 密集任务还是 IO 密集任务？</h2><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>]]></content>
    
    
    <summary type="html">线程池</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>GC学习</title>
    <link href="http://example.com/2023/07/01/gc/"/>
    <id>http://example.com/2023/07/01/gc/</id>
    <published>2023-07-01T23:02:35.000Z</published>
    <updated>2023-07-11T03:19:41.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GC 是垃圾回收器的简称，全称是Garbage Collection。<br><strong>Stop The World</strong> 在这里非常重要。当 Stop The World 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到 GC 任务完成。每一代的Java垃圾回收器，都把缩减 Stop The World 停顿时间作为很重要的目标。</p><p>JVM GC只回收<strong>堆区</strong>和<strong>方法区</strong>内的基本类型数据和对象。</p><h2 id="是否允许被回收"><a href="#是否允许被回收" class="headerlink" title="是否允许被回收"></a>是否允许被回收</h2><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>在对象里添加一个被引用的计数器，每当有地方引用了它，计数器就加1，引用失效时，计数器就减1。<br>在触发回收内存的时候，遍历所有对象，把计数器值等于0的找出来，释放掉即可。<br>但是它有个问题，无法回收互相引用的对象！</p><p>所以，市面上主流的Java虚拟机都没有使用这个算法，而是使用可达性分析法做为判断对象是否存活的算法。</p><h2 id="可达性分析法（根搜索算法）"><a href="#可达性分析法（根搜索算法）" class="headerlink" title="可达性分析法（根搜索算法）"></a>可达性分析法（根搜索算法）</h2><p>其实不止是Java，C# 也是使用可达性分析算法来判断对象是否存活的，这个算法也可以称之为根搜索算法。</p><p>基本原理是通过一系列可被作为 GC Roots 的根对象来作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程的就是一条引用链（Reference Chain），没有在这个链条上面的对象，也就是根节点通过引用链不可达到这个对象时，就认为这个对象是可以被回收的。</p><h4 id="哪些对象可以作为根节点呢？"><a href="#哪些对象可以作为根节点呢？" class="headerlink" title="哪些对象可以作为根节点呢？"></a>哪些对象可以作为根节点呢？</h4><blockquote><p>在虚拟机栈帧中引用的对象，例如线程调用方法时，使用或产生的参数、局部变量、临时变量等。<br>在方法区中，类的引用类型静态变量或常量。<br>在本地方法栈中的JNI引用的对象，<br>在JVM内部的对象，例如基本数据类型的Class对象，一些常驻的异常对象（NullPointExcepiton），系统类加载器等。<br>所有synchronized同步锁的持有对象。<br>反映JVM内部情况的JMXBean、JVMTI注册的回调、本地代码缓存等。<br>……</p></blockquote><h2 id="JVM-GC什么时候执行"><a href="#JVM-GC什么时候执行" class="headerlink" title="JVM GC什么时候执行"></a>JVM GC什么时候执行</h2><p>当程序创建一个新的对象或者基本类型的数据，内存空间不足时，会触发GC的执行。</p><h2 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h2><p>大多数的商业虚拟机，都采用分代回收的理论来设计垃圾收集器。既然绝大多数对象都熬不过几次垃圾回收，而熬过多次回收的对象又很难消亡，那么可以根据年龄把它们划分到不同的区域，例如新生代区域和老年代区域，然后分而治之。</p><p>各区域触发垃圾回收的类型与解释：</p><ul><li>Minor GC：只回收新生代区域。</li><li>Major GC：只回收老年代区域。只有CMS实现了Major GC，所以在老年代里，触发GC，除了CMS和G1之外的其他收集器，大多数触发的其实是 Full GC</li><li>Full GC：回收整个堆区和方法区</li><li>Mixed GC：回收整个新生代和部分老年代。G1收集器实现了这个类型。</li></ul><h2 id="新生代（Young-generation）"><a href="#新生代（Young-generation）" class="headerlink" title="新生代（Young generation）"></a>新生代（Young generation）</h2><p>绝大多数新创建的对象都会被分配到这里，这个区域触发的垃圾回收称之为：Minor GC 。</p><p>默认情况下，新生代（Young generation）、老年代（Old generation）所占空间比例为 1 : 2 。</p><p>默认情况下，新生代空间的分配：Eden : Fron : To = 8 : 1 : 1</p><h2 id="新生代GC收集的执行顺序如下"><a href="#新生代GC收集的执行顺序如下" class="headerlink" title="新生代GC收集的执行顺序如下"></a>新生代GC收集的执行顺序如下</h2><ul><li><ol><li>绝大多数新创建的对象会存放在Eden空间。</li></ol></li><li><ol><li>在Eden空间执行第 1 次GC（Minor GC）之后，存活的对象被移动到其中一个幸存者空间（Survivor）。</li></ol></li><li><ol><li>此后每次 Minor GC，都会将 Eden 和 使用中的Survivor 区域中存活的对象，一次性复制到另一块空闲中的Survivor区，然后直接清理 Eden 和 使用过的那块Survivor 空间。</li></ol></li><li><ol><li>从以上空间分配我们知道，Survivor区内存占比很小，当空闲中的Survivor空间不够存放活下来的对象时，这些对象会通过分配担保机制直接进入老年代。</li></ol></li><li><ol><li>在以上步骤中重复N次（N = MaxTenuringThreshold（年龄阀值设定，默认15））依然存活的对象，就会被移动到老年代。</li></ol></li></ul><p>新创建的对象，是保存在Eden空间的。那些经历多次GC依然存活的对象会经由Survivor空间转存到老年代空间（Old generation）。</p><h2 id="老年代（Old-generation）"><a href="#老年代（Old-generation）" class="headerlink" title="老年代（Old generation）"></a>老年代（Old generation）</h2><p>对象在新生代周期中存活了下来的，会被拷贝到这里。通常情况下这个区域分配的空间要比新生代多。正是由于对象经历的GC次数越多越难回收，加上相对大的空间，发生在老年代的GC次数要比新生代少得多。这个区域触发的垃圾回收称之为：Major GC 或者 Full GC</p><p>为什么老年代的回收耗时，比新生代更长</p><ul><li><ol><li>老年代内存占比更大，所以理论上回收的时间也更长</li></ol></li><li><ol><li>老年代使用的是标记-整理算法，清理完成内存后，还得把存活的对象重新排序整理成连续的空间，成本更高</li></ol></li></ul><h2 id="方法区（Method-area）"><a href="#方法区（Method-area）" class="headerlink" title="方法区（Method area）"></a>方法区（Method area）</h2><p>这个区域主要回收废弃的常量和类型，例如常量池里不会再被使用的各种符号引用等等。类型信息的回收相对来说就比较严苛了，必须符合以下3个条件才会被回收：</p><ul><li><ol><li>所有实例被回收</li></ol></li><li><ol><li>加载该类的ClassLoader 被回收</li></ol></li><li><ol><li>Class 对象无法通过任何途径访问（包括反射）</li></ol></li></ul><h2 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h2><p>新生代中的对象很有可能会被老年代里的对象所引用，当新生代触发GC的时候，只搜索新生代的区域明显是不够的，还得搜索老年代的对象是否引用了新生代中非 GC Roots 引用链上的对象，来确保正确性。但这样做会带来很大的性能开销。为了解决这个问题，Java定义了一种名为记忆集的抽象的数据结构，用于记录存在跨区域引用的对象指针集合。</p><p>大多数的虚拟机，都采用一种名为卡表（Card Table）的方式去实现记忆集，卡表由一个数组构成，每一个元素都对应着一块特定大小的内存区域，这块内存区域被称之为卡页（Card Page），每一个卡页，可能会包含N个存在跨区域引用的对象，只要存在跨区域引用的对象，这个卡页就会被标识为1。当GC发生的时候，就不需要扫描整个区域了，只需要把这些被标识为1的卡页加入对应区域的 GC Roots 里一起扫描即可。</p><h2 id="总结整个过程"><a href="#总结整个过程" class="headerlink" title="总结整个过程"></a>总结整个过程</h2><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="/img/Gc/0.png" alt="github"><br>图中大致将各个代说明了一下各个代的关系。</p><p><img src="/img/Gc/1.png" alt="github"><br>上图中则是大致说明了对象后的生命周期</p><ul><li>首先是创建并在新生代eden中</li><li>此时如果发生gc则会判断其大小，如果过大则直接进入老年代，否则就进入s1中</li><li>gc时s1和s2会发生循环往复的复制，其一是用来计算代数，其二是因为这里会经常发生数据调整产生数据碎片导致存储率降低，因此复制调整也是为了减少碎片提高使用率</li><li>而当s1和s2每次换代的时候，就会计算如果超过了阀值则进入老年代</li></ul><h2 id="回收算法讲解"><a href="#回收算法讲解" class="headerlink" title="回收算法讲解"></a>回收算法讲解</h2><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><p>这个算法和它的名字一样，分两个步骤：标记 和 清除。首先标记出所有存活的对象，再扫描整个空间中未被标记的对象直接回收。</p><p>并没有规定标记阶段一定要标记“存活”的对象，也可以标记“可回收”的对象。但是是标记存活的。这样效率高些。<br>首先，Java使用的是可达性分析算法来判断对象是否存活。</p><p>我们假设要标记“可回收”的对象，再进行清除，那么需要三个步骤：</p><ul><li>1、先通过可达性分析法，通过根对象（GC Roots）顺着引用链先把这些存活对象都标出来</li><li>2、遍历这个区域所有对象，把没标记存活的对象，打上一个“可回收”的标记</li><li>3、遍历这个区域所有对象，把标记了“可回收”的对象，释放掉。</li></ul><p>但标记的是“存活”的对象，再进行清除，只需要两个步骤即可：</p><ul><li>1、先通过可达性分析法，通过根对象（GC Roots）顺着引用链先把这些存活对象都标出来</li><li>2、遍历这个区域所有对象，把没标记存活的对象，直接清理掉即可。</li></ul><p>所以，标记“可回收”的对象，会多了一次完全没有必要的遍历。</p><p><img src="/img/Gc/2.png" alt="github"></p><p>可以看到在标记后，就会将未标记的清除掉，但是有一个问题，由于回收后没有进行整理的操作，所以会存在内存空间碎片化的问题。<br>但是反过来想，正是因为没有标记，效率才会高。</p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记 - 复制算法"></a>标记 - 复制算法</h2><p>一个80%的Eden空间和两个10%的Survivor空间。<br>每次分配内存，只使用Eden和其中一块Survivor空间，发生GC回收时，把Eden和其中一块Survivor空间中存活的对象，复制到另一块空闲的Survivor空间，然后直接把Eden和使用过的那块Survivor空间清理掉。</p><p>这个在上面的分代回收机制中已说明。</p><p>目前主流的使用分代回收机制的Java虚拟机，都是使用标记-复制算法来作为新生代的回收算法。它非常适合用在新生代这种回收率极高的场景，这样的场景下，复制算法浪费的空间几乎可以忽略不计。效率高，且内存不会有碎片化的问题。但对于老年代这种存活率很高的场景，就不适合了。</p><p>标记-复制算法还有一个非常重要的知识点，就是分配担保机制。虽然GC新生代里98%的对象都会被回收，但这不是百分之百的几率，极端情况下可能会出现超过10%的对象存活。分配担保机制就是为了保证当出现这种情况时，有其他内存空间来进行兜底。通常这个“担保人”是老年代，当存活的对象超过Survivor空间大小时，这些存活的对象会忽略年龄，直接进入老年代里。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h2><p>标记-清除算法会产生内存碎片，不适合哪些需要大量连续内存空间的场景，而标记-整理算法，就是在其基础之上，增加了整理这个操作，去解决这些内存空间碎片化的问题，</p><p><img src="/img/Gc/3.png" alt="github"></p><p>和标记-清除算法一样，先标记，但清除之前，会先进行整理，把所有存活的对象往内存空间的左边移动，然后清理掉存活对象边界以外的内存，即完成了清除的操作。标记-整理 算法是在 标记-清除 算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><p>老年代里的对象存活率很高，不适合使用标记-复制的算法。而且老年代存储大对象的概率要比新生代大很多，这些大对象需要连续的内存空间来存储，标记-清除这个算法也不适合。所以大多数的老年代都采用标记-整理来作为这个区域的回收算法。</p><h2 id="常用的垃圾回收器"><a href="#常用的垃圾回收器" class="headerlink" title="常用的垃圾回收器"></a>常用的垃圾回收器</h2><p>目前应用范围最广的，应该还是JDK8，它默认使用的是 Parallel Scavenge + Parallelo Old 收集器组合。</p><h2 id="Serial（-XX-UseSerialGC）"><a href="#Serial（-XX-UseSerialGC）" class="headerlink" title="Serial（-XX:+UseSerialGC）"></a>Serial（-XX:+UseSerialGC）</h2><p>Serial 是Java虚拟机初代收集器，在JDK1.3之前是Java虚拟机新生代收集器的唯一选择，这是一个单线程工作的收集器。在进行垃圾回收的时候，需要暂停所有的用户线程，直到回收结束。</p><p>虽然历史久远，但它依然是HotSpot虚拟机运行在客户端模式下，或者4核4GB以下服务端的默认新生代收集器，这种核心数和内存空间较小的场景下，它单线程的优势就体现出来了，没有线程交互的开销，加上内存空间不大，单次回收耗时几十毫秒，这点停顿时间，完全是可以接受的。</p><p>Serial 负责收集新生代区域，它采用标记-复制算法。</p><p><img src="/img/Gc/4.png" alt="github"></p><h2 id="Serial-Old（-XX-UseSerialOldGC）"><a href="#Serial-Old（-XX-UseSerialOldGC）" class="headerlink" title="Serial Old（-XX:+UseSerialOldGC）"></a>Serial Old（-XX:+UseSerialOldGC）</h2><p>SerialOld 是 Serial 收集器的老年代版本，和 Serial 一样，它也是单线程的收集器。目前主要应用在客户端模式（Client VM）下的HotSpot虚拟机使用。</p><p>如果在服务端模式（Server VM）下，它也有两种用途：一个是在JDK5以及之前，和Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器在出现并发模式故障（Concurrent Mode Failure） 时作为后备收集器。</p><p>SerialOld 负责收集老年代区域，它采用标记-整理算法。</p><p><img src="/img/Gc/5.png" alt="github"></p><h2 id="ParNew（-XX-UseParNewGC）"><a href="#ParNew（-XX-UseParNewGC）" class="headerlink" title="ParNew（-XX:+UseParNewGC）"></a>ParNew（-XX:+UseParNewGC）</h2><p>Serial 收集器单线程的性能明显比较落后了，ParNew 就是 在Serial 收集器的基础之上，实现了它的多线程版本。它可以多条线程同时进行垃圾收集，这也是它和 Serial 收集器的最大的区别，其他的功能性、配置、策略等等的和 Serial 基本一致。</p><p>在JDK9之后，Java官方取消了ParNew和除了CMS收集器之外的所有老年代收集器的搭配，而且还取消了 - XX:+UseParNewGC 这个参数。所以JDK9之后，ParNew只能和CMS搭配使用了。</p><p>ParNew 负责收集新生代区域，它采用标记-复制算法。<br><img src="/img/Gc/6.png" alt="github"></p><h2 id="Parallel-Scavenge（-XX-UseParallelGC）"><a href="#Parallel-Scavenge（-XX-UseParallelGC）" class="headerlink" title="Parallel Scavenge（-XX:+UseParallelGC）"></a>Parallel Scavenge（-XX:+UseParallelGC）</h2><p>Parallel Scavenge 从外观上看，和 ParNew 很相似，都是新生代的收集器，支持多线程并行回收，也同样是使用标记-复制来作为回收算法。但 Parallel Scavenge 的关注点不一样，它的目标是实现一个可控制吞吐量的垃圾收集器。</p><p>吞吐量的计算公式：运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)</p><p>Parallel Scavenge 收集器提供了一些参数，给用户按自身需求控制吞吐量：</p><blockquote><p>-XX:MaxGCPauseMillis<br>控制垃圾收集停顿的最大时间，单位是毫秒，可以设置一个大于0的数值。<br>不要想着把这个数值设置得很小来提升垃圾收集的速度，这里缩短的停顿时间是以牺牲新生代空间大小换来的，空间小，回收自然就快，停顿时间自然也短，但是空间小，吞吐量自然也会小。所以得综合考虑。</p><p>-XX:GCTimeRatio<br>设置垃圾收集时间占比的计算因子，参数范围是0 - 100的整数。它的公式是 1 / (1+GCTimeRatio)<br>举个栗子：当设置成15，那就是 1 / (1+15) = 0.0625，就是允许最大垃圾收集时间占总时间的6.25%，当设置成99的时候，就是 1 / (1+99) = 0.01，也就是允许最大垃圾收集时间占总时间的1%，依次类推。</p><p>-XX:+UseAdaptiveSizePolicy<br>动态调整开关，这个参数和 Parallel Scavenge 收集器无关，但是搭配起来使用是一个很好的选择。<br>当这个参数被激活，就不需要人工指定新生代的大小、Eden和Survivor区的比例、对象直接进入老年代的大小等等细节参数了，JVM会根据当前运行的情况动态调整，给出最合适的停顿时间和吞吐量。搭配以上两个参数，和把基本的内存数据设置好即可，例如堆的最大占用空间等等。</p></blockquote><h2 id="Parallel-Old（-XX-UseParallelOldGC）"><a href="#Parallel-Old（-XX-UseParallelOldGC）" class="headerlink" title="Parallel Old（-XX:+UseParallelOldGC）"></a>Parallel Old（-XX:+UseParallelOldGC）</h2><p>就像 Serial Old 是 Serial 的老年代版本一样，Parallel Old 是 Parallel Scavenge 的老年代版本。</p><p>Parallel Old 也支持多线程并行回收的能力，使用标记-整理来作为回收算法。这个收集器是JDK6的时候推出的，和 Parallel Scavenge 搭配，在多CPU核心和大内存的场景下，吞吐性能优秀。</p><p><img src="/img/Gc/7.png" alt="github"><br>在注重吞吐量和多CPU核心的情况下，都可以优先考虑 Parallel Scavenge + Parallelo Old 收集器，这也是JDK8默认的垃圾收集器组合。</p><h2 id="CMS-（-XX-UseConcMarkSweepGC）"><a href="#CMS-（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS （-XX:+UseConcMarkSweepGC）"></a>CMS （-XX:+UseConcMarkSweepGC）</h2><p>CMS（Concurrent Mark Sweep） 是JDK1.4后期推出的GC收集器，它是一款并发低停顿的收集器，对于响应速度有较高要求，对停顿时间忍受度低的应用，非常适合使用CMS作为垃圾收集器。</p><h4 id="CMS-负责收集老年代区域，它采用标记-清除算法。"><a href="#CMS-负责收集老年代区域，它采用标记-清除算法。" class="headerlink" title="CMS 负责收集老年代区域，它采用标记-清除算法。"></a>CMS 负责收集老年代区域，它采用标记-清除算法。</h4><p>它的运行过程相对于前几个来说会复杂一些，可以分为四个步骤：</p><ul><li>1、初始标记（CMS initial mark）<ul><li>这个阶段需要 Stop Tow World（暂停暂停所有用户线程），但这个阶段的速度很快，因为只标记和根节点（GC Roots）直接关联的对象。</li></ul></li><li>2、并发标记（CMS Concurrent mark）<ul><li>这个阶段不需要 Stop Tow World，在初始标记完成后，并发标记从GC Roots直接关联的对象开始，遍历整个引用链，这个阶段耗时较长，但用户线程可以和GC线程一起并发执行。</li></ul></li><li>3、重新标记（CMS remark）<ul><li>这个阶段需要 Stop Tow World，因为并发标记阶段，用户线程和标间线程同时在运行，相当于一边扫地一边丢垃圾，重新标记就是修正用户线程继续运行，导致的变动的那一部分对象。这一阶段的耗时比初始标记长一些，但远没有达到并发标记阶段那么长的时间。这个阶段可以多线程并行标记。</li></ul></li><li>4、并发清理（Concurrent sweep） <ul><li>这个阶段不需要 Stop Tow World，执行到这里，说明标记阶段已经完成，此时遍历整个老年代的内存空间，清理掉可回收的对象，由于不需要移动整理存活的对象，这个阶段可以允许用户线程和回收线程并发执行。在清理完成后，会重置CMS收集器的数据结构，等待下一次垃圾回收。</li></ul></li></ul><p><img src="/img/Gc/8.png" alt="github"><br>以上4个步骤可以看出，CMS之所以能实现低延迟，是因为它把垃圾搜集分成了几个明确的步骤，在一些耗时较长的阶段实现了用户线程和GC线程并发执行的能力。用两次短暂的 Stop Tow World 来代替了其他收集器一整段长时间的 Stop Tow World。</p><h4 id="CMS确实是非常优秀的垃圾收集器，但它也是有缺点的"><a href="#CMS确实是非常优秀的垃圾收集器，但它也是有缺点的" class="headerlink" title="CMS确实是非常优秀的垃圾收集器，但它也是有缺点的"></a>CMS确实是非常优秀的垃圾收集器，但它也是有缺点的</h4><ul><li>1、内存碎片。由于使用了 标记-清理 算法，回收结束后会产生大量不连续的内存空间，也就是内存碎片。</li><li>2、GC进行时会降低吞吐量。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，GC线程肯定会占用一部分计算资源，这个期间会降低一部分吞吐量（尽管这样，也比之前几个收集器好很多）。</li><li>3、浮动垃圾。CMS有两个阶段是可以用户线程和GC线程并发执行的，用户线程的继续执行自然会伴随垃圾的不断产生，这些就是浮动垃圾。这些垃圾只能等下次触发GC的时候才能清除了，也因为这些浮动垃圾的存在，CMS收集器需要留一手，JDK5的时候，在老年代内存空间使用了68%的时候就会触发一次GC，到了JDK6，觉得JDK5的这个设置太保守了，所以调整到了92%。</li></ul><blockquote><p>可以通过-XX:CMSInitiatingOccupancyFraction 调整这个阈值</p></blockquote><h2 id="Garbage-First（G1）"><a href="#Garbage-First（G1）" class="headerlink" title="Garbage First（G1）"></a>Garbage First（G1）</h2><p>G1 是 Garbage First 收集器的简称，它在JDK7的时候立项，JDK8 Update 40的时候才全部完工。这个收集器在JDK9 的时候成为了服务端模式下的默认垃圾收集器。</p><p>G1 收集器的设计理念是：实现一个停顿时间可控的低延迟垃圾收集器</p><p>G1 依然遵循分代回收的设计理论，但它对堆（Java Heap）内存进行了重新布局，不再是简单的按照新生代、老年代分成两个固定大小的区域了，而是把堆区划分成很多个大小相同的区域（Region），新、老年代也不再固定在某个区域了，每一个Region都可以根据运行情况的需要，扮演Eden、Survivor、老年代区域、或者Humongous区域。</p><p>大对象会被存储到Humongous区域，G1大多数情况下会把这个区域当作老年代来看待。如果对象占用空间超过Region的容量，就会存放到N个连续的 Humongous Region 中。</p><p><img src="/img/Gc/9.png" alt="github"></p><p>收集器的运行过程可以大致分成四个步骤：</p><ul><li>初始标记（Initial Marking）- Stop Tow World<ul><li>只标记 GC Roots 能直接关联的对象，还有一些额外的细节操作例如修改TAMS指针的值，保证后续阶段用户程序并发运行的时候，新对象分配在正确的位置。这个阶段需要暂停用户线程，但耗时很短。</li></ul></li><li>并发标记（Concurrent Marking）- No Stop Tow World<ul><li>从根节点（GC Root）开始，顺着引用链遍历整个堆，找出存活的对象。这个步骤耗时较长，但用户线程可以和GC线程并发执行。</li></ul></li><li>最终标记（Final Marking）- Stop Tow World<ul><li>处理并发标记阶段，用户线程继续运行产生的引用变动，这个阶段需要暂停用户线程，支持并行处理。</li></ul></li><li>筛选回收（Live Data Counting and Evacuation）- Stop Tow World<ul><li>根据以上三个阶段标记完成的数据，计算出各个Region的回收价值和成本，再根据用户期望的停顿时间来决定要回收多少个Region。回收使用的是复制算法，把需要回收的这些Region里存活的对象，复制到空闲的Region中，然后清理掉旧Region全部空间。因为需要移动存活的对象，所以不可避免的要暂停用户线程，这个步骤支持多条线程并行回收。</li></ul></li></ul><p><img src="/img/Gc/10.png" alt="github"></p><p>设置停顿时间</p><blockquote><p>-XX:MaxGCPauseMillis 默认值是 200 毫秒<br>首先G1把内存区域分成了若干个相同大小的 Region 区，在执行回收的时候，根据标记阶段统计到的数据，计算出各个 Region 区的回收价值和成本，有了这些数据之后，就可以计算出回收哪几个Region价值最高，且符合用户预期的停顿时间。</p></blockquote>]]></content>
    
    
    <summary type="html">GC学习</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习</title>
    <link href="http://example.com/2023/06/19/jvm/"/>
    <id>http://example.com/2023/06/19/jvm/</id>
    <published>2023-06-19T09:22:35.000Z</published>
    <updated>2023-07-11T03:20:50.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>线程独占:栈,本地方法栈,程序计数器<br>线程共享:堆,方法区</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法 出口等信息.调用方法时执行入栈,方法返回式执行出栈.<br>使用jclasslib工具可以查看class类文件的结构。<br><img src="/img/jvm/7.png" alt="github"></p><p>栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出 stackOverflowError;如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出 OutofMemoryError。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行 Native方法时,程序计数器为空.</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆 没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行 垃圾的回收管理</p><p><img src="/img/jvm/6.png" alt="github"></p><p>若堆的空间不够实例分配，则 OutOfMemoryError。</p><h2 id="方法区-1-8以后为元空间"><a href="#方法区-1-8以后为元空间" class="headerlink" title="方法区(1.8以后为元空间)"></a>方法区(1.8以后为元空间)</h2><p>又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现</p><h2 id="JVM-内存可见性"><a href="#JVM-内存可见性" class="headerlink" title="JVM 内存可见性"></a>JVM 内存可见性</h2><p><img src="/img/jvm/0.png" alt="github"></p><p>JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主 内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.</p><p><img src="/img/jvm/1.png" alt="github"></p><h2 id="类加载与卸载"><a href="#类加载与卸载" class="headerlink" title="类加载与卸载"></a>类加载与卸载</h2><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><p><img src="/img/jvm/2.png" alt="github"></p><p>其中<strong>验证,准备,解析</strong>合称链接</p><ul><li>加载：通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象. </li><li>验证：确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.</li><li>准备：进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变量, 因为final变量在编译时分配.</li><li>解析：将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等. </li><li>初始化：主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用时才会初始化.</li></ul><p>触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用<code>Class.forName</code>反射类的时候,<br>或者某个子类初始化的时候. Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.</p><h4 id="加载机制-双亲委派模式"><a href="#加载机制-双亲委派模式" class="headerlink" title="加载机制-双亲委派模式"></a>加载机制-双亲委派模式</h4><p><img src="/img/jvm/4.png" alt="github"><br>双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载<code>.*</code><br>优点:</p><ol><li>避免类的重复加载</li><li>避免Java的核心API被篡改</li></ol><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObject</span> &#123;</span><br><br>&#125;<br><span class="hljs-comment">//加载该类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    Class clazz = MyObject.class;<br>    System.out.<span class="hljs-built_in">println</span>(clazz.<span class="hljs-built_in">getClassLoader</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">//输出结果<br><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> <span class="hljs-title">name: java.lang</span><br></code></pre></td></tr></table></figure></p><h6 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><strong><em>ClassLoader</em></strong></h6><p>所有的类加载器（除了根类加载器）都必须继承java.lang.ClassLoader。它是一个抽象类，主要的方法如下：</p><ul><li>loadClass：这里就是双亲委托模式的代码实现。只有父类加载器加载不到类时，会调用findClass方法进行类的查找，所以，在定义自己的类加载器时，不要覆盖掉该方法，而应该覆盖掉findClass方法。</li><li>findClass：在自定义类加载器时，一般我们需要覆盖这个方法，且ClassLoader中给出了一个默认的错误实现。</li><li>defineClass：用来将byte字节解析成虚拟机能够识别的Class对象。defineClass()方法通常与findClass()方法一起使用。在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法获取要加载类的字节码，然后调用defineClass()方法生成Class对象。</li><li>resolveClass：连接指定的类，类加载器可以使用此方法来连接类。</li></ul><h6 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a><strong><em>URLClassLoader</em></strong></h6><p>JDK提供了一个更加易用的类加载器URLClassLoader，它扩展了ClassLoader，能够从本地或者网络上指定的位置加载类。我们可以使用该类作为自定义的类加载器使用。</p><ul><li><code>public URLClassLoader(URL[] urls)</code>: 指定要加载的类所在的URL地址，父类加载器默认为系统类加载器。</li><li><code>public URLClassLoader(URL[] urls, ClassLoader parent)</code>：指定要加载的类所在的URL地址，并指定父类加载器。</li></ul><h6 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong><em>自定义类加载器</em></strong></h6><p>我们如果需要自定义类加载器，只需要继承ClassLoader类，并覆盖掉findClass方法即可。<br><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyFileClassLoader <span class="hljs-keyword">extends</span> ClassLoader &#123;<br>    <span class="hljs-keyword">private</span> String directory;<span class="hljs-comment">//被加载的类所在的目录</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定要加载的类所在的文件目录</span><br><span class="hljs-comment">     * @param directory</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> MyFileClassLoader(String directory,ClassLoader parent)&#123;<br>        <span class="hljs-keyword">super</span>(parent);<br>        <span class="hljs-keyword">this</span>.directory = directory;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">Class</span>&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//把类名转换为目录</span><br>            String <span class="hljs-keyword">file</span> = directory+<span class="hljs-keyword">File</span>.separator+name.replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-keyword">File</span>.separator)+<span class="hljs-string">&quot;.class&quot;</span>;<br>            <span class="hljs-comment">//构建输入流</span><br>            InputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">file</span>);<br>            <span class="hljs-comment">//存放读取到的字节数据</span><br>            ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            <span class="hljs-keyword">byte</span> buf[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>((len=in.<span class="hljs-keyword">read</span>(buf))!=-<span class="hljs-number">1</span>)&#123;<br>                baos.<span class="hljs-keyword">write</span>(buf,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            <span class="hljs-keyword">byte</span> data[] = baos.toByteArray();<br>            in.close();<br>            baos.close();<br>            <span class="hljs-keyword">return</span> defineClass(name,data,<span class="hljs-number">0</span>,data.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br>        MyFileClassLoader myFileClassLoader = <span class="hljs-keyword">new</span> MyFileClassLoader(<span class="hljs-string">&quot;d:/&quot;</span>);<br>        <span class="hljs-keyword">Class</span> clazz = myFileClassLoader.loadClass(<span class="hljs-string">&quot;com.itheima.Demo&quot;</span>);<br>        clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="类的显式与隐式加载"><a href="#类的显式与隐式加载" class="headerlink" title="类的显式与隐式加载"></a><strong><em>类的显式与隐式加载</em></strong></h6><p>类的加载方式是指虚拟机将class文件加载到内存的方式。</p><ul><li>显式加载是指在java代码中通过调用ClassLoader加载class对象，比如Class.forName(String name)；this.getClass().getClassLoader().loadClass()加载类。</li><li>隐式加载指不需要在java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中。比如在加载某个class时，该class引用了另外一个类的对象，那么这个对象的字节码文件就会被虚拟机自动加载到内存中。</li></ul><h6 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a><strong><em>线程上下文类加载器</em></strong></h6><p>在Java中存在着很多的服务提供者接口SPI，全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，这些接口一般由第三方提供实现，常见的SPI有JDBC、JNDI等。这些SPI的接口（比如JDBC中的java.sql.Driver）属于核心类库，一般存在rt.jar包中，由根类加载器加载。<br>而第三方实现的代码一般作为依赖jar包存放在classpath路径下，由于SPI接口中的代码需要加载具体的第三方实现类并调用其相关方法，SPI的接口类是由根类加载器加载的，Bootstrap类加载器无法直接加载位于classpath下的具体实现类。<br>由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载SPI的具体实现类。在这种情况下，java提供了线程上下文类加载器用于解决以上问题。</p><p>线程上下文类加载器可以通过java.lang.Thread的getContextClassLoader()来获取，或者通过setContextClassLoader(ClassLoader cl)来设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader），在线程中运行的代码可以通过此类加载器来加载类或资源。</p><p>显然这种加载类的方式破坏了双亲委托模型，但它使得java类加载器变得更加灵活。<br><img src="/img/jvm/5.png" alt="github"><br>我们以JDBC中的类为例做一下说明。在JDBC中有一个类java.sql.DriverManager，它是rt.jar中的类，用来注册实现了java.sql.Driver接口的驱动类，而java.sql.Driver的实现类一般都是位于数据库的驱动jar包中的。</p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间.</p><div class="table-container"><table><thead><tr><th>堆分代</th><th></th><th></th></tr></thead><tbody><tr><td>年轻代</td><td>Dden</td><td>Survivor1</td><td>Survivor2</td></tr><tr><td>老年代</td><td>Tenured</td><td>Tenured</td><td>Tenured</td></tr><tr><td>永久代</td><td>Prem/MetaSpcae</td><td>Prem/MetaSpcae</td><td>Prem/MetaSpcae</td></tr></tbody></table></div><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><h6 id="1-G1算法"><a href="#1-G1算法" class="headerlink" title="1.G1算法"></a>1.G1算法</h6><p>1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的 增量式清理,以保证停顿时间不会过长<br>其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分 用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.<br>同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间. </p><p>年轻代回收:并行复制采用复制算法,并行收集,会StopTheWorld.<br>老年代回收:会对年轻代一并回收</p><p>初始标记完成堆root对象的标记,会StopTheWorld.<br>并发标记 GC线程和应用线程并发执行.<br>最终标记完成三色标记周期,会StopTheWorld.<br>复制/清楚会优先对可回收空间加大的区域进行回收</p><h6 id="2-ZGC算法"><a href="#2-ZGC算法" class="headerlink" title="2.ZGC算法"></a>2.ZGC算法</h6><p>前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间.</p><p>什么时候会触发FullGC<br>-<br>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p><h2 id="1-旧生代空间不足"><a href="#1-旧生代空间不足" class="headerlink" title="1. 旧生代空间不足"></a>1. 旧生代空间不足</h2><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误:java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p><h2 id="2-Permanet-Generation空间满"><a href="#2-Permanet-Generation空间满" class="headerlink" title="2. Permanet Generation空间满"></a>2. Permanet Generation空间满</h2><p>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较 多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经 过Full GC仍然回收不了，那么JVM会抛出如下错误信息:java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p><h2 id="3-CMS-GC时出现promotion-failed和concurrent-mode-failure"><a href="#3-CMS-GC时出现promotion-failed和concurrent-mode-failure" class="headerlink" title="3. CMS GC时出现promotion failed和concurrent mode failure"></a>3. CMS GC时出现promotion failed和concurrent mode failure</h2><p>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。<br>promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代 也放不下造成的;concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此 时旧生代空间不足造成的。 应对措施为:增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本 中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可 通过设置-XX:CMSMaxAbortablePrecleanTime=5(单位为ms)来避免。</p><h2 id="4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间"><a href="#4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间" class="headerlink" title="4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间"></a>4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</h2><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的 现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小 大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先 检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。 当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次 Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。 除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一 次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的 间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p><h2 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h2><ul><li>当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据 读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载 完成后，Class对象还不完整，所以此时的类还不可用。</li><li>当类被加载后就进入连接阶段，这一阶段包括 验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。</li><li>最后JVM对类进行初始化，包括:1)如果类存在直接的父类并且这个类还没有被初始化，那么就先 初始化父类;2)如果类中存在初始化语句，就依次执行这些初始化语句。 </li><li>类的加载是由类加载器完成的,类的加载首先请求父类加载器加载，父类加载器 无能为力时才由其子类加载器自行加载。</li></ul><h2 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h2><ul><li>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类(类加载过程在后边讲)</li><li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li><li>将除对象头外的对象内存空间初始化为0</li><li>对对象头进行必要设置</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>连接，连接又包含三块内容:验证、准备、初始化。 <ul><li>1)验证，文件格式、元数据、字节码、符号 引用验证; </li><li>2)准备，为类的静态变量分配内存，并将其初始化为默认值; </li><li>3)解析，把类中的符 号引用转换为直接引用</li></ul></li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><h2 id="Java的对象结构"><a href="#Java的对象结构" class="headerlink" title="Java的对象结构"></a>Java的对象结构</h2><p>Java对象由三个部分组成:对象头、实例数据、对齐填充。</p><ul><li>对象头由两部分组成，第一部分存储对象自身的运行时数据:哈希码、GC分代年龄、锁标识状态、线 程持有的锁、偏向线程ID(一般占32/64 bit)。第二部分是指针类型，指向对象的类元数据类型(即对 象代表哪个类)。如果是数组对象，则对象头中还有一部分用来记录数组长度。</li><li>实例数据用来存储对象真正的有效信息(包括父类继承下来的和自己定义的)</li><li>对齐填充:JVM要求对象起始地址必须是8字节的整数倍(8字节对齐)</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>GC最基础的算法有三种: 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p><ul><li>标记 -清除算法，“标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分为“标记”和“清除”两 个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li><li>复制算法，“复制”(Copying)的收集算法，它将可用内存按容量划分为大小相等的两块，每次只 使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已 使用过的内存空间一次清理掉。</li><li>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清 理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li><li>分代收集算法，“分代收集”(Generational Collection)算法，把Java堆分为新生代和老年代，这 样就可以根据各个年代的特点采用最适当的收集算法。</li></ul><h2 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h2><ul><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机 进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了 一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 </li><li>jstack，用于生成java虚拟机当前时刻的线程快照。</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><p>常用调优工具分为两类,jdk自带监控工具:jconsole和jvisualvm，第三方有:MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控 和管理控制台，用于对JVM中内存，线程和类等的监控 </li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照;监控内存变化、GC变化等。 </li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 </li><li>GChisto，一款专业分析gc日志的工具</li></ul><h2 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h2><p>设定堆内存大小 </p><ul><li>-Xmx:堆内存最大限制。<br>设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代 </li><li>-XX:NewSize:新生代大小</li><li>-XX:NewRatio 新生代和老生代占比 </li><li>-XX:SurvivorRatio:伊甸园空间和幸存者空间的占比</li></ul><p>设定垃圾回收器 年轻代用 </p><ul><li>-XX:+UseParNewGC </li></ul><p>年老代用</p><ul><li>-XX:+UseConcMarkSweepGC</li></ul><p>PermSpace 和 MetaSpace<br>-<br>JDK 1.8后用元空间替代了 Perm Space;字符串常量存放到堆内存中。<br>MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。</p><ul><li>-XX:MetaspaceSize:分配给类元数据空间(以字节计)的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark)。此值为估计值，MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。 </li><li>-XX:MaxMetaspaceSize:分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li></ul>]]></content>
    
    
    <summary type="html">jvm学习</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <link href="http://example.com/2023/06/09/lambada/"/>
    <id>http://example.com/2023/06/09/lambada/</id>
    <published>2023-06-09T09:22:35.000Z</published>
    <updated>2023-06-13T08:07:59.534Z</updated>
    
    <content type="html"><![CDATA[<p>在Java8支持Lambda表达式以后，为了满足Lambda表达式的一些典型使用场景，JDK为我们提供了大量常用的函数式接口。它们主要在 <code>java.util.function</code> 包中，下面简单介绍几个其中的接口及其使用示例。</p><h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><p>Supplier接口是对象实例的提供者，定义了一个名叫get的抽象方法，它没有任何入参，并返回一个泛型T对象。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> java.util.<span class="hljs-keyword">function</span>;<br><br>@FunctionalInterface<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T <span class="hljs-keyword">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">Supplier&lt;<span class="hljs-built_in">String</span>&gt; stringCallable = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><br>这里的<code>lambda</code>声明了一个<code>Supplier</code>的实例。<br>它提供了一个<code>get</code>方法，来获取里面得到数值。<br><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">String</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = stringCallable.get();</span><br></code></pre></td></tr></table></figure></p><h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><p><code>Consumer</code>接口是一个类似消费者的接口，定义了一个名叫<code>accept</code>的抽象方法，它的入参是一个泛型T对象，没有任何返回（void），主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">final Consumer&lt;<span class="hljs-built_in">String</span>&gt; stringConsumer = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> data)</span> -&gt;</span> &#123;&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><p><code>Predicate</code>接口是判断是与否的接口，定义了一个名叫<code>test</code>的抽象方法，它的入参是一个泛型T对象，并返回一个<code>boolean</code>类型，主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">final Predicate&lt;<span class="hljs-built_in">String</span>&gt; stringFilter = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> data)</span> -&gt;</span> data.isEmpty();<br></code></pre></td></tr></table></figure></p><h2 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h2><p><code>Function</code>接口是对实例进行处理转换的接口，定义了一个名叫<code>apply</code>的抽象方法，它的入参是一个泛型T对象，并返回一个泛型R对象，主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">final <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; stringIntegerFunction = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> data)</span> -&gt;</span> <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p><h2 id="BiFunction接口"><a href="#BiFunction接口" class="headerlink" title="BiFunction接口"></a>BiFunction接口</h2><p><code>Function</code>接口的入参只有一个泛型对象，JDK还为我们提供了两个泛型对象入参的接口：<code>BiFunction</code>接口，主要源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BiFunction</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t, U u)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看看下面的例子：<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">final</span> BiFunction&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>, <span class="hljs-keyword">Double</span>&gt; stringIntegerDoubleBiFunction = (<span class="hljs-keyword">String</span> data, <span class="hljs-keyword">Integer</span> item) -&gt; <span class="hljs-keyword">Double</span>.parseDouble(item.toString());<br></code></pre></td></tr></table></figure></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>以上介绍的几个常用的函数式接口入参和返回，都是泛型对象的，也就是必须为引用类型。当我们传入或获取的是基本数据类型时，将会发生自动装箱和自动拆箱，带来不必要的性能损耗。</p><p>JDK为我们提供相应的函数式接口，如<code>LongSupplier</code>接口，定义了一个名叫getAsLong的抽象方法，签名是<code>() -&gt; long</code>。</p><h3 id="Supplier相关的接口"><a href="#Supplier相关的接口" class="headerlink" title="Supplier相关的接口"></a>Supplier相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Supplier</td><td>get</td><td><code>() -&gt; T</code></td></tr><tr><td>BooleanSupplier</td><td>getAsBoolean</td><td><code>() -&gt; boolean</code></td></tr><tr><td>DoubleSupplier</td><td>getAsDouble</td><td><code>() -&gt; double</code></td></tr><tr><td>IntSupplier</td><td>getAsInt</td><td><code>() -&gt; int</code></td></tr><tr><td>LongSupplier</td><td>getAsLong</td><td><code>() -&gt; long</code></td></tr></tbody></table></div><h3 id="Consumer相关的接口"><a href="#Consumer相关的接口" class="headerlink" title="Consumer相关的接口"></a>Consumer相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Consumer</td><td>accept</td><td><code>(T) -&gt; void</code></td></tr><tr><td>DoubleConsumer</td><td>accept</td><td><code>(double) -&gt; void</code></td></tr><tr><td>IntConsumer</td><td>accept</td><td><code>(int) -&gt; void</code></td></tr><tr><td>LongConsumer</td><td>accept</td><td><code>(long) -&gt; void</code></td></tr><tr><td>ObjDoubleConsumer</td><td>accept</td><td><code>(T, double) -&gt; void</code></td></tr><tr><td>ObjIntConsumer</td><td>accept</td><td><code>(T, int) -&gt; void</code></td></tr><tr><td>ObjLongConsumer</td><td>accept</td><td><code>(T, long) -&gt; void</code></td></tr></tbody></table></div><h3 id="Predicate相关的接口"><a href="#Predicate相关的接口" class="headerlink" title="Predicate相关的接口"></a>Predicate相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Predicate</td><td>test</td><td><code>(T) -&gt; boolean</code></td></tr><tr><td>BiPredicate</td><td>test</td><td><code>(T, U) -&gt; boolean</code></td></tr><tr><td>DoublePredicate</td><td>test</td><td><code>(double) -&gt; boolean</code></td></tr><tr><td>IntPredicate</td><td>test</td><td><code>(int) -&gt; boolean</code></td></tr><tr><td>LongPredicate</td><td>test</td><td><code>(long) -&gt; boolean</code></td></tr></tbody></table></div><h3 id="Function相关的接口"><a href="#Function相关的接口" class="headerlink" title="Function相关的接口"></a>Function相关的接口</h3><div class="table-container"><table><thead><tr><th>接口名称</th><th>方法名称</th><th>方法签名</th></tr></thead><tbody><tr><td>Function</td><td>apply</td><td><code>(T) -&gt; R</code></td></tr><tr><td>BiFunction</td><td>apply</td><td><code>(T, U) -&gt; R</code></td></tr><tr><td>DoubleFunction</td><td>apply</td><td><code>(double) -&gt; R</code></td></tr><tr><td>DoubleToIntFunction</td><td>applyAsInt</td><td><code>(double) -&gt; int</code></td></tr><tr><td>DoubleToLongFunction</td><td>applyAsLong</td><td><code>(double) -&gt; long</code></td></tr><tr><td>IntFunction</td><td>apply</td><td><code>(int) -&gt; R</code></td></tr><tr><td>IntToDoubleFunction</td><td>applyAsDouble</td><td><code>(int) -&gt; double</code></td></tr><tr><td>IntToLongFunction</td><td>applyAsLong</td><td><code>(int) -&gt; long</code></td></tr><tr><td>LongFunction</td><td>apply</td><td><code>(long) -&gt; R</code></td></tr><tr><td>LongToDoubleFunction</td><td>applyAsDouble</td><td><code>(long) -&gt; double</code></td></tr><tr><td>LongToIntFunction</td><td>applyAsInt</td><td><code>(long) -&gt; int</code></td></tr><tr><td>ToDoubleFunction</td><td>applyAsDouble</td><td><code>(T) -&gt; double</code></td></tr><tr><td>ToDoubleBiFunction</td><td>applyAsDouble</td><td><code>(T, U) -&gt; double</code></td></tr><tr><td>ToIntFunction</td><td>applyAsInt</td><td><code>(T) -&gt; int</code></td></tr><tr><td>ToIntBiFunction</td><td>applyAsInt</td><td><code>(T, U) -&gt; int</code></td></tr><tr><td>ToLongFunction</td><td>applyAsLong</td><td><code>(T) -&gt; long</code></td></tr><tr><td>ToLongBiFunction</td><td>applyAsLong</td><td><code>(T, U) -&gt; long</code></td></tr></tbody></table></div><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。</p><h2 id="Java8内置了一些常用的方法接口FunctionalInterface"><a href="#Java8内置了一些常用的方法接口FunctionalInterface" class="headerlink" title="Java8内置了一些常用的方法接口FunctionalInterface"></a>Java8内置了一些常用的方法接口FunctionalInterface</h2><p>这种接口只定义了一个抽象方法，并且用<code>@FunctionalInterface</code>注解标记，如Predicate,Consumer,Function,Supplier,Comparator等等，这些都属于<code>java.util.function</code>包中<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br><span class="hljs-comment">// 省略不贴了</span><br></code></pre></td></tr></table></figure><br>在使用时，传入<code>类名::实例方法名</code>实现的效果是等价的</p>]]></content>
    
    
    <summary type="html">lambda表达式</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java Stream管道数据处理操作</title>
    <link href="http://example.com/2023/06/09/javaStream/"/>
    <id>http://example.com/2023/06/09/javaStream/</id>
    <published>2023-06-09T09:22:35.000Z</published>
    <updated>2023-06-13T14:49:53.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-Stream管道数据处理操作"><a href="#Java-Stream管道数据处理操作" class="headerlink" title="Java Stream管道数据处理操作"></a>Java Stream管道数据处理操作</h2><p>在使用的过程中分为三个阶段。<br><img src="/img/JavaStream/0.png" alt="github"></p><ul><li>第一阶段(图中蓝色)：将集合、数组、或行文本文件转换为java Stream管道流</li><li>第二阶段(图中虚线部分)：管道流式数据处理操作，处理管道中的每一个元素。上一个管道中的输出元素作为下一个管道的输入元素。</li><li>第三阶段(图中绿色)：管道流结果处理操作。</li></ul><p>中间操作可分为：</p><ul><li>无状态（Stateless）操作：指元素的处理不受之前元素的影响</li><li>有状态（Stateful）操作：指该操作只有拿到所有元素之后才能继续下去</li></ul><p>终结操作可分为：</p><ul><li>短路（Short-circuiting）操作：指遇到某些符合条件的元素就可以得到最终结果</li><li>非短路（Unshort-circuiting）操作：指必须处理完所有元素才能得到最终结果</li></ul><p><img src="/img/JavaStream/1.png" alt="github"></p><h2 id="Stream-构成与创建"><a href="#Stream-构成与创建" class="headerlink" title="Stream 构成与创建"></a>Stream 构成与创建</h2><h3 id="java-util-Collection-stream-方法用集合创建流"><a href="#java-util-Collection-stream-方法用集合创建流" class="headerlink" title="java.util.Collection.stream() 方法用集合创建流"></a>java.util.Collection.stream() 方法用集合创建流</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">List&lt;<span class="hljs-keyword">String</span>&gt; list = Arrays.<span class="hljs-built_in">asList</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;stream&quot;</span>);<br><span class="hljs-comment">//创建顺序流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = list.<span class="hljs-built_in">stream</span>();<br><span class="hljs-comment">//创建并行流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; parallelStream = list.<span class="hljs-built_in">parallelStream</span>();<br></code></pre></td></tr></table></figure><h3 id="java-util-Arrays-stream-T-array-方法用数组创建流"><a href="#java-util-Arrays-stream-T-array-方法用数组创建流" class="headerlink" title="java.util.Arrays.stream(T[] array)方法用数组创建流"></a>java.util.Arrays.stream(T[] array)方法用数组创建流</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span>[] array = &#123;<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;;<br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; arrayStream = Arrays.<span class="hljs-built_in">stream</span>(array);<br></code></pre></td></tr></table></figure><h3 id="Stream的静态方法：of-、iterate-、generate"><a href="#Stream的静态方法：of-、iterate-、generate" class="headerlink" title="Stream的静态方法：of()、iterate()、generate()"></a>Stream的静态方法：of()、iterate()、generate()</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">Stream&lt;Integer&gt; stream1 = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br> <br>Stream&lt;Integer&gt; stream2 = Stream.iterate<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>)</span>.<span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">stream2</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(System.out::println)</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-title">Stream</span>&lt;<span class="hljs-title">Double</span>&gt; <span class="hljs-title">stream3</span> = <span class="hljs-title">Stream</span>.<span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-built_in">Math</span>::random)</span>.<span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">stream3</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(System.out::println)</span></span><br></code></pre></td></tr></table></figure><h3 id="stream和parallelStream的简单区分"><a href="#stream和parallelStream的简单区分" class="headerlink" title="stream和parallelStream的简单区分"></a>stream和parallelStream的简单区分</h3><p>tream是顺序流，由主线程按顺序对流执行操作，而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，需要注意使用并行流的前提是流中的数据处理没有顺序要求（会乱序，即使用了forEachOrdered）。</p><p>除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">Optional&lt;Integer&gt; findFirst = list.stream<span class="hljs-params">()</span><span class="hljs-string">.parallel</span><span class="hljs-params">()</span><span class="hljs-string">.filter</span><span class="hljs-params">(x-&gt;x&gt;4)</span><span class="hljs-string">.findFirst</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></p><h2 id="无状态（Stateless）操作"><a href="#无状态（Stateless）操作" class="headerlink" title="无状态（Stateless）操作"></a>无状态（Stateless）操作</h2><h3 id="filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。"><a href="#filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。" class="headerlink" title="filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。"></a>filter：筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; filter(<span class="hljs-type">Predicate</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; predicate);<br></code></pre></td></tr></table></figure><h3 id="映射-map、flatMap、peek"><a href="#映射-map、flatMap、peek" class="headerlink" title="映射(map、flatMap、peek)"></a>映射(map、flatMap、peek)</h3><h5 id="map：一个元素类型为-T-的流转换成元素类型为-R-的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；"><a href="#map：一个元素类型为-T-的流转换成元素类型为-R-的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；" class="headerlink" title="map：一个元素类型为 T 的流转换成元素类型为 R 的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；"></a>map：一个元素类型为 T 的流转换成元素类型为 R 的流，这个方法传入一个Function的函数式接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象；</h5><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-keyword">map</span>(<span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> R&gt; mapper);<br></code></pre></td></tr></table></figure><h5 id="flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。"><a href="#flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。" class="headerlink" title="flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。"></a>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</h5><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">R</span>&gt;</span> Stream<span class="hljs-tag">&lt;<span class="hljs-name">R</span>&gt;</span> flatMap(Function</span><span class="php"><span class="hljs-meta">&lt;?</span> super T, ? <span class="hljs-keyword">extends</span> Stream<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> R&gt;&gt; mapper)</span><br></code></pre></td></tr></table></figure><p>例子：<br><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">List&lt;<span class="hljs-keyword">String</span>&gt; list1 = Arrays.asList(<span class="hljs-string">&quot;m,k,l,a&quot;</span>, <span class="hljs-string">&quot;1,3,5,7&quot;</span>);<br>List&lt;<span class="hljs-keyword">String</span>&gt; listNew = list1.stream().flatMap(s -&gt; &#123;<br>    <span class="hljs-comment">// 将每个元素转换成一个stream</span><br>    <span class="hljs-keyword">String</span>[] <span class="hljs-built_in">split</span> = s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>    Stream&lt;<span class="hljs-keyword">String</span>&gt; s2 = Arrays.stream(<span class="hljs-built_in">split</span>);<br>    <span class="hljs-keyword">return</span> s2;<br>&#125;).collect(Collectors.toList());<br></code></pre></td></tr></table></figure></p><h5 id="peek：peek-操作接收的是一个-Consumer-函数。顾名思义-peek-操作会按照-Consumer-函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。"><a href="#peek：peek-操作接收的是一个-Consumer-函数。顾名思义-peek-操作会按照-Consumer-函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。" class="headerlink" title="peek：peek 操作接收的是一个 Consumer 函数。顾名思义 peek 操作会按照 Consumer 函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。"></a>peek：peek 操作接收的是一个 Consumer<T> 函数。顾名思义 peek 操作会按照 Consumer<T> 函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。</h5><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Stream</span>&lt;<span class="hljs-type">T</span>&gt; peek(<span class="hljs-type">Consumer</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; action);<br></code></pre></td></tr></table></figure><p>这里因为<code>peek</code>是中间操作层，因此如果以他结尾，则无法完成事件消费。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;felord.cn&quot;</span>);<br>stream.peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println);<br><br>Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;felord.cn&quot;</span>);<br>stream.peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure></p><h5 id="peek-AND-map"><a href="#peek-AND-map" class="headerlink" title="peek AND map"></a>peek AND map</h5><ul><li>peek 操作 一般用于不想改变流中元素本身的类型或者只想元素的内部状态时；</li><li>map 则用于改变流中元素本身类型，即从元素中派生出另一种类型的操作。</li></ul><h5 id="mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong"><a href="#mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong" class="headerlink" title="mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong"></a>mapToInt、mapToLong、mapToDouble、flatMapToDouble、flatMapToInt、flatMapToLong</h5><p>以上这些操作是map和flatMap的特例版，也就是针对特定的数据类型进行映射处理。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">IntStream map<span class="hljs-constructor">ToInt(ToIntFunction&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">mapper</span>)</span>;<br>LongStream map<span class="hljs-constructor">ToLong(ToLongFunction&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">mapper</span>)</span>; <br>DoubleStream map<span class="hljs-constructor">ToDouble(ToDoubleFunction&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">mapper</span>)</span>;<br>IntStream flat<span class="hljs-constructor">MapToInt(Function&lt;? <span class="hljs-params">super</span> T, ? <span class="hljs-params">extends</span> IntStream&gt; <span class="hljs-params">mapper</span>)</span>;<br>LongStream flat<span class="hljs-constructor">MapToLong(Function&lt;? <span class="hljs-params">super</span> T, ? <span class="hljs-params">extends</span> LongStream&gt; <span class="hljs-params">mapper</span>)</span>;<br>DoubleStream flat<span class="hljs-constructor">MapToDouble(Function&lt;? <span class="hljs-params">super</span> T, ? <span class="hljs-params">extends</span> DoubleStream&gt; <span class="hljs-params">mapper</span>)</span>;<br></code></pre></td></tr></table></figure></p><h3 id="无序化（unordered）"><a href="#无序化（unordered）" class="headerlink" title="无序化（unordered）"></a>无序化（unordered）</h3><p><code>unordered()</code>操作不会执行任何操作来显式地对流进行排序。它的作用是消除了流必须保持有序的约束，从而允许后续操作使用不必考虑排序的优化。</p><blockquote><p>对于顺序流，顺序的存在与否不会影响性能，只影响确定性。如果流是顺序的，则在相同的源上重复执行相同的流管道将产生相同的结果;<br>如果是非顺序流，重复执行可能会产生不同的结果。 对于并行流，放宽排序约束有时可以实现更高效的执行。<br>在流有序时, 但用户不特别关心该顺序的情况下，使用 unordered 明确地对流进行去除有序约束可以改善某些有状态或终端操作的并行性能。</p></blockquote><h2 id="有状态（Stateful）操作"><a href="#有状态（Stateful）操作" class="headerlink" title="有状态（Stateful）操作"></a>有状态（Stateful）操作</h2><h3 id="distinct：返回由该流的不同元素组成的流（根据-Object-equals-Object-）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。"><a href="#distinct：返回由该流的不同元素组成的流（根据-Object-equals-Object-）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。" class="headerlink" title="distinct：返回由该流的不同元素组成的流（根据 Object.equals(Object)）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。"></a>distinct：返回由该流的不同元素组成的流（根据 Object.equals(Object)）；distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">distinct</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><strong>就是去重</strong></p><h3 id="sorted：返回由该流的元素组成的流，并根据自然顺序排序"><a href="#sorted：返回由该流的元素组成的流，并根据自然顺序排序" class="headerlink" title="sorted：返回由该流的元素组成的流，并根据自然顺序排序"></a>sorted：返回由该流的元素组成的流，并根据自然顺序排序</h3><p>该接口有两种形式：无参和有参数<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(Comparator&lt;? super T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><br>那区别其实就在于：<code>传入比较器的参数，可以自定义这个比较器，即自定义比较规则。</code></p><h3 id="limit：获取流中n个元素返回的流"><a href="#limit：获取流中n个元素返回的流" class="headerlink" title="limit：获取流中n个元素返回的流"></a>limit：获取流中n个元素返回的流</h3><p>mysql的中的limit函数一样的效果，返回指定个数的元素流。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br></code></pre></td></tr></table></figure></p><h3 id="skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。"><a href="#skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。" class="headerlink" title="skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。"></a>skip：在丢弃流的第一个n元素之后，返回由该流的其余元素组成的流。</h3><p>跳过第n个元素，返回其后面的元素流；<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">Stream</span>&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure></p><h2 id="短路（Short-circuiting）操作"><a href="#短路（Short-circuiting）操作" class="headerlink" title="短路（Short-circuiting）操作"></a>短路（Short-circuiting）操作</h2><h3 id="anyMatch：Stream-中只要有一个元素符合传入的-predicate，返回-true"><a href="#anyMatch：Stream-中只要有一个元素符合传入的-predicate，返回-true" class="headerlink" title="anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true;"></a>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true;</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">anyMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="allMatch：Stream-中全部元素符合传入的-predicate，返回-true"><a href="#allMatch：Stream-中全部元素符合传入的-predicate，返回-true" class="headerlink" title="allMatch：Stream 中全部元素符合传入的 predicate，返回 true;"></a>allMatch：Stream 中全部元素符合传入的 predicate，返回 true;</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="noneMatch：Stream-中没有一个元素符合传入的-predicate，返回-true"><a href="#noneMatch：Stream-中没有一个元素符合传入的-predicate，返回-true" class="headerlink" title="noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true."></a>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true.</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">noneMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）"><a href="#findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）" class="headerlink" title="findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）"></a>findFirst：用于返回满足条件的第一个元素（但是该元素是封装在Optional类中）</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Optional&lt;T&gt; findFirst()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）"><a href="#findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）" class="headerlink" title="findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）"></a>findAny：返回流中的任意元素（但是该元素也是封装在Optional类中）</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Optional&lt;T&gt; findAny()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>findAny会每次按顺序返回第一个元素。那这个时候，可能会认为findAny与findFirst方法是一样的效果。其实不然，findAny()操作，返回的元素是不确定的，对于同一个列表多次调用findAny()有可能会返回不同的值。使用findAny()是为了更高效的性能。如果是数据较少，串行地情况下，一般会返回第一个结果，如果是并行的情况，那就不能确保是第一个。</p><h2 id="非短路（Unshort-circuiting）操作"><a href="#非短路（Unshort-circuiting）操作" class="headerlink" title="非短路（Unshort-circuiting）操作"></a>非短路（Unshort-circuiting）操作</h2><h3 id="forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式"><a href="#forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式" class="headerlink" title="forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式"></a>forEach：该方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>不同于普通的for循环，他在接收外部参数的时候，要求外部变量必须是最终的，不可变的，所以如果我们想要对其进行修改，那是不可能的！如果必须这么使用，可以将外部变量，移至表达式之中使用才行！<br>或者使用原子类来包装这些需要改变的外部参数。</p><h3 id="forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式"><a href="#forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式" class="headerlink" title="forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式"></a>forEachOrdered：该方法接收一个Lambda表达式，然后按顺序在Stream的每一个元素上执行该表达式</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEachOrdered</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>该功能其实和forEach是很相似的，也是循环操作！那唯一的区别，就在于forEachOrdered是可以保证循环时元素是按原来的顺序逐个循环的！</p><p>有的时候，forEachOrdered也是不能百分百保证有序！<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;AAA,&quot;</span>,<span class="hljs-string">&quot;BBB,&quot;</span>,<span class="hljs-string">&quot;CCC,&quot;</span>,<span class="hljs-string">&quot;DDD,&quot;</span>).parallel<span class="hljs-literal">()</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">print</span>)</span>;<br></code></pre></td></tr></table></figure><br>在并行流时，由于是多线程处理，其实还是无法保证有序操作的！</p><h3 id="toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组"><a href="#toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组" class="headerlink" title="toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组"></a>toArray：返回包含此流元素的数组；当有参数时，则使用提供的generator函数分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Object</span> <span class="hljs-selector-attr">[]</span> toArray();<br>&lt;<span class="hljs-selector-tag">A</span>&gt; <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[]</span> toArray(IntFunction&lt;<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[]</span>&gt; generator);<br></code></pre></td></tr></table></figure><h3 id="reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值"><a href="#reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值" class="headerlink" title="reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值"></a>reduce：方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</h3><figure class="highlight bnf"><table><tr><td class="code"><pre><code class="hljs bnf"><br>Optional<span class="hljs-attribute">&lt;T&gt;</span> reduce(BinaryOperator<span class="hljs-attribute">&lt;T&gt;</span> accumulator);<br> <br>T reduce(T identity, BinaryOperator<span class="hljs-attribute">&lt;T&gt;</span> accumulator);<br> <br><span class="hljs-attribute">&lt;U&gt;</span> U reduce(U identity,BiFunction<span class="hljs-attribute">&lt;U, ? super T, U&gt;</span> accumulator,BinaryOperator<span class="hljs-attribute">&lt;U&gt;</span> combiner);<br></code></pre></td></tr></table></figure><ul><li>1个参数：累加处理的纯函数</li><li>2个参数：基础上增加一个基础值</li><li>3个参数：在基础上，增加了一个针对并行流的一个纯函数，组合器的作用，是对参数2中的数据进行处理，产生的结果进行一次合并器处理。</li></ul><h3 id="collect：称为收集器，是一个终端操作-它接收的参数是将流中的元素累积到汇总结果的各种方式"><a href="#collect：称为收集器，是一个终端操作-它接收的参数是将流中的元素累积到汇总结果的各种方式" class="headerlink" title="collect：称为收集器，是一个终端操作,它接收的参数是将流中的元素累积到汇总结果的各种方式"></a>collect：称为收集器，是一个终端操作,它接收的参数是将流中的元素累积到汇总结果的各种方式</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">&lt;<span class="hljs-built_in">R</span>, A&gt; <span class="hljs-built_in">R</span> collect(Collector&lt;? super T, A, <span class="hljs-built_in">R</span>&gt; collector);<br> <br>&lt;<span class="hljs-built_in">R</span>&gt; <span class="hljs-built_in">R</span> collect(Supplier&lt;<span class="hljs-built_in">R</span>&gt; supplier,<br>                  BiConsumer&lt;<span class="hljs-built_in">R</span>, ? super T&gt; accumulator,<br>                  BiConsumer&lt;<span class="hljs-built_in">R</span>, <span class="hljs-built_in">R</span>&gt; combiner);<br></code></pre></td></tr></table></figure><p>第一种方式会比较经常使用到，也比较方便使用，现在先看一看里面常用的一些方法：</p><div class="table-container"><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>用于</th></tr></thead><tbody><tr><td>toList</td><td><code>List&lt;T&gt;</code></td><td>把流中所有元素收集到List中</td></tr><tr><td>toSet</td><td><code>Set&lt;T&gt;</code></td><td>把流中所有元素收集到Set中,删除重复项</td></tr><tr><td>toCollection</td><td><code>Collection&lt;T&gt;</code></td><td>把流中所有元素收集到给定的供应源创建的集合中</td></tr><tr><td>Counting</td><td>Long</td><td>计算流中元素个数</td></tr><tr><td>SummingInt</td><td>Integer</td><td>对流中元素的一个整数属性求和</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素integer属性的平均值</td></tr><tr><td>Joining</td><td>String</td><td>连接流中每个元素的toString方法生成的字符串</td></tr><tr><td>maxBy</td><td><code>Optional&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最大元素的optional。如果为空返回的是Optional.empty()</td></tr><tr><td>minBy</td><td><code>Optional&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最小元素的optional。如果为空返回的是Optional.empty()</td></tr><tr><td>Reducing</td><td>归约操作产生的类型</td><td>从一个作为累加器的初始值开始,利用binaryOperator与流中的元素逐个结合,从而将流归约为单个值</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个转换器,对其结果应用转换函数</td></tr><tr><td>groupingBy</td><td><code>Map&lt;K,List&lt;T&gt;&gt;</code></td><td>根据流中元素的某个值对流中的元素进行分组,并将属性值做为结果map的键</td></tr><tr><td>partitioningBy</td><td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td><td>根据流中每个元素应用谓语的结果来对项目进行分区</td></tr></tbody></table></div><p>第二种方式看起来跟reduce的三个入参的方法有点类似，也可以用来实现filter、map等操作！</p><ul><li>第一个参数：构建新数据结构用于后面使用</li><li>第二个参数：用于对循环stream数据的流循环处理，如果在并行是则会对每个数据分线程处理第一个参数数据</li><li>第三个参数：只有在并行流中调用。完成第二个参数调用后，就会调用该合并器，与reduce的三个参数一致。</li></ul><h3 id="max：根据提供的Comparator返回此流的最大元素"><a href="#max：根据提供的Comparator返回此流的最大元素" class="headerlink" title="max：根据提供的Comparator返回此流的最大元素"></a>max：根据提供的Comparator返回此流的最大元素</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-built_in">max</span>(<span class="hljs-type">Comparator</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; comparator);<br></code></pre></td></tr></table></figure><h3 id="min：根据提供的Comparator返回此流的最小元素"><a href="#min：根据提供的Comparator返回此流的最小元素" class="headerlink" title="min：根据提供的Comparator返回此流的最小元素"></a>min：根据提供的Comparator返回此流的最小元素</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-built_in">min</span>(<span class="hljs-type">Comparator</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; comparator);<br></code></pre></td></tr></table></figure><h3 id="count：返回此流中的元素计数"><a href="#count：返回此流中的元素计数" class="headerlink" title="count：返回此流中的元素计数"></a>count：返回此流中的元素计数</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>这是对<code>NullPointerException</code>的异常问题专门提供的方案，在许多语言中都会以不同的方式进行呈现。<br>Optional 只是一个容器，它可以保存一些类型的值或者null。</p><div class="table-container"><table><thead><tr><th>修饰符和类型</th><th>方法和说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td>empty()返回一个空Optional实例。</td></tr><tr><td>boolean</td><td>equals(Object obj) 指示其他某个对象是否“等于”此Optional。</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>filter(Predicate&lt;? super T&gt; predicate)</code>如果存在一个值，并且该值与给定的谓词匹配，则返回一个Optional描述值的描述，否则返回一个empty Optional。</td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td><code>flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</code>如果存在值，则将提供的Optional-bearing映射函数应用于该值，返回该结果，否则返回empty Optional。</td></tr><tr><td>T</td><td>get()如果此值存在Optional，则返回该值，否则抛出NoSuchElementException。</td></tr><tr><td>int</td><td>hashCode()返回当前值的哈希码值（如果有）；如果没有值，则返回0（零）。</td></tr><tr><td>void</td><td><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>如果存在值，请使用该值调用指定的使用者，否则不执行任何操作。</td></tr><tr><td>boolean</td><td>isPresent()true如果存在值，则返回，否则返回false。</td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td><code>map(Function&lt;? super T,? extends U&gt; mapper)</code>如果存在值，则将提供的映射函数应用于该值，如果结果为非null，则返回Optional描述结果的描述。</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td>of(T value)返回Optional具有指定的当前非空值的。</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td>ofNullable(T value)返回Optional描述指定值的描述，如果不为null，则返回null Optional。</td></tr><tr><td>T</td><td>orElse(T other)返回值（如果存在），否则返回other。</td></tr><tr><td>T</td><td><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>返回值（如果存在），否则调用other并返回该调用的结果。</td></tr><tr><td><code>&lt;X extends Throwable&gt;</code> / T</td><td><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>返回包含的值（如果存在），否则抛出异常，由提供的供应商创建。</td></tr><tr><td>String</td><td>toString()返回此Optional的非空字符串表示形式，适用于调试。</td></tr></tbody></table></div><h3 id="Optional使用场景"><a href="#Optional使用场景" class="headerlink" title="Optional使用场景"></a>Optional使用场景</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">String isocode = user.get<span class="hljs-constructor">Address()</span>.get<span class="hljs-constructor">Country()</span>.get<span class="hljs-constructor">Isocode()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br> <br><span class="hljs-comment">//将上面的代码进行判空处理</span><br><span class="hljs-keyword">if</span> (user != null) &#123;<br>    Address address = user.get<span class="hljs-constructor">Address()</span>;<br>    <span class="hljs-keyword">if</span> (address != null) &#123;<br>        Country country = address.get<span class="hljs-constructor">Country()</span>;<br>        <span class="hljs-keyword">if</span> (country != null) &#123;<br>            String isocode = country.get<span class="hljs-constructor">Isocode()</span>;<br>            <span class="hljs-keyword">if</span> (isocode != null) &#123;<br>                isocode = isocode.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以转换成如下写法：<br><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Optional</span><span class="hljs-selector-class">.ofNullable</span>(user)<br><span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">User</span>::getAddress)<br><span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">Address</span>::getCountry)<br><span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">Country</span>::getIsocode)<br><span class="hljs-selector-class">.ifPresent</span>(s-&gt; s.toUpperCase());<br></code></pre></td></tr></table></figure><br>不仅仅是美观，而是在数据整体的包装且进行数据流传递处理。</p><ul><li>当使用值为空的情况，并非源于报错时产生，可以使用Optional（因为有错误的情况，肯定是不正常的，需要处理的）</li><li>对于一个对象，我们需要做判空、过滤、某些校验的时候，可以使用Optional</li></ul><h3 id="常用方法使用"><a href="#常用方法使用" class="headerlink" title="常用方法使用"></a>常用方法使用</h3><h5 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h5><p>empty 方法返回一个不包含值的 Optional 实例, 注意不保证返回的 empty 是单例, 不要用 == 比较。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="of"><a href="#of" class="headerlink" title="of()"></a>of()</h5><p>返回一个 Optional 实例；代表指定的非空值, 如果传入 null 会立刻抛出空指针异常。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T value)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable()"></a>ofNullable()</h5><p>返回一个 Optional 实例, 如果指定非空值则实例包含非空值, 如果传入 null 返回不包含值的 empty<br><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">ofNullable</span><span class="hljs-params">(T value)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent()"></a>isPresent()</h5><p>isPresent 用来判断实例是否包含值, 如果不包含非空值返回 false, 否则返回 true<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPresent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>get 方法, 如果实例包含值则返回当前值, 否则抛出 NoSushElementException 异常<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> T <span class="hljs-keyword">get</span>();<br></code></pre></td></tr></table></figure></p><h5 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent()"></a>ifPresent()</h5><p>ifPresent 方法作用是当实例包含值时, 来执行传入的 Consumer, 比如调用一些其他方法<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; consumer)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><p>filter 方法用于过滤不符合条件的值, 接收一个 Predicate 参数, 如果符合条件返回代表值的 Optional 实例, 否则返回 empty</p><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><p>map 方法是链式调用避免空指针的核心方法, 当实例包含值时, 对值执行传入的 Function 逻辑, 并返回一个代表结果值的新的 Optional 实例；也就是将 optional 中的对象转成 其他对象，或者修改对象中的属性。</p><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h5><p>flatMap方法是将 optional 中的对象转成 optional 对象，或者修改对象中的属性；与map方法类似。<br>不同之处在于，前者返回的数据，后者返回的数据需要封装在Stream中。</p><h5 id="orElse"><a href="#orElse" class="headerlink" title="orElse()"></a>orElse()</h5><p>orElse方法是如果实例包含值, 那么返回这个值, 否则返回指定的默认值, 如null<br><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElse</span><span class="hljs-params">(T other)</span></span>;<br></code></pre></td></tr></table></figure></p><h5 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet()"></a>orElseGet()</h5><p>orElseGet方法是如果实例包含值, 返回这个值；否则，它会执行作为参数传入的 Supplier(供应者) 函数式接口，并将返回其执行结果。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function">T <span class="hljs-title">orElseGet</span><span class="hljs-params">(Supplier&lt;? <span class="hljs-keyword">extends</span> T&gt; other)</span></span>;<br></code></pre></td></tr></table></figure></p><p>orElse与orElseGet不同之处：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public void given<span class="hljs-constructor">PresentValue_whenCompare_thenOk()</span> &#123;<br>    User user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">User(<span class="hljs-string">&quot;john@gmail.com&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>)</span>;<br>    logger.info(<span class="hljs-string">&quot;Using orElse&quot;</span>);<br>    User result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">user</span>)</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">Else(<span class="hljs-params">createNewUser</span>()</span>);<br>    logger.info(<span class="hljs-string">&quot;Using orElseGet&quot;</span>);<br>    User result2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">user</span>)</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">ElseGet(()</span> -&gt; create<span class="hljs-constructor">NewUser()</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow()"></a>orElseThrow()</h5><p>如果实例不包含值, 调用传入的 Supplier 参数, 生成一个异常实例并抛出.这个方法通常与全局异常处理器一起使用, 当参数或者其他情况获取不到值时, 抛出自定义异常, 由异常处理器处理成通用返回结果, 返回给前端。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">tempList</span>)</span><br>        .<span class="hljs-keyword">or</span><span class="hljs-constructor">ElseThrow(()</span> -&gt; runtimeException)<br>        .<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">t</span> -&gt; System.<span class="hljs-params">out</span>.<span class="hljs-params">println</span>(<span class="hljs-string">&quot;2:&quot;</span> + <span class="hljs-params">t</span>)</span>);<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java Stream管道数据处理操作</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>全局ID</title>
    <link href="http://example.com/2023/06/01/%E5%85%A8%E5%B1%80id/"/>
    <id>http://example.com/2023/06/01/%E5%85%A8%E5%B1%80id/</id>
    <published>2023-06-01T09:02:25.000Z</published>
    <updated>2023-06-06T03:59:10.919Z</updated>
    
    <content type="html"><![CDATA[<p>要求</p><ol><li>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li><li>在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li><li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li><li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li></ol><h2 id="常见方法介绍"><a href="#常见方法介绍" class="headerlink" title="常见方法介绍"></a>常见方法介绍</h2><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符。</p><p>优点：</p><ul><li>性能非常高：本地生成，没有网络消耗。</li><li>比较适合用于生成唯一的名字的标示比如文件的名字。</li></ul><p>缺点：</p><ul><li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li><li>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li><li>ID作为主键时在特定的环境会存在一些问题，36字符长度太长，他的无序性可能会引起数据位置频繁变动，性能受到影响。</li></ul><h2 id="snowflake方案"><a href="#snowflake方案" class="headerlink" title="snowflake方案"></a>snowflake方案</h2><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等。<br><img src="/img/ID/0.png" alt="github"><br><code>41-bit</code>的时间可以表示<code>（1L&lt;&lt;41）/(1000L*3600*24*365)=69</code>年的时间，<code>10-bit</code>机器可以分别表示<code>1024</code>台机器。</p><p>优点：</p><ul><li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li><li>可以根据自身业务特性分配bit位，非常灵活。</li></ul><p>缺点：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h2 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h2><p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">begin</span>;<br>REPLACE <span class="hljs-keyword">INTO</span> Tickets64 (stub) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">SELECT</span> LAST_INSERT_ID();<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure></p><p>优点：</p><ul><li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li><li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li></ul><p>缺点：</p><ul><li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li><li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li></ul><p>对于MySQL性能问题，每台机器设置不同的初始值，且步长和机器数相等。这种架构貌似能够满足性能的需求，但有以下几个缺点：</p><ul><li>系统水平扩展比较困难</li><li>ID没有了单调递增的特性，只能趋势递增</li><li>数据库压力还是很大</li></ul><h2 id="Leaf方案实现"><a href="#Leaf方案实现" class="headerlink" title="Leaf方案实现"></a>Leaf方案实现</h2><h4 id="Leaf-segment数据库方案"><a href="#Leaf-segment数据库方案" class="headerlink" title="Leaf-segment数据库方案"></a>Leaf-segment数据库方案</h4><p>在使用数据库的方案上，做了如下改变：</p><ul><li>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</li><li>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</li></ul><figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">+-------------+--------------+------+-----+-------------------+-----------------------------+<br>|<span class="hljs-string"> Field       </span>|<span class="hljs-string"> Type         </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default           </span>|<span class="hljs-string"> Extra                       </span>|<br>+-------------+--------------+------+-----+-------------------+-----------------------------+<br>|<span class="hljs-string"> biz_tag     </span>|<span class="hljs-string"> varchar(128) </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string">                   </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> max_id      </span>|<span class="hljs-string"> bigint(20)   </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> 1                 </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> step        </span>|<span class="hljs-string"> int(11)      </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL              </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> desc        </span>|<span class="hljs-string"> varchar(256) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL              </span>|<span class="hljs-string">                             </span>|<br>|<span class="hljs-string"> update_time </span>|<span class="hljs-string"> timestamp    </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> CURRENT_TIMESTAMP </span>|<span class="hljs-string"> on update CURRENT_TIMESTAMP </span>|<br>+-------------+--------------+------+-----+-------------------+-----------------------------+<br></code></pre></td></tr></table></figure><p>重要字段说明：biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1/step。</p><p>test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Begin</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">SET</span> max_id=max_id+step <span class="hljs-keyword">WHERE</span> biz_tag=xxx<br><span class="hljs-keyword">SELECT</span> tag, max_id, step <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> biz_tag=xxx<br><span class="hljs-keyword">Commit</span><br></code></pre></td></tr></table></figure></p><p>优点：</p><ul><li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li><li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li></ul><p>缺点：</p><ul><li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li><li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li><li>DB宕机会造成整个系统不可用。</li></ul><h4 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h4><p>对于第二个缺点，Leaf-segment做了一些优化，简单的说就是：<br>Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p><p>为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的TP999指标。</p><p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p><h4 id="Leaf-snowflake方案"><a href="#Leaf-snowflake方案" class="headerlink" title="Leaf-snowflake方案"></a>Leaf-snowflake方案</h4><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。面对这一问题，提供了 Leaf-snowflake方案。</p><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p><ol><li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li><li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li><li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li></ol><h4 id="弱依赖ZooKeeper"><a href="#弱依赖ZooKeeper" class="headerlink" title="弱依赖ZooKeeper"></a>弱依赖ZooKeeper</h4><p>除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。一定程度上提高了SLA。</p><h4 id="时钟问题"><a href="#时钟问题" class="headerlink" title="时钟问题"></a>时钟问题</h4><p>因为这种方案依赖时间，如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号，需要解决时钟回退的问题。<br><img src="/img/ID/1.png" alt="github"><br>服务启动时首先检查自己是否写过ZooKeeper leaf_forever节点：</p><ol><li>若写过，则用自身系统时间与<code>leaf_forever/$&#123;self&#125;</code>节点记录时间做比较，若小于<code>leaf_forever/$&#123;self&#125;</code>时间则认为机器时间发生了大步长回拨，服务启动失败并报警。</li><li>若未写过，证明是新服务节点，直接创建持久节点<code>leaf_forever/$&#123;self&#125;</code>并写入自身系统时间，接下来综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点(所有运行中的Leaf-snowflake节点)的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)/nodeSize。</li><li>若abs( 系统时间-sum(time)/nodeSize ) &lt; 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点<code>leaf_temporary/$&#123;self&#125;</code> 维持租约。</li><li>否则认为本机系统时间发生大步长偏移，启动失败并报警。</li><li>每隔一段时间(3s)上报自身系统时间写入<code>leaf_forever/$&#123;self&#125;</code>。</li></ol><p>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警。</p><h4 id="利用-redis-生成-id"><a href="#利用-redis-生成-id" class="headerlink" title="利用 redis 生成 id"></a>利用 redis 生成 id</h4><p>性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更 加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>]]></content>
    
    
    <summary type="html">全局ID</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM-工具</title>
    <link href="http://example.com/2023/05/23/JVM%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2023/05/23/JVM%E5%B7%A5%E5%85%B7/</id>
    <published>2023-05-23T08:02:25.000Z</published>
    <updated>2023-05-23T14:06:46.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps（Java Virtual Machine Process Status Tool）是JDK提供的一个可以列出正在运行的Java虚拟机的进程信息的命令行工具，它可以显示Java虚拟机进程的执行主类（Main Class，main()函数所在的类）名称、本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）等信息。另外，jps命令只能显示它有访问权限的Java进程的信息。<br>命令参数说明：</p><blockquote><p>-q：不显示主类名称、JAR文件名和传递给主方法的参数，只显示本地虚拟机唯一ID。<br>-mlvV：我们可以指定这些参数的任意组合。<br>-m：显示Java虚拟机启动时传递给main()方法的参数。<br>-l：显示主类的完整包名，如果进程执行的是JAR文件，也会显示JAR文件的完整路径。<br>-v：显示Java虚拟机启动时传递的JVM参数。<br>-V：不显示主类名称、JAR文件名和传递给主方法的参数，只显示本地虚拟机唯一ID。<br>hostid：指定的远程主机，可以是ip地址和域名, 也可以指定具体协议，端口。如果不指定，则显示本机的Java虚拟机的进程信息。<br>-help：显示jps命令的帮助信息。</p></blockquote><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat 是JDK中提供的一个命令行工具，主要用来打印JVM 性能数据相关的统计数据。主要包含以下几个方面：<br>垃圾回收(GC)方面数据<br>编译(Compilation)相关数据<br>类加载信息(Class Loader)</p><p>jstat 使用很简单，只要在命令行中执行如下命令：<br> jstat -gc -t 11256 10000 10<br>参数解释：</p><blockquote><p>-gc :打印相关的统计参数<br>-t:  在每行日志之前加上JVM的启动时间<br>11256 : 目标Java进程的ID<br>10000: jstat命令执行间隔时间(milliseconds)，10000表示每10s打印一行日志<br>10: jstat命令的执行次数，(和上面的时间间隔一起，表示jstat会每10s执行1次，总共执行10次).</p></blockquote><p>参数意义：</p><ul><li>time :  JVM启动时间(单位为秒)</li><li>S0C ：年轻代中S0区的容量 （字节）</li><li>S1C ：年轻代中S1区的容量 (字节)</li><li>S0U ：年轻代中S0区目前已使用空间 (字节)</li><li>S1U ：年轻代中S1区目前已使用空间 (字节)</li><li>EC ：年轻代中Eden区的容量 (字节)</li><li>EU ：年轻代中Eden区目前已使用空间 (字节)</li><li>OC ：老年代的容量 (字节)</li><li>OU ：老年代目前已使用空间 (字节)</li><li>YGC ：从应用程序启动到采样时年轻代中GC次数</li><li>YGCT ：从应用程序启动到采样时年轻代中GC所用时间(s)</li><li>FGC ：从应用程序启动到采样时老年代(全GC)GC次数</li><li>FGCT ：从应用程序启动到采样时老年代(全GC)GC所用时间(s)</li><li>GCT：从应用程序启动到采样时GC用的总时间(s)</li></ul><p><a href="https://img-blog.csdnimg.cn/aaa166818181449da9f695d45f8c5ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16">https://img-blog.csdnimg.cn/aaa166818181449da9f695d45f8c5ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16</a></p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>jmap是JDK自带的监控工具，在JDK的根目录中可以找到。主要用来查看Java进程对内存的使用情况<br>1、查看类列表，包含实例数、占用内存大小<br><code>jmap -histo[:live] pid</code><br>2、查看动态链接库的列表<br><code>jmap pid</code><br>3、查看Java堆的概要信息<br><code>jmap -heap pid</code><br>4、生成Java虚拟机的堆转储快照 dump文件<br><code>jmap -dump:[live,] format=b,file=./heap.hprof pid</code></p><blockquote><p>live参数是可选的，如果指定，则只转储堆中的活动对象；如果没有指定，则转储堆中的所有对象。<br>format=b表示以hprof二进制格式转储Java堆的内存。<br>file=用于指定快照dump文件的文件名。</p></blockquote><p>注意，如果是k8s中自启动的java项目的pid可能为1，导致无法找到这个默认进程。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>主要是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言。<br>使用jmap等方法生成java的堆文件后，使用其进行分析。</p><h2 id="第一步：导出堆"><a href="#第一步：导出堆" class="headerlink" title="第一步：导出堆"></a>第一步：导出堆</h2><p><code>jmap -dump:live,file=a.log pid</code><br>除了jmap还有以下方法获取</p><ol><li>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）、</li><li>虚拟机启动时如果指定了 -XX:+HeapDumpOnOutOfMemoryError 选项, 则在抛出 OutOfMemoryError 时, 会自动执行堆转储。</li><li>使用 hprof 命令</li></ol><h2 id="第二步：分析堆文件"><a href="#第二步：分析堆文件" class="headerlink" title="第二步：分析堆文件"></a>第二步：分析堆文件</h2><p><code>jhat -J-Xmx512M a1.log</code><br>说明：有时dump出来的堆很大，在启动时会报堆空间不足的错误，可加参数：jhat -J-Xmx512m 。这个内存大小可根据自己电脑进行设置。<br>解析Java堆转储文件,并启动一个 web server</p><h2 id="第三步：查看html"><a href="#第三步：查看html" class="headerlink" title="第三步：查看html"></a>第三步：查看html</h2><p><code>http://ip:7000/</code></p><p>对于jhat启动后显示的html页面中功能：</p><ul><li>（1）显示出堆中所包含的所有的类</li><li>（2）从根集能引用到的对象</li><li>（3）显示平台包括的所有类的实例数量</li><li>（4）堆实例的分布表</li><li>（5）执行对象查询语句</li></ul><p>当需要进行语句查询是：<br>输入内容如：<br><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#查询长度大于100的字符串</span><br><span class="hljs-keyword">select</span> s <span class="hljs-keyword">from</span> java.lang.String s <span class="hljs-keyword">where</span> s.<span class="hljs-keyword">count</span> &gt; <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照。<br>jstack 命令格式如下<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">jstack <span class="hljs-selector-attr">[ option ]</span> pid <br>jstack <span class="hljs-selector-attr">[ option ]</span> executable core <br>jstack <span class="hljs-selector-attr">[ option ]</span> <span class="hljs-selector-attr">[server-id@]</span>remote-hostname-or-IP <br></code></pre></td></tr></table></figure></p><p>option<br>选项    作用</p><ul><li>-F    当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-m    如果调用到本地方法的话，可以显示C/C++的堆栈</li><li>-l    除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</li></ul><p>Java语言定义了6种线程池状态：</p><ul><li>New：创建后尚未启动的线程处于这种状态，不会出现在Dump中。</li><li>RUNNABLE：包括Running和Ready。线程开启start（）方法，会进入该状态，在虚拟机内执行的。</li><li>Waiting：无限的等待另一个线程的特定操作。</li><li>Timed Waiting：有时限的等待另一个线程的特定操作。</li><li>阻塞（Blocked）：在程序等待进入同步区域的时候，线程将进入这种状态，在等待监视器锁。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul><p>Dump文件的线程状态一般其实就以下3种：</p><ul><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li></ul><p>Dump 文件分析关注重点</p><ul><li>runnable，线程处于执行中</li><li>deadlock，死锁（重点关注）</li><li>blocked，线程被阻塞 （重点关注）</li><li>Parked，停止</li><li>locked，对象加锁</li><li>waiting，线程正在等待</li><li>waiting to lock 等待上锁</li><li>Object.wait()，对象等待中</li><li>waiting for monitor entry 等待获取监视器（重点关注）</li><li>Waiting on condition，等待资源（重点关注），最常见的情况是线程在等待网络的读写</li></ul><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo命令用于打印指定Java进程或核心文件或远程调试服务器的Java配置信息。这些配置信息包括Java系统属性和Java虚拟机(JVM)命令行标志。<br>如果指定的进程运行在64位JVM上，则需要用：jinfo -J-d64 -sysprops pid命令。<br>jinfo命令可能会在之后的版本中删除。<br>语法<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jinfo </span>[ option ] pid 连接到正在运行的进程<br><span class="hljs-keyword">jinfo </span>[ option ] executable core 连接到核心文件<br><span class="hljs-keyword">jinfo </span>[ option ] [ servier-id ] remote-hostname-<span class="hljs-keyword">or-IP </span>要连接到远程<span class="hljs-built_in">DEBUG</span>服务器<br></code></pre></td></tr></table></figure></p><ul><li>executable：生成core dump的Java可执行文件</li><li>core：要打印内存映射的核心文件</li><li>server-id：服务器的ID。如果多个DEBUG服务器在同一个远程主机上运行，则各个服务器的ID必须唯一</li><li>remote-hostname：远程DEBUG服务器的主机名</li><li>IP：远程DEBUG服务器的IP</li></ul><p>参数说明</p><ul><li>no-option<br>打印命令行标志和系统属性的【name-value】对。</li><li>-flag name<br>打印指定命令行标志的【name-value】对。</li><li>-flag [+|-]name<br>启用或禁用指定的命令行标志。<br>表示启用，- 表示禁用。</li><li>-flag name=value<br>将指定的命令行标志设置为指定的值。<br>注意：不是所有的flag都可以通过命令行改变！！！</li><li>-flags<br>打印传递给JVM的命令行标志。</li><li>-sysprops<br>以【name-value】对的形式打印Java系统属性。</li><li>-h or -help<br>打印jinfo命令的帮助信息。</li></ul><h2 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h2><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对正在运行的环境进行查看。</p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>jdk自带全能工具，可以分析内存快照、线程快照;监控内存变化、GC变化等。<br><code>jvisualvm --openpid 44620</code></p><p>安装插件<br>在这里找到对应jdk版本号的地址<a href="https://visualvm.github.io/pluginscenters.html，复制到插件中心里面即可。">https://visualvm.github.io/pluginscenters.html，复制到插件中心里面即可。</a></p><h2 id="Memory-Analyzer-Tool"><a href="#Memory-Analyzer-Tool" class="headerlink" title="Memory Analyzer Tool"></a>Memory Analyzer Tool</h2><p>一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br>下载地址 <a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a><br>这里需要找对版本号。</p><h2 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h2><p>一款专业分析gc日志的工具<br>需要自己编译运行<br>git 地址<br><code>https://github.com/jewes/gchisto</code></p>]]></content>
    
    
    <summary type="html">JVM-工具</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>相机学习2-我的富士学习</title>
    <link href="http://example.com/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/"/>
    <id>http://example.com/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/</id>
    <published>2023-04-24T18:02:25.000Z</published>
    <updated>2023-04-26T14:02:32.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="曝光模式"><a href="#曝光模式" class="headerlink" title="曝光模式"></a>曝光模式</h1><h2 id="程序自动曝光P"><a href="#程序自动曝光P" class="headerlink" title="程序自动曝光P"></a>程序自动曝光P</h2><p>若要使快门速度和光圈均由照相机调整已获得理想曝光，请将快门速度和光圈设置为A。<br>若拍照对象位于照相机测光范围之外，快门速度和光圈将显示<code>---</code>。</p><p>如有需要，可旋转前指令拨盘选择快门和光圈的其他组合而不更改曝光。<br>程序切换在以下情况中不可用</p><ul><li>安装的闪光灯支持TTL自动</li><li>动态范围选择了自动</li><li>感光度拨盘旋转至A</li></ul><h2 id="快门优先AE-S"><a href="#快门优先AE-S" class="headerlink" title="快门优先AE S"></a>快门优先AE S</h2><p>将光圈设为A并使用快门速度拨盘，可手动调整快门速度而有照片相机选择光圈获得的理想曝光。</p><p>在180X以外的设定下，也可以通过旋转前指令拨盘以1/3EV为步长调整快门速度。即使在板块们按钮期间也可调整快门速度。</p><p>若无法在所选快门速度下达到正确的曝光，半按快门按钮时光圈将显示红色。<br>若拍摄对象位于测光范围之外，光圈将显示为<code>---</code>。</p><h2 id="光圈优先AE-A"><a href="#光圈优先AE-A" class="headerlink" title="光圈优先AE A"></a>光圈优先AE A</h2><p>将快门速度旋转至A并根据需要调整光圈，可手动调整光圈至由相机选择快门速度已获得理想曝光。</p><p>即使在半按快门按钮期间也可以调整光圈。</p><p>若无法在光圈下达到正常曝光，将显示红色。<br>若拍摄对象位于相机测光范围之外，快门速度将显示<code>---</code>。</p><p>手动曝光 M<br>-<br>将快门速度和光圈均设为A以外的值可改变照相机建议的曝光值。屏幕将显示M。</p><p>在180X以外的的设定下，也可以通过选择前指令拨盘以1/3EV为步长调整快门速度。<br>手动曝光显示包含曝光指示，当前设定下照片将会曝光不足或曝光过度的量通过最左侧的曝光指示提示。</p><h1 id="DRIVE拨盘"><a href="#DRIVE拨盘" class="headerlink" title="DRIVE拨盘"></a>DRIVE拨盘</h1><p>BKT：包围，在一些列照片中自动更改设定<br>CH：高速连拍<br>CL：低速连拍<br>S：单幅画面<br>多重曝光：创建由两次曝光组合的照片<br>创意滤镜：拍摄带滤镜效果的照片<br>全景：按照屏幕指南创建全景照片</p><h1 id="色彩相关"><a href="#色彩相关" class="headerlink" title="色彩相关"></a>色彩相关</h1><p><code>XT-1</code>只有<code>色彩</code>功能。</p><ol><li>色彩的加减即是整体饱和度的加减，影响全局饱和度</li><li>色彩的加减不会影响色相</li></ol><h1 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h1><p>一共三个档次，每一次提升都需要提升一档ISO。</p><ol><li>提高ISO会下降很小的画质，但是可以显著降低高光区域的曝光</li><li>不影响阴影区域的曝光</li><li>主要用于恢复高光细节</li></ol><h1 id="高光色调"><a href="#高光色调" class="headerlink" title="高光色调"></a>高光色调</h1><ol><li>高光加就是增强高光</li><li>高光减则是减轻高光</li></ol><h1 id="阴影色调"><a href="#阴影色调" class="headerlink" title="阴影色调"></a>阴影色调</h1><ol><li>加阴影则是增强阴影</li><li>减阴影则是减弱阴影</li></ol><h1 id="锐度"><a href="#锐度" class="headerlink" title="锐度"></a>锐度</h1><p>让整体画面更加锐利。</p><ol><li>人物一般降低锐度</li><li>静物一般增加锐度</li></ol><h1 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h1><p>一般情况是在ISO125开始工作，显著改善ISO下的噪点。</p><h1 id="长时间曝光降噪"><a href="#长时间曝光降噪" class="headerlink" title="长时间曝光降噪"></a>长时间曝光降噪</h1><p>一般指快门8s后开始工作，星空下效果很好。</p><h1 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h1><p>色温的高低会让画面呈现的冷暖不同。</p><h1 id="胶片模拟的底层逻辑"><a href="#胶片模拟的底层逻辑" class="headerlink" title="胶片模拟的底层逻辑"></a>胶片模拟的底层逻辑</h1><p>风格差异：</p><ol><li>色相/饱和度/亮度；高光与阴影的偏色</li><li>高光/阴影； 照片的反差与对比度</li></ol><p>最终成像：<br>同一种胶片模拟通过机内设置可产生完全不同的风格<br>白平衡与偏移的影响最为显著。</p><ul><li>PROVIA/标准：基础拍摄</li><li>Velvia/鲜艳：色彩饱和、对比度高，用于自然风景</li><li>ASTIA/柔和：增加用于肖像颜色范围，同时保留天空蓝色，适合户外肖像</li><li>PRO Neg.Hi：提供的对比度在n.s.下提供的稍多，在户外进行肖像拍摄时推荐</li><li>PRO Neg.Std：色调柔和，增加用于肤色的色相范围，适合摄影棚肖像</li><li>黑白：标准黑白</li><li>黑白+黄滤镜：对比度稍强，并稍微降低天空的亮度</li><li>黑白+红滤镜：对比度增强，大幅降低天空的亮度</li><li>黑白+绿滤镜：柔化黑白肖像的肤色</li><li>棕褐色：棕褐色照片</li></ul><h1 id="一些使用参数"><a href="#一些使用参数" class="headerlink" title="一些使用参数"></a>一些使用参数</h1><h2 id="晴天"><a href="#晴天" class="headerlink" title="晴天"></a>晴天</h2><ol><li>胶片 c.n.</li><li>色温5200K</li><li>色调H-2，S-2</li><li>动态范围 400</li><li>色彩+3 锐度+4</li></ol><h2 id="温柔黄昏胶片滤镜"><a href="#温柔黄昏胶片滤镜" class="headerlink" title="温柔黄昏胶片滤镜"></a>温柔黄昏胶片滤镜</h2><ol><li>胶片c.c.</li><li>色彩+4</li><li>锐度0</li><li>高ISO降噪-4</li><li>色温6050K red3，blue0</li><li>ISO最高6400</li><li>动态范围自动</li><li>曝光补偿0-2/3</li><li>色调 H+1，S-2</li></ol><h2 id="日系清新胶片滤镜"><a href="#日系清新胶片滤镜" class="headerlink" title="日系清新胶片滤镜"></a>日系清新胶片滤镜</h2><ol><li>胶片n.c.</li><li>色彩+2</li><li>锐度+2</li><li>高ISO降噪 关</li><li>白平衡 日光，red-2，blue-2</li><li>ISO最高6400</li><li>动态范围自动</li><li>曝光补偿+2/3</li><li>色调 H-0.5，S-0.5</li></ol><h2 id="夜色复古胶片滤镜"><a href="#夜色复古胶片滤镜" class="headerlink" title="夜色复古胶片滤镜"></a>夜色复古胶片滤镜</h2><ol><li>胶片c.c.</li><li>色彩+2</li><li>白平衡 阴天 red-2，blue-2</li><li>动态范围 100</li><li>色调H-1，S+2</li><li>降噪-1</li></ol><h2 id="电影扫街胶片滤镜"><a href="#电影扫街胶片滤镜" class="headerlink" title="电影扫街胶片滤镜"></a>电影扫街胶片滤镜</h2><p>胶片c.c.<br>白平衡 5500K<br>锐度+3<br>动态范围400<br>色调 H+2，S+2<br>降噪-2</p><h2 id="静谧氛围胶片滤镜"><a href="#静谧氛围胶片滤镜" class="headerlink" title="静谧氛围胶片滤镜"></a>静谧氛围胶片滤镜</h2><p>胶片c.c.<br>色彩 +1<br>锐度 +1<br>白平衡 日光 red+2，blue-3<br>ISO最高6400<br>动态范围400<br>色调H-1，S+2<br>降噪-2</p>]]></content>
    
    
    <summary type="html">相机</summary>
    
    
    
    <category term="相机" scheme="http://example.com/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>相机学习1-基础部分</title>
    <link href="http://example.com/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/"/>
    <id>http://example.com/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/</id>
    <published>2023-04-09T08:59:25.000Z</published>
    <updated>2023-04-25T06:06:52.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h1><p>光圈越大，亮度越高。<br>光圈数值和大小相反，数值越小，光圈越大。</p><h1 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h1><p>快门越快，亮度越小。<br>一般使用分数来表示，数值越大，快门越小。</p><h1 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h1><p>ISO相当于在cmos上加上一个亮片，ISO越高，亮度越高，但是照片质量会降低，增加颗粒感，因为它是靠电子信号来发光。<br>iso并非越低越好，而是越接近原生iso越好，比如有的相机原生iso在400那么这时iso100的画质不如iso400，再比如有的iso可以低至50，而尼康D850的iso可以低至64，但由于iso50是拓展的iso画质是不如D850的iso64的。</p><h1 id="景深和虚化"><a href="#景深和虚化" class="headerlink" title="景深和虚化"></a>景深和虚化</h1><p>光圈的大小不仅仅会影响亮度，还会影响景深和虚化。</p><h1 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h1><p>大光圈导致浅景深，小光圈导致深景深。</p><h1 id="虚化"><a href="#虚化" class="headerlink" title="虚化"></a>虚化</h1><p>大光圈导致虚化强，小光圈导致虚化弱。</p><h1 id="动态模糊"><a href="#动态模糊" class="headerlink" title="动态模糊"></a>动态模糊</h1><p>快门的快慢不仅仅会影响亮度，还会影响动态模糊。<br>在亮度不够使，自动快门会导致快门时间过长，导致手抖可能发生照片模糊，测试需要将快门变慢，如果要保持自动，则需要设置其他的功能提高亮度。<br>但是慢快门可以让照片好看，即慢速快门。慢速快门拍摄技巧，可用于拍摄光绘，星轨，车流，火花可使用三脚架保持相机稳定，防止糊掉。</p><p>大太阳下，如何既有虚化（大光圈，浅景深，模糊背景），又有动态模糊（慢快门，让光在CMOS上运动）？<br>既有虚化，又有运动模糊，可以拍摄出一种运动感、速度感。引入  ND滤镜    （控光工具，可理解为相机用墨镜🕶可以降低画面亮度，有可变和固定参数两种。）</p><h1 id="相机档位"><a href="#相机档位" class="headerlink" title="相机档位"></a>相机档位</h1><p>Aperture 光圈<br>Shutter 快门<br>Program 程序（辅助）<br>Manual 全手动</p><div class="table-container"><table><thead><tr><th>档位</th><th>光圈</th><th>快门</th><th>ISO</th></tr></thead><tbody><tr><td>A</td><td>你</td><td>相机</td><td>你</td></tr><tr><td>S</td><td>相机</td><td>你</td><td>你</td></tr><tr><td>P</td><td>相机</td><td>相机</td><td>你</td></tr><tr><td>M</td><td>你</td><td>你</td><td>你</td></tr></tbody></table></div><h1 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h1><p>若IOS为手动挡</p><div class="table-container"><table><thead><tr><th>档位</th><th>光圈</th><th>快门</th><th>ISO</th></tr></thead><tbody><tr><td>A</td><td>你</td><td>曝光补偿</td><td>你</td></tr><tr><td>S</td><td>曝光补偿</td><td>你</td><td>你</td></tr><tr><td>P</td><td>曝光补偿</td><td>曝光补偿</td><td>你</td></tr><tr><td>M</td><td>你</td><td>你</td><td>你</td></tr></tbody></table></div><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>亮度说明图<br>左侧为偏暗<br>右侧为偏暗<br>中间表示明暗过渡的部分</p><h1 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h1><h1 id="除杂物"><a href="#除杂物" class="headerlink" title="除杂物"></a>除杂物</h1><p>保持画面干净整洁</p><ol><li>手动清除杂物</li><li>调整取景角度</li><li>大光圈虚化，或者放大画面规避</li></ol><h1 id="视角独特"><a href="#视角独特" class="headerlink" title="视角独特"></a>视角独特</h1><ol><li>低角度往上拍，突显高贵</li><li>高角度往下拍，娇小可爱，邻家感觉</li><li>远拍，距离感</li><li>近拍，感觉亲和</li><li>广角拍摄，纳入更多环境元素</li><li>特写拍摄:代入感强</li></ol><p>空间拍摄技巧，让画面更具纵深感和层次感<br>在空间上找可以延伸的最远方向<br>利用引导线<br>多个平面堆叠<br>添置前景遮挡</p><h1 id="突出主题（影明暗，色彩强弱，空间虚实）"><a href="#突出主题（影明暗，色彩强弱，空间虚实）" class="headerlink" title="突出主题（影明暗，色彩强弱，空间虚实）"></a>突出主题（影明暗，色彩强弱，空间虚实）</h1><ol><li>光影明暗</li><li>色彩强弱</li><li>空间虚实</li><li>明显的引导线</li></ol><h1 id="平衡主体"><a href="#平衡主体" class="headerlink" title="平衡主体"></a>平衡主体</h1><p>平衡画面重心，不要过于强调画面主体<br>画面元素，明暗占比会影响画面重心。色彩艳丽占比。<br>保证脸部光线要均匀。</p><h1 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h1><p>没有经过压缩的原始文件</p><h1 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h1><p>黑白颜色标准，推算别的颜色，白平衡则是告诉相机那一个是白色。<br>具备功能都会指明场景，晴天、雨天、灯下等。</p><h1 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h1><p>全局测光<br>中央测光<br>点测光</p><h1 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h1><p>光圈变小，将对焦范围变大<br>手动扭动对焦环，设置对焦距离</p><p>单次自动对焦:AF-S<br>连续自动对焦:AF-C（拍摄运动物体）<br>手动对焦:mf（手拧对焦环对焦）<br>自动手动混合:DMF（在相机自动对焦后，仍可以手拧对焦环微调）</p>]]></content>
    
    
    <summary type="html">相机</summary>
    
    
    
    <category term="相机" scheme="http://example.com/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NginxProxyManager增加ssl</title>
    <link href="http://example.com/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/"/>
    <id>http://example.com/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-30T09:01:12.209Z</updated>
    
    <content type="html"><![CDATA[<p>NginxProxyManager增加custom ssl<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">openssl genrsa -out root.key <span class="hljs-number">1024</span><br><br>openssl req -<span class="hljs-keyword">new</span> -out root.csr -key root.key<br><br>openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days <span class="hljs-number">3650</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">NginxProxyManager增加ssl</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JVM—SafePoint</title>
    <link href="http://example.com/2023/03/15/JVM_SafePoint/"/>
    <id>http://example.com/2023/03/15/JVM_SafePoint/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-23T06:18:41.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h2><p>JVM的主要任务是执行Java程序，而JVM运行时本身也是一个程序，但是为了执行Java程序JVM还有不少辅助工作，比如进行GC、JIT编译等等。一般会把运行在JVM上的用户Java程序称为<code>mutator</code>。</p><p>在GC中，JVM中一般的GC都使用可达性分析，也就是从应用程序的一些GC Root(比如运行中的线程栈里的方法栈帧中本地变量表、操作数表中的引用、静态变量引用等)开始通过引用进行引用图遍历，如果在JVM遍历的过程中mutator也在运行，则mutator则可能会修改这个对象图的引用关系，如果JVM不对这种并发修改进行特殊处理，可能导致一些非可回收对象没有被遍历到，从而被标记成垃圾对象而被错误的回收。<br>如果要完全并发GC，JVM的实现成本会比较大，并且很多情况下整体的吞吐量是会降低的。<br>因此在很多GC收集器中都会有一些StopTheWorld阶段，这个StopTheWorld就是safepoint。在safepoint中不会有mutator操作对象，并且线程栈和heap中每个位置的数据类型也是确定的。</p><p>一个线程要么在safepoint中，要么不在safepoint中。上面提到的StopTheWorld指的是全局safepoint，也就是要求所有线程都处于safepoint状态。后面如果没有特别说明safepoint也指的是全局safepoint。</p><h2 id="SafePoint-如何实现的"><a href="#SafePoint-如何实现的" class="headerlink" title="SafePoint 如何实现的"></a>SafePoint 如何实现的</h2><p>可以这么理解，SafePoint 可以插入到代码的某些位置，每个线程运行到 SafePoint 代码时，主动去检查是否需要进入 SafePoint，这个主动检查的过程，被称为 Polling。<br>在hotspot实现中safepoint是协作式的，当JVM需要mutator进入safepoint时，会设置一个状态标记表示要进入safepoint了，每个mutator线程都会在合适的时机检查这个状态标记，如果发现需要进入safepoint则会暂停自己。</p><p>针对 SafePoint，线程有 5 种情况；假设现在有一个操作触发了某个 VM 线程所有线程需要进入 SafePoint（例如现在需要 GC），如果其他线程现在：</p><ul><li>运行字节码：运行字节码时，解释器会看线程是否被标记为 poll armed，如果是，VM 线程调用 <code>SafepointSynchronize::block(JavaThread *thread)</code>进行 block。</li><li>运行 native 代码：当运行 native 代码时，VM 线程略过这个线程，但是给这个线程设置 poll armed，让它在执行完 native 代码之后，它会检查是否 poll armed，如果还需要停在 SafePoint，则直接 block。</li><li>运行 JIT 编译好的代码：由于运行的是编译好的机器码，直接查看本地 local polling page 是否为脏，如果为脏则需要 block。这个特性是在 Java 10 引入的 JEP 312: Thread-Local Handshakes 之后，才是只用检查本地 local polling page 是否为脏就可以了。</li><li>处于 BLOCK 状态：在需要所有线程需要进入 SafePoint 的操作完成之前，不许离开 BLOCK 状态</li><li>处于线程切换状态或者处于 VM 运行状态：会一直轮询线程状态直到线程处于阻塞状态（线程肯定会变成上面说的那四种状态，变成哪个都会 block 住）。</li></ul><h2 id="如何排查safepoint相关问题"><a href="#如何排查safepoint相关问题" class="headerlink" title="如何排查safepoint相关问题"></a>如何排查safepoint相关问题</h2><p>在JVM启动参数上增加一些参数可以打印出应用暂停和safepoint相关信息。 如果版本&lt;=jdk8<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>如果版本&gt;jdk8<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-Xlog:gc*=info::time,tags,tid -Xlog:safepoint=info::time,tags,tid<br></code></pre></td></tr></table></figure></p><h2 id="深入Safepoint"><a href="#深入Safepoint" class="headerlink" title="深入Safepoint"></a>深入Safepoint</h2><p><img src="/img/Safepoint/0.png" alt="github"><br>可以看到，jvm中的每个子系统都或多或少的与安全点相关。因此在需要学会思考，编写的代码会与安全点有何关系之类的问题。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>java线程：他是jvm中线程概念的一种特殊化，是专门针对执行java代码的线程。线程本地gc根被定义为一个oop，它是指向java线程本地的java堆的指针，这里代表的java堆上对象，是可达性分析树的根。<br>可变线程状态：是一种java线程状态，特指可以改变java堆的线程状态。例如，分配对象或修改设置字段或其线程本地gc根，这种状态有时也被称为不安全状态。<br>安全点：他是一个全局JVM状态，这里的直观概念是在这个点或状态下，java世界停止了。所以他是安全的，因为所有其他应用线程停止了，这样jvm可以独占访问检查和处理。更技术性的定义是没有java线程在内部执行或可以转换到可变线程状态。技术定义的另一部分是所有java线程的线程本地gc根都可以访问或发布到JVM。<br>Safepointing作为动词，也称为stop the world，是jvm到达一个安全点的过程或者机制。并且有一个更古老的直观概念，这围绕着暂停或停止所有正在执行的java线程的过程，这对于抽象来说是可以的，但这次我们将了解到这是一种更加精细和进化的机制，它严重依赖于线程之间的协作，使用一种称为协作挂起的技术。<br>合作暂停：是一种基于轮询的技术。这意味着java线程将在VM中的指定位置检查或轮询线程本地状态。在暂停时，JVM会阻止java线程转换为可变线程状态，并且在暂停时，jvm会触发java线程从可变线程状态转换为不可变线程状态。并且由于这种转换，线程本地gc根将被发布。由于这种转换，线程本地gc根将被发布，传统上将系统带到安全点对于提供某种形式的自动内存管理的运行时来说是必要的<strong>邪恶机制</strong>。被称为如此的原因是，这是运行时延迟和不确定性的主要来源之一。<br>安全点就想轮回或苦难一样，我们想摆脱他们以达到涅槃。<br>新的衍生技术，例如线程握手和线程栈水位线，他们使得安全点机制可以更轻量级或更精细化。<br>谁需要安全点，因为某些操作因素，导致必须达到安全点才能完成任务，相反，某些操作必须在非安全点才能完成一样。</p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>java线程有一个叫做线程状态的字段（_thread_state），_thread_state的目的是跟踪java线程正在执行的代码的哪一部分。</p><p>这是java线程的状态转换：<br><img src="/img/Safepoint/2.png" alt="github"></p><ol><li>可变线程状态是一种线程可以改变java堆或其线程本地gc根的状态。</li><li>不可变线程状态是不能做这些事情的状态。</li><li>过渡状态，他们就像可变状态和不可变状态之间的桥梁。</li></ol><p>转换状态具有安全的检查或轮询指令以及适当的防护。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>看看下面的情况：<br>我们有了一个新线程，他开始在VM状态下运行。假设这个线程现在想要执行一些java代码；为了做到这一点，他需要遍历到java状态的转换；正如我们所说的状态转换包含安全点检查；这里的一些值得注意的状态转换时，处于运行java代码的状态可以在不执行安全点检查的情况下转换到状态VM和状态native，而是在线程返回状态java时执行安全点检查。<br>这里的另一个重要说明是，在native状态下执行的代码被认为是安全的，这意味着在安全点期间，java线程实际上可以继续运行native代码，这也意味着与安全点涉及阻塞或停止所有java线程的直观概念相悖。这只意味着她们不会在敏感的可变状态下执行。</p><h2 id="java线程本地gc根（Java-Thread-Local-GC-Roots）"><a href="#java线程本地gc根（Java-Thread-Local-GC-Roots）" class="headerlink" title="java线程本地gc根（Java Thread Local GC Roots）"></a>java线程本地gc根（Java Thread Local GC Roots）</h2><p>在我们将安全点定义为全局jvm状态时，所有java线程的线程本地gc根都可以访问或发不到jvm。当前所有的垃圾收集器都是跟踪型垃圾收集器，这意味着他们从所谓的根集开始跟踪可达性树，这是一组立即可以访问的oops（对象指针），是根集的一个子集，即java线程本地可访问的根集。</p><p>让我们看看这些线程本地gc根是什么</p><h3 id="本地jni句柄"><a href="#本地jni句柄" class="headerlink" title="本地jni句柄"></a>本地jni句柄</h3><p>java线程有一个成为活动句柄（_active_handles）的字段，他是一个本地jni句柄，提供给在本地状态下运行的jni代码对应的oop的间接访问，但是分配解除分配甚至取消引用jni句柄涉及首先执行vm状态，这将会执行安全点检查。本地jni句柄是自动管理的，因此，当代码从jni方法返回时，他会从进行安全点检查的状态native转换为状态java。由该方法分配的本地jni句柄被释放。</p><h3 id="句柄区域"><a href="#句柄区域" class="headerlink" title="句柄区域"></a>句柄区域</h3><p>java线程也有一个叫做句柄区域（_handle_area）的字段，句柄区域及其他伙伴句柄，提供与本地jni句柄几乎相同的间接功能，但是这些是针对在VM状态下运行的代码。<br>重要的区别是这些句柄不是自动管理的，而是必须由程序员手动管理。HandleMark用于描述句柄范围，并且HandleMark析构函数将为该特定范围是否分配的句柄，并且范围也可以嵌套。</p><h3 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h3><p>该线程还有一个内部结构体，并且有一个对应字段叫做锚（_anchor）。他由三个指针组成：</p><ul><li>_last_java_sp 表示最后一个java堆栈指针</li><li>_last_java_pc 表示最后一个java程序计数器</li><li>_last_java_fp 表示最后一个java帧指针</li></ul><p>最后一个java帧是外部遍历线程栈的入口点。我们排出JFR采集的帧。<br>如果线程在其堆栈上至少有一个java激活记录或帧，并且他当前不在状态java中，则设置他。所以处于状态java的线程在转换到其他状态之前，会设置这个锚（last java fram ljf）。<br>相反，他在线程重新进入状态java时被清除。</p><p>这里的anchor结构只需要设置_last_java_sp，因为其他字段要么与该上下文无关，要么可以通过堆栈便利代码推导出来。堆栈上的java帧可能包含普通、压缩的或派生的oops。所以，如果和之前讨论的句柄对比下，这些事裸oops，即他们没有处理引用定向，他们是直接指针。<br>ordinary指的是一般对象普通的oop；压缩oop是oop的压缩版本，他是32位大小；派生的oop是指向对象的指针，不是直接指向其对象头的。例如，我们可以考虑一个指针，他指向数组中的一个元素，派生oop始终与基址相关，对于java中的特定代码位置，对于像是代表特定的代码位置的程序计数器，堆栈槽和寄存器包含相对于该程序计数器的oops，是由编译器生成的一段元数据描述的，是叫做OopMap的一个东西。为了精确定位帧中的oop，OopMap使用栈指针的相对地址或RegisterMap的索引的相对地址来描述位置。<br>并非所有代码代码位置都有OopMap，他们主要与调用点和安全点轮询页面指令相关联。对于堆栈遍历，每帧的返回地址将于一个OopMap相关联。</p><h3 id="java线程-CPU上下文"><a href="#java线程-CPU上下文" class="headerlink" title="java线程 CPU上下文"></a>java线程 CPU上下文</h3><p>执行java代码的线程也有一个cpu上下文，并且根据调用约定和出于性能原因，理想情况下，oops由寄存器分配器直接放入寄存器中。<br>Hotspot广泛使用称为Stubs或StubRoutines的东西，他们是特定于平台的特殊程序集帮助程序。<br>Stub的一个重要特性就是在线程暂停他的工作让出CPU的时候保存CPU上下文，并且在线程回归之行的时候恢复CPU上下文，在某种程度上类似于上下文切换。</p><p>RegisterMap用于将oop映射描述的位置解析为寄存器，还有一些线程本地gc根。</p><p>例如潜在的未决异常和一些与jvmti相关的状态。</p><h1 id="将系统带到安全点的过程"><a href="#将系统带到安全点的过程" class="headerlink" title="将系统带到安全点的过程"></a>将系统带到安全点的过程</h1><h2 id="VMThread-is-the-coordinator"><a href="#VMThread-is-the-coordinator" class="headerlink" title="VMThread is the coordinator"></a>VMThread is the coordinator</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> VMThread::loop() &#123;<br>    ...<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (should_terminate()) <span class="hljs-keyword">break</span>;<br>        wait_for_operation();<br>        <span class="hljs-keyword">if</span> (should_terminate()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">assert</span>(_next_vm_operation != NULL, <span class="hljs-string">&quot;Must have one&quot;</span>);<br>        inner_execute(_next_vm_operation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该过程由从VMThread请求安全点操作的客户端启动，它通过将VM_Operation类型的对象排入队列并将其属性evaluate_at_safepoint()设置为true来实现。<br>VMThread将等待出队并启动安全点过程以服务提交的请求。</p><h2 id="VMThread-SafepointSynchronize-begin"><a href="#VMThread-SafepointSynchronize-begin" class="headerlink" title="VMThread - SafepointSynchronize::begin()"></a>VMThread - SafepointSynchronize::begin()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> SafepointSynchronize::begin() &#123;<br>    <span class="hljs-keyword">assert</span>(Thread::current()-&gt;is_VM_thread(), <span class="hljs-string">&quot;Only VM thread may execute a safepoint&quot;</span>);<br>    <br>    Threads_lock-&gt;lock();<br>    <span class="hljs-keyword">assert</span>(_state == _not_synchronized, <span class="hljs-string">&quot;trying to safepoint synchronize with wrong state&quot;</span>);<br>    <span class="hljs-keyword">int</span> nof_threads = Threads::number_of_threads();<br>    ...<br>    arm_safepoint();<br>    <br>    <span class="hljs-keyword">int</span> iterations = synchronize_threads(safepoint_limit_time, nof_threads, &amp;initial_running);<br>    <span class="hljs-keyword">assert</span>(_waiting_to_block == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;No thread should be running&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是VMThread运行的第一部分。他由三个部分组成：</p><ol><li><strong>组装</strong>java线程</li><li>同步，即等待所有java线程</li><li>当所有线程都被认为是安全的，即已经到达全局jvm安全点状态时，VMThread运行提交的操作</li></ol><p>首先看看组装部分</p><h3 id="VMThread-arm-safepoint"><a href="#VMThread-arm-safepoint" class="headerlink" title="VMThread - arm_safepoint()"></a>VMThread - arm_safepoint()</h3><p>java线程有一个嵌入的结构体。<br>_poll_data字段，由两个指针组成_polling_word和_polling_page。arming本质上意味着VMThread更改了安全点检查中使用的所谓轮询页面的内存保护。并且他从内存保护状态PAGE_READONLY更改为PAGE_NOACCESS。<br>这里VMThread大致完成了封装了java线程的内存页，它有效的删除了线程转换到任何红色不安全可变状态的能力。他切换了从蓝色到红色的所有链接。这意味着，VMThread通过这个进程所做的事情现在状态机制被替换成了一个临时的状态机制。</p><p>然而，这只是合作暂停的一部分。之前说的是，JVM阻止了java线程转变到被归类为可变的线程状态。</p><p>定义的第二部分是JVM触发java线程从可变状态为不可变状态。作为这个转换线程的结果，本地gc根被发布。<br>如何确保那些已经在可变状态下运行的线程变为不可变状态，对于在VM状态下运行的线程，他需要等待，知道线程自己执行转换。在VM状态中只有少数地方显式滴执行安全点检查。例如当争用VM下的互斥锁或监视器时。<br>这种设计的前提是java线程应该在状态VM中话费尽可能少的时间。</p><p>但是在状态Java中运行的现场就不一样了。<br>我们不能像在状态VM中那样，等待状态Java中的线程自行过渡。例如，一个线程可以执行无限循环，这是完全合法的，在这种情况下，JVM永远不会到达安全点。因此，要解决这个问题，需要有一种适当的机制来疏散或推出当前运行java代码的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (n == first) &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">int</span> second = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (scond == n) &#123;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>    <span class="hljs-keyword">int</span> nth = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        nth = getSuccressor(first, second);<br>        first = second;<br>        second = nth;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nth;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuccressor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> second)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码完成斐波那契数列，实现版本迭代。<br>但是在了解到细节时，最好谈谈x64调用约定或应用程序二进制接口，以及Hotspot Java调用约定以及他们之间的关系。<br>windows平台ABI按顺序在寄存器中传递前四个参数，其余的按从右到左（RTL）的顺序在堆栈上传递。还有32个字节的影子栈区域需要由调用者分配。System V ABI定义了参数在这六个寄存器中传递。而其余的也从右到左在堆栈上传递。<br>在栈下面有一个128字节的红色区域，Hotspot java调用约定定义了6个寄存器，用于在windows平台上参数传递，其余的从右到左在堆栈上传递，有一个自定义版本的堆栈保护，这只适用于System V平台。<br>对于所有这些，栈需要在16字节的边界上对齐。如果仔细观察，就会发现Hotspot java调用约定是平台ABI的一个移位或旋转版本，这种移位或旋转是因为通过跳过第一个ABI寄存器，我们可以调用非静态jni方法，而不必打乱参数。<br>相反，我们只将jni结束指针直接放在第一个ABI寄存器中。大多数寄存器都被认为是易失的，即调用方必须在调用过程中保留寄存器。除了RBP寄存器，是被调用的保存，如果存在压缩oops，R12就会保存java堆基址，而R15寄存器保存当前线程。所以这些寄存器可以被认为是常数。</p><p>JIT编译器在常规代码流中插入了安全点检查或轮询指令，他由两个指令组成：<br>第一个是从驻留在r15中的java线程加载轮询页面指针，然后执行一个test，解除轮询页面引用。除了在代码流中插入safepoint检查指令之外，JIT还确保这里的测试指令具有关联的OopMap，但对于这个特定的例子，这个特定的OopMap是空的。原因是，这段代码并没有真正使用任何java对象，因为他是一个静态方法，他没有接受对象，而且他只用了java原始类型。<br><img src="/img/Safepoint/3.png" alt="github"><br>Safepoint检查由编译器插入到循环头中，就像这里这样，以便捕获长时间运行的循环，并且在方法返回之前。</p><p>让我们看一下被调用的方法getSuccessor<br><img src="/img/Safepoint/4.png" alt="github"><br>这里可以看到安全点检查指令有点不同，这是一个cmp，而不是一个test，这是安全点检查的一个更优化版本。这与衍生技术如跨线程握手和线程水位线有关。不幸的事，这个版本不能应用于所有上下文中，后面会知道为什么在不同情况下需要不同的轮询指令。<br>在这段代码中，safepoint检查比较指令没有关联的OopMap，这是为什么？这是因为在方法末尾的safepoint调用指令是在栈帧出栈之后，但在返回指令之前插入的。这意味着调用者的返沪指令位于栈的顶部，通过表示一个调用点，他有一个关联的OopMap。<br>如果我们返回调用方，我们可以看到安全点检查，这是一个test指令，尝试解除对她从r15（java线程位于寄存器r15中）加载的轮询页面的引用。但是如果VMThread封装了轮询页面，即它将内存保护从PAGE_READONLY更改为PAGE_NO_ACCESS。<br>硬件将报非发访问或者segmentation fault，这又会通知操作系统，反过来通知寄存器信号或异常处理程序。Hotspot JVM将向各自的操作系统注册新号处理程序，以获取有关此事件的通知。利用硬件和操作系统提供的信息，我们可以确定发生了什么，所以在这个例子中，这是非法访问或者segmentation fault，并且还提供了有关哪个指令导致他的信息，内存地址。<br>所以在信号处理程序内部，我们可以确定内存地址是安全点轮询页面，所以我们知道这种非法访问或者segmentation fault并不是真正的崩溃，但它与合作暂停有关。<br>我们保存被困在名为saved_exception_pc的java线程字段中的指令，操作系统还为我们提供了处于trap时的状态和cpu上下文，我们可以在信号处理程序中重写cpu上下文，也就是说我们可以修改指令指针（IP），而不是指向捕获他的原始java代码，而是指向特定的StubRoutine。<br>当线程在展开所有异常处理程序后恢复时，操作系统重新加载这个现在修改的cpu上下文，并且线程继续在指定的StubRoutine中运行，而不是在原来的java代码中运行。</p><p>看一下Hotspot StubRoutine的代表性实例<br><img src="/img/Safepoint/5.png" alt="github"><br>这个叫做StubRoutineBlob，代表了汇编代码。</p><ol><li>我们说在循环中间进行曲折进给，这意味着栈上没有正确的返回地址，所以我们要解决这个问题，所以我吗需要为他分配一个槽。</li><li>这里很重要，我们正在栈上建立一个新栈帧，一个与java代码本身没有直接关系的对象，而是一个元对象。并且因为jvm是java语言的元理论的实现，可以看到很多这些元结构与真正的java代码混合在一起，所以让我们称这个对象为合成帧或者Stub帧来表示这种差异。</li><li>rflags寄存器被推入栈</li><li>如果还记得调用约定，说过堆栈需要在16字节边界上对齐</li><li>然后将cpu上下文的通用寄存器溢出到栈上</li><li>此处浮点寄存器也被溢出，如果查看这些Stub帧的大小，会发现她们非常大，例如此帧大小为360个字或近3000个字节，而这样做的原因当然是大部分cpu上下文都溢出了</li><li>如果记得在信号处理程序中，我们保存了错误指令的地址，我们现在将这个地址写入我们一开始分配的栈槽，我们这样做是为了让他成为返回地址，这样做的原因不仅仅是为了以后能够返回到代码中断的地方，更重要的是，test指令有一个关联的OopMap，并且在安全点期间，栈必须具有所有返回地址的OopMaps，而StubRoutines发挥的另一个重要的作用是在java ABI和特定平台ABI之间切换，这也是为什么这些Stub帧是平台特定的原因。</li><li>可以看到，因为我吗即将调用进入JVM，改掉用需要在此处添加到平台ABI的调用，对于这个例子在windows上，首先需要分配一个32字节的栈空间，然后将线程作为rcx中的第一个参数传递</li><li>在我们对安全点定义中，说过所有java线程的线程本地gc根都可以访问或发布到jvm，并且详细说明了_last_java_frame是发布到jvm的重要部分，因为它提供了遍历栈的入口点，其cpu上下文的一部分，直接在寄存器中，因此出现了一个棘手的问题，即如何使线程的cpu上下文可访问或发布到jvm以使其到达安全点，答案是使用Stub帧提供解决方案，通过将cpu上下文溢出到栈中，进入这些Stub帧之一，她看起来就像一个常规帧。cpu上下被塑造成一个栈帧。</li><li>所以确实可以在这里看到_last_java_frame或锚字段将被设置为指向Stub帧而不是真正的java代码帧</li><li>重要的方面也是这些合成Stub帧也有OopMaps，这个特定的OopMap将详细说明每个寄存器在堆栈上的位置，OopMap的值类型表示栈位置，确实属于调用者帧，这里是fibonacci方法，之前提到了一个RegisterMap，其中也会填充那些Stub帧中的位置信息，并与调用者中的OopMap一起，即fibonacci方法的OopMap，表示放在寄存器中的oops可以被解析出</li></ol><h3 id="SafepointSynchronize-block"><a href="#SafepointSynchronize-block" class="headerlink" title="SafepointSynchronize::block()"></a>SafepointSynchronize::block()</h3><p>所以负责将这个特定线程的cpu上下文和堆栈导出到VM。当我们最终进入VM操作的时候，将java线程的线程状态字段设置为阻塞，连同Full Fence完全内存屏障指令，这对于线程本地gc根可见或发不到VM非常重要。线程现在将等待全局信号量，在VM线程运行VM操作之后，她发出信号量以及当线程恢复的时候，他将解除自己的轮询页并从中断的地方继续执行。<br><img src="/img/Safepoint/6.png" alt="github"></p><p>至此，关于Hotspot JVM中的安全点到此结束。<br>Safepoint 可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，线程可以暂停。在 SafePoint 保存了其他位置没有的一些当前线程的运行信息，供其他线程读取。这些信息包括：线程上下文的任何信息，例如对象或者非对象的内部指针等等。我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息，才是确定的，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候，才会感知。</p>]]></content>
    
    
    <summary type="html">JVM—SafePoint</summary>
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码指令大全</title>
    <link href="http://example.com/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-05-11T10:21:38.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0X01</td><td>aconst_null</td><td></td><td>null值入栈</td></tr><tr><td>0X02</td><td>iconst_m1</td><td></td><td>-1(int)值入栈</td></tr><tr><td>0X03</td><td>iconst_0</td><td></td><td>0(int)值入栈</td></tr><tr><td>0X04</td><td>iconst_1</td><td></td><td>1(int)值入栈</td></tr><tr><td>0X05</td><td>iconst_2</td><td></td><td>2(int)值入栈</td></tr><tr><td>0X06</td><td>iconst_3</td><td></td><td>3(int)值入栈</td></tr><tr><td>0X07</td><td>iconst_4</td><td></td><td>4(int)值入栈</td></tr><tr><td>0X08</td><td>iconst_5</td><td></td><td>5(int)值入栈</td></tr><tr><td>0X09</td><td>lconst_0</td><td></td><td>0(long)值入栈</td></tr><tr><td>0X0a</td><td>lconst_1</td><td></td><td>1(long)值入栈</td></tr><tr><td>0X0b</td><td>fconst_0</td><td></td><td>0(float)值入栈</td></tr><tr><td>0X0c</td><td>fconst_1</td><td></td><td>1(float)值入栈</td></tr><tr><td>0X0d</td><td>fconst_2</td><td></td><td>2(float)值入栈</td></tr><tr><td>0X0e</td><td>dconst_0</td><td></td><td>0(double)值入栈</td></tr><tr><td>0X0f</td><td>dconst_1</td><td></td><td>1(double)值入栈</td></tr><tr><td>0X10</td><td>bipush</td><td>valuebyte</td><td>valuebyte值带符号扩展成int值入栈</td></tr><tr><td>0X11</td><td>sipush</td><td>valuebyte1、valuebyte2(valuebyte1 &lt;&lt; 8)</td><td>valuebyte2 值带符号扩展成int值入栈</td></tr><tr><td>0X12</td><td>ldc</td><td>indexbyte1</td><td>常量池中的常量值（int, float, string reference, object reference）入栈</td></tr><tr><td>0X13</td><td>ldc_w</td><td>indexbyte1、indexbyte2</td><td>常量池中常量（int, float, string reference, object reference）入栈</td></tr><tr><td>0X14</td><td>ldc2_w</td><td>indexbyte1、indexbyte2</td><td>常量池中常量（long, double）入栈</td></tr></tbody></table></div><h2 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0X19</td><td>(wide)aload</td><td>indexbyte</td><td>从局部变量indexbyte中装载引用类型值入栈</td></tr><tr><td>0X2a</td><td>aload_0</td><td></td><td>从局部变量0中装载引用类型值入栈</td></tr><tr><td>0X2b</td><td>aload_1</td><td></td><td>从局部变量1中装载引用类型值入栈</td></tr><tr><td>0X2c</td><td>aload_2</td><td></td><td>从局部变量2中装载引用类型值入栈</td></tr><tr><td>0X2d</td><td>aload_3</td><td></td><td>从局部变量3中装载引用类型值入栈</td></tr><tr><td>0X15</td><td>(wide)iload</td><td>indexbyte</td><td>从局部变量indexbyte中装载int类型值入栈</td></tr><tr><td>0X1a</td><td>iload_0</td><td></td><td>从局部变量0中装载int类型值入栈</td></tr><tr><td>0X1b</td><td>iload_1</td><td></td><td>从局部变量1中装载int类型值入栈</td></tr><tr><td>0X1c</td><td>iload_2</td><td></td><td>从局部变量2中装载int类型值入栈</td></tr><tr><td>0X1d</td><td>iload_3</td><td></td><td>从局部变量3中装载int类型值入栈</td></tr><tr><td>0X16</td><td>(wide)lload</td><td>indexbyte</td><td>从局部变量indexbyte中装载long类型值入栈</td></tr><tr><td>0X1e</td><td>lload_0</td><td></td><td>从局部变量0中装载int类型值入栈</td></tr><tr><td>0X1f</td><td>lload_1</td><td></td><td>从局部变量1中装载int类型值入栈</td></tr><tr><td>0X20</td><td>lload_2</td><td></td><td>从局部变量2中装载int类型值入栈</td></tr><tr><td>0X21</td><td>lload_3</td><td></td><td>从局部变量3中装载int类型值入栈</td></tr><tr><td>0X17</td><td>(wide)fload</td><td>indexbyte</td><td>从局部变量indexbyte中装载float类型值入栈</td></tr><tr><td>0X22</td><td>fload_0</td><td></td><td>从局部变量0中装载float类型值入栈</td></tr><tr><td>0X23</td><td>fload_1</td><td></td><td>从局部变量1中装载float类型值入栈</td></tr><tr><td>0X24</td><td>fload_2</td><td></td><td>从局部变量2中装载float类型值入栈</td></tr><tr><td>0X25</td><td>fload_3</td><td></td><td>从局部变量3中装载float类型值入栈</td></tr><tr><td>0X18</td><td>(wide)dload</td><td>indexbyte</td><td>从局部变量indexbyte中装载double类型值入栈</td></tr><tr><td>0X26</td><td>dload_0</td><td></td><td>从局部变量0中装载double类型值入栈</td></tr><tr><td>0X27</td><td>dload_1</td><td></td><td>从局部变量1中装载double类型值入栈</td></tr><tr><td>0X28</td><td>dload_2</td><td></td><td>从局部变量2中装载double类型值入栈</td></tr><tr><td>0X29</td><td>dload_3</td><td></td><td>从局部变量3中装载double类型值入栈</td></tr><tr><td>0X32</td><td>aaload</td><td></td><td>从引用类型数组中装载指定项的值</td></tr><tr><td>0X2e</td><td>iaload</td><td></td><td>从int类型数组中装载指定项的值</td></tr><tr><td>0X2f</td><td>laload</td><td></td><td>从long类型数组中装载指定项的值</td></tr><tr><td>0X30</td><td>faload</td><td></td><td>从float类型数组中装载指定项的值</td></tr><tr><td>0X31</td><td>daload</td><td></td><td>从double类型数组中装载指定项的值</td></tr><tr><td>0X33</td><td>baload</td><td></td><td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）</td></tr><tr><td>0X34</td><td>caload</td><td></td><td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）</td></tr><tr><td>0X35</td><td>saload</td><td></td><td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）</td></tr></tbody></table></div><h2 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0X3a</td><td>(wide)astore</td><td>indexbyte</td><td>将栈顶引用类型值保存到局部变量indexbyte中</td></tr><tr><td>0X4b</td><td>astroe_0</td><td></td><td>将栈顶引用类型值保存到局部变量0中</td></tr><tr><td>0X4c</td><td>astroe_1</td><td></td><td>将栈顶引用类型值保存到局部变量1中</td></tr><tr><td>0X4d</td><td>astroe_2</td><td></td><td>将栈顶引用类型值保存到局部变量2中</td></tr><tr><td>0X4e</td><td>astroe_3</td><td></td><td>将栈顶引用类型值保存到局部变量3中</td></tr><tr><td>0X36</td><td>(wide)istore</td><td>indexbyte</td><td>将栈顶int类型值保存到局部变量indexbyte中</td></tr><tr><td>0X3b</td><td>istroe_0</td><td></td><td>将栈顶int类型值保存到局部变量0中</td></tr><tr><td>0X3c</td><td>istroe_1</td><td></td><td>将栈顶int类型值保存到局部变量1中</td></tr><tr><td>0X3d</td><td>istroe_2</td><td></td><td>将栈顶int类型值保存到局部变量2中</td></tr><tr><td>0X3e</td><td>istroe_3</td><td></td><td>将栈顶int类型值保存到局部变量3中</td></tr><tr><td>0X37</td><td>(wide)lstore</td><td>indexbyte</td><td>将栈顶long类型值保存到局部变量indexbyte中</td></tr><tr><td>0X3f</td><td>lstroe_0</td><td></td><td>将栈顶long类型值保存到局部变量0中</td></tr><tr><td>0X40</td><td>lstroe_1</td><td></td><td>将栈顶long类型值保存到局部变量1中</td></tr><tr><td>0X41</td><td>lstroe_2</td><td></td><td>将栈顶long类型值保存到局部变量2中</td></tr><tr><td>0X42</td><td>lstroe_3</td><td></td><td>将栈顶long类型值保存到局部变量3中</td></tr><tr><td>0X38</td><td>(wide)fstore</td><td>indexbyte</td><td>将栈顶float类型值保存到局部变量indexbyte中</td></tr><tr><td>0X43</td><td>fstroe_0</td><td></td><td>将栈顶float类型值保存到局部变量0中</td></tr><tr><td>0X44</td><td>fstroe_1</td><td></td><td>将栈顶float类型值保存到局部变量1中</td></tr><tr><td>0X45</td><td>fstroe_2</td><td></td><td>将栈顶float类型值保存到局部变量2中</td></tr><tr><td>0X46</td><td>fstroe_3</td><td></td><td>将栈顶float类型值保存到局部变量3中</td></tr><tr><td>0X39</td><td>(wide)dstore</td><td>indexbyte</td><td>将栈顶double类型值保存到局部变量indexbyte中</td></tr><tr><td>0X47</td><td>dstroe_0</td><td></td><td>将栈顶double类型值保存到局部变量0中</td></tr><tr><td>0X48</td><td>dstroe_1</td><td></td><td>将栈顶double类型值保存到局部变量1中</td></tr><tr><td>0X49</td><td>dstroe_2</td><td></td><td>将栈顶double类型值保存到局部变量2中</td></tr><tr><td>0X4a</td><td>dstroe_3</td><td></td><td>将栈顶double类型值保存到局部变量3中</td></tr><tr><td>0X53</td><td>aastore</td><td></td><td>将栈顶引用类型值保存到指定引用类型数组的指定项</td></tr><tr><td>0X4f</td><td>iastore</td><td></td><td>将栈顶int类型值保存到指定int类型数组的指定项</td></tr><tr><td>0X50</td><td>lastore</td><td></td><td>将栈顶long类型值保存到指定long类型数组的指定项</td></tr><tr><td>0X51</td><td>fastore</td><td></td><td>将栈顶float类型值保存到指定float类型数组的指定项</td></tr><tr><td>0X52</td><td>dastore</td><td></td><td>将栈顶double类型值保存到指定double类型数组的指定项</td></tr><tr><td>0X54</td><td>bastore</td><td></td><td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项</td></tr><tr><td>0X55</td><td>castore</td><td></td><td>将栈顶char类型值保存到指定char类型数组的指定项</td></tr><tr><td>0X56</td><td>sastore</td><td></td><td>将栈顶short类型值保存到指定short类型数组的指定项</td></tr></tbody></table></div><h2 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0Xc4</td><td>wide</td><td></td><td>使用附加字节扩展局部变量索引（iinc指令特殊）</td></tr></tbody></table></div><h2 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td></td><td>空操作。</td></tr><tr><td>0x57</td><td>pop</td><td></td><td>从栈顶弹出一个字长的数据。</td></tr><tr><td>0x58</td><td>pop2</td><td></td><td>从栈顶弹出两个字长的数据。</td></tr><tr><td>0x59</td><td>dup</td><td></td><td>复制栈顶一个字长的数据，将复制后的数据压栈。</td></tr><tr><td>0x5a</td><td>dup_x1</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td></tr><tr><td>0x5b</td><td>dup_x2</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5c</td><td>dup2</td><td></td><td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td></tr><tr><td>0x5f</td><td>swap</td><td></td><td>交换栈顶两个字长的数据的位置。Java指令中没有提供以两个字长为单位的交换指令。</td></tr></tbody></table></div><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x86</td><td>i2f</td><td></td><td>将栈顶int类型值转换为float类型值。</td></tr><tr><td>0x85</td><td>i2l</td><td></td><td>将栈顶int类型值转换为long类型值。</td></tr><tr><td>0x87</td><td>i2d</td><td></td><td>将栈顶int类型值转换为double类型值。</td></tr><tr><td>0x8b</td><td>f2i</td><td></td><td>将栈顶float类型值转换为int类型值。</td></tr><tr><td>0x8c</td><td>f2l</td><td></td><td>将栈顶float类型值转换为long类型值。</td></tr><tr><td>0x8d</td><td>f2d</td><td></td><td>将栈顶float类型值转换为double类型值。</td></tr><tr><td>0x88</td><td>l2i</td><td></td><td>将栈顶long类型值转换为int类型值。</td></tr><tr><td>0x89</td><td>l2f</td><td></td><td>将栈顶long类型值转换为float类型值。</td></tr><tr><td>0x8a</td><td>l2d</td><td></td><td>将栈顶long类型值转换double类型值。</td></tr><tr><td>0x8e</td><td>d2i</td><td></td><td>将栈顶double类型值转换为int类型值。</td></tr><tr><td>0x90</td><td>d2f</td><td></td><td>将栈顶double类型值转换为float类型值。</td></tr><tr><td>0x8f</td><td>d2l</td><td></td><td>将栈顶double类型值转换为long类型值。</td></tr><tr><td>0x91</td><td>i2b</td><td></td><td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x92</td><td>i2c</td><td></td><td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x93</td><td>i2s</td><td></td><td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td></tr></tbody></table></div><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x60</td><td>iadd</td><td></td><td>将栈顶两int类型数相加，结果入栈。</td></tr><tr><td>0x64</td><td>isub</td><td></td><td>将栈顶两int类型数相减，结果入栈。</td></tr><tr><td>0x68</td><td>imul</td><td></td><td>将栈顶两int类型数相乘，结果入栈。</td></tr><tr><td>0x6c</td><td>idiv</td><td></td><td>将栈顶两int类型数相除，结果入栈。</td></tr><tr><td>0x70</td><td>irem</td><td></td><td>将栈顶两int类型数取模，结果入栈。</td></tr><tr><td>0x74</td><td>ineg</td><td></td><td>将栈顶int类型值取负，结果入栈。</td></tr><tr><td>0x61</td><td>ladd</td><td></td><td>将栈顶两long类型数相加，结果入栈。</td></tr><tr><td>0x65</td><td>lsub</td><td></td><td>将栈顶两long类型数相减，结果入栈。</td></tr><tr><td>0x69</td><td>lmul</td><td></td><td>将栈顶两long类型数相乘，结果入栈。</td></tr><tr><td>0x6d</td><td>idiv</td><td></td><td>将栈顶两long类型数相除，结果入栈。</td></tr><tr><td>0x71</td><td>lrem</td><td></td><td>将栈顶两long类型数取模，结果入栈。</td></tr><tr><td>0x75</td><td>lneg</td><td></td><td>将栈顶long类型值取负，结果入栈。</td></tr><tr><td>0x84</td><td>(wide)iinc</td><td>indexbyte constbyte</td><td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td></tr></tbody></table></div><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x62</td><td>fadd</td><td></td><td>将栈顶两float类型数相加，结果入栈。</td></tr><tr><td>0x66</td><td>fsub</td><td></td><td>将栈顶两float类型数相减，结果入栈。</td></tr><tr><td>0x6a</td><td>fmul</td><td></td><td>将栈顶两float类型数相乘，结果入栈。</td></tr><tr><td>0x6e</td><td>fdiv</td><td></td><td>将栈顶两float类型数相除，结果入栈。</td></tr><tr><td>0x72</td><td>frem</td><td></td><td>将栈顶两float类型数取模，结果入栈。</td></tr><tr><td>0x76</td><td>fneg</td><td></td><td>将栈顶float类型值取反，结果入栈。</td></tr><tr><td>0x63</td><td>dadd</td><td></td><td>将栈顶两double类型数相加，结果入栈。</td></tr><tr><td>0x67</td><td>dsub</td><td></td><td>将栈顶两double类型数相减，结果入栈。</td></tr><tr><td>0x6b</td><td>dmul</td><td></td><td>将栈顶两double类型数相乘，结果入栈。</td></tr><tr><td>0x6f</td><td>ddiv</td><td></td><td>将栈顶两double类型数相除，结果入栈。</td></tr><tr><td>0x73</td><td>drem</td><td></td><td>将栈顶两double类型数取模，结果入栈。</td></tr><tr><td>0x77</td><td>dneg</td><td></td><td>将栈顶double类型值取负，结果入栈。</td></tr></tbody></table></div><h2 id="逻辑运算——移位运算"><a href="#逻辑运算——移位运算" class="headerlink" title="逻辑运算——移位运算"></a>逻辑运算——移位运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x78</td><td>ishl</td><td></td><td>左移int类型值。</td></tr><tr><td>0x79</td><td>lshl</td><td></td><td>左移long类型值。</td></tr><tr><td>0x7a</td><td>ishr</td><td></td><td>算术右移int类型值。</td></tr><tr><td>0x7b</td><td>lshr</td><td></td><td>算术右移long类型值。</td></tr><tr><td>0x7c</td><td>iushr</td><td></td><td>逻辑右移int类型值。</td></tr><tr><td>0x7d</td><td>lushr</td><td></td><td>逻辑右移long类型值。</td></tr></tbody></table></div><h2 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x73</td><td>iand</td><td></td><td>对int类型按位与运算。</td></tr><tr><td>0x7f</td><td>land</td><td></td><td>对long类型的按位与运算。</td></tr><tr><td>0x80</td><td>ior</td><td></td><td>对int类型的按位或运算。</td></tr><tr><td>0x81</td><td>lor</td><td></td><td>对long类型的按位或运算。</td></tr><tr><td>0x82</td><td>ixor</td><td></td><td>对int类型的按位异或运算。</td></tr><tr><td>0x83</td><td>lxor</td><td></td><td>对long类型的按位异或运算。</td></tr></tbody></table></div><h2 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值为0则跳转。</td></tr><tr><td>0x9a</td><td>ifne</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值不为0则跳转。</td></tr><tr><td>0x9b</td><td>iflt</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值小于0则跳转。</td></tr><tr><td>0x9e</td><td>ifle</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值小于等于0则跳转。</td></tr><tr><td>0x9d</td><td>ifgt</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值大于0则跳转。</td></tr><tr><td>0x9c</td><td>ifge</td><td>branchbyte1 branchbyte2</td><td>若栈顶int类型值大于等于0则跳转。</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值相等则跳转。</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值不相等则跳转。</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前小于后则跳转。</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前小于等于后则跳转。</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前大于后则跳转。</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>branchbyte1 branchbyte2</td><td>若栈顶两int类型值前大于等于后则跳转。</td></tr><tr><td>0xc6</td><td>ifnull</td><td>branchbyte1 branchbyte2</td><td>若栈顶引用值为null则跳转。</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>branchbyte1 branchbyte2</td><td>若栈顶引用值不为null则跳转。</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>branchbyte1 branchbyte2</td><td>若栈顶两引用类型值相等则跳转。</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>branchbyte1 branchbyte2</td><td>若栈顶两引用类型值不相等则跳转。</td></tr></tbody></table></div><h2 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x94</td><td>lcmp</td><td></td><td>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</td></tr><tr><td>0x95</td><td>fcmpl</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x96</td><td>fcmpg</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x97</td><td>dcmpl</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x98</td><td>dcmpg</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr></tbody></table></div><h2 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xa7</td><td>goto</td><td>branchbyte1 branchbyte2</td><td>无条件跳转到指定位置。</td></tr><tr><td>0xc8</td><td>goto_w</td><td>branchbyte1 branchbyte2 branchbyte3 branchbyte4</td><td>无条件跳转到指定位置（宽索引）。</td></tr></tbody></table></div><h2 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xaa</td><td>tableswitch</td><td>defaultbyte1-4 lowbyte1-4 highbyte1-4 jump offsets…</td><td>通过索引访问跳转表，并跳转。</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>defaultbyte1-4 npairs1-4 matcj offsets…</td><td>通过键值访问跳转表，并跳转。</td></tr></tbody></table></div><h2 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbf</td><td>athrow</td><td></td><td>抛出异常。</td></tr><tr><td>0xa8</td><td>jsr</td><td>branchbyte1 branchbyte2</td><td>跳转到子例程序。</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>branchbyte-4</td><td>跳转到子例程序（宽索引）。</td></tr><tr><td>0xa9</td><td>(wide)ret</td><td>indexbyte</td><td>返回子例程序。</td></tr></tbody></table></div><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbb</td><td>new</td><td>indexbyte1 indexbyte2</td><td>创建新的对象实例。</td></tr><tr><td>0xc0</td><td>checkcast</td><td>indexbyte1 indexbyte2</td><td>类型强转。</td></tr><tr><td>0xc1</td><td>instanceof</td><td>indexbyte1 indexbyte2</td><td>判断类型。</td></tr><tr><td>0xb4</td><td>getfield</td><td>indexbyte1 indexbyte2</td><td>获取对象字段的值。</td></tr><tr><td>0xb5</td><td>putfield</td><td>indexbyte1 indexbyte2</td><td>给对象字段赋值。</td></tr><tr><td>0xb2</td><td>getstatic</td><td>indexbyte1 indexbyte2</td><td>获取静态字段的值。</td></tr><tr><td>0xb3</td><td>putstatic</td><td>indexbyte1 indexbyte2</td><td>给静态字段赋值。</td></tr></tbody></table></div><h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbc</td><td>newarray</td><td>atype</td><td>创建type类型的数组。</td></tr><tr><td>0xbd</td><td>anewarray</td><td>indexbyte1 indexbyte2</td><td>创建引用类型的数组。</td></tr><tr><td>0xbe</td><td>arraylength</td><td></td><td>获取一维数组的长度。</td></tr><tr><td>0xbe</td><td>multianewarray</td><td>indexbyte1 indexbyte2 dimension</td><td>创建dimension维度的数组。</td></tr></tbody></table></div><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xb7</td><td>invokespecial</td><td>indexbyte1 indexbyte2</td><td>编译时方法绑定调用方法。</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>indexbyte1 indexbyte2</td><td>运行时方法绑定调用方法。</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>indexbyte1 indexbyte2</td><td>调用静态方法。</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>indexbyte1 indexbyte2 count 0</td><td>调用接口方法。</td></tr></tbody></table></div><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xac</td><td>ireturn</td><td></td><td>返回int类型值。</td></tr><tr><td>0xad</td><td>lreturn</td><td></td><td>返回long类型值。</td></tr><tr><td>0xae</td><td>freturn</td><td></td><td>返回float类型值。</td></tr><tr><td>0xaf</td><td>dreturn</td><td></td><td>返回double类型值。</td></tr><tr><td>0xb0</td><td>areturn</td><td></td><td>返回引用类型值。</td></tr><tr><td>0xb1</td><td>return</td><td></td><td>void函数返回。</td></tr></tbody></table></div><h2 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h2><div class="table-container"><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc2</td><td>monitorenter</td><td></td><td>进入并获得对象监视器。</td></tr><tr><td>0xc3</td><td>monitorexit</td><td></td><td>释放并退出对象监视器。</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">Java字节码指令大全</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java锁</title>
    <link href="http://example.com/2023/03/15/java%E9%94%81/"/>
    <id>http://example.com/2023/03/15/java%E9%94%81/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-07-26T06:30:03.773Z</updated>
    
    <content type="html"><![CDATA[<p>Java中常见锁分为两种：一种是<code>Synchronized</code>修饰的锁；另一种就是<code>java.util.concurrent</code>包下的各种同步锁，他们基于<code>AbstractQueuedSynchronizer（AQS）框架来构建的</code>，而<code>AQS</code>的核心数据结构是<code>CLH锁</code>的变体。</p><h2 id="一、无锁、偏向锁、轻量级锁和重量级锁"><a href="#一、无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="一、无锁、偏向锁、轻量级锁和重量级锁"></a>一、无锁、偏向锁、轻量级锁和重量级锁</h2><p>Synchronized 锁的底层类别</p><div class="table-container"><table><thead><tr><th>所状态</th><th>存储内容</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td>01</td><td></td></tr><tr><td>偏向锁</td><td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td>01</td><td></td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td><td></td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>10</td><td></td></tr></tbody></table></div><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。<br><strong><em>在jdk1.6之前，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，这种方式就是synchronized最初实现同步的方式（依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步），synchronized 是重量级锁，效率低下。</em></strong></p><p>在jvm中，对象在内存中除了本身的数据外还会有个对象头，其对象头中有两类信息：<code>mark word</code>和<code>类型指针</code>；另外对于数组而言还会有一份记录数组长度的数据。类型指针是指向该对象所属类对象的指针，mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32bit，64位系统上长度为64bit。<br><img src="/img/JavaLock/0.png" alt="github"><br>表格中可以看到存储数据格式会随着锁的不同而不同。<br>当对象状态为偏向锁时，mark word存储的是偏向的线程ID；当状态为轻量级锁时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁时，为指向堆中的monitor对象的指针。</p><h2 id="1-1-全局安全点（safepoint）"><a href="#1-1-全局安全点（safepoint）" class="headerlink" title="1.1 全局安全点（safepoint）"></a>1.1 全局安全点（safepoint）</h2><p>代表了一个状态，在该状态下所有线程都是暂停的。</p><h2 id="1-2-偏向锁"><a href="#1-2-偏向锁" class="headerlink" title="1.2 偏向锁"></a>1.2 偏向锁</h2><p>偏向锁在获取资源的时候会在资源对象上记录该对象是偏向该线程的，偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。</p><h3 id="1-2-1-偏向锁获取过程"><a href="#1-2-1-偏向锁获取过程" class="headerlink" title="1.2.1 偏向锁获取过程"></a>1.2.1 偏向锁获取过程</h3><ol><li>访问Mark Word中偏向锁标志位是否设置成1，锁标志位是否为01——确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>执行同步代码。</li></ol><h3 id="1-2-2-偏向锁的释放"><a href="#1-2-2-偏向锁的释放" class="headerlink" title="1.2.2.偏向锁的释放"></a>1.2.2.偏向锁的释放</h3><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点safepoint，它会首先暂停拥有偏向锁的线程A，然后判断这个线程A，此时有两种情况：</p><ol><li>A线程已经退出了同步代码块，或者是已经不存活了，如果是上面两种情况之一的，此时就会直接撤销偏向锁，变成无锁状态</li><li>A线程还在同步代码块中，此时将A线程的偏向锁升级为轻量级锁。下面说明了怎么升级。</li></ol><h3 id="1-2-3-批量重偏向"><a href="#1-2-3-批量重偏向" class="headerlink" title="1.2.3 批量重偏向"></a>1.2.3 批量重偏向</h3><h4 id="为什么有批量重偏向"><a href="#为什么有批量重偏向" class="headerlink" title="为什么有批量重偏向"></a>为什么有批量重偏向</h4><p>当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。这个过程是要消耗一定的成本的，所以如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p><h4 id="批量重偏向的原理"><a href="#批量重偏向的原理" class="headerlink" title="批量重偏向的原理"></a>批量重偏向的原理</h4><ol><li>首先引入一个概念epoch，其本质是一个时间戳，代表了偏向锁的有效性，epoch存储在可偏向对象的MarkWord中。除了对象中的epoch，对象所属的类class信息中，也会保存一个epoch值。</li><li>每当遇到一个全局安全点时(这里的意思是说批量重偏向没有完全替代了全局安全点，全局安全点是一直存在的)，比如要对class C 进行批量再偏向，则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new</li><li>然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，仅将epoch_new的值赋给被锁定的对象中，也就是现在偏向锁还在被使用的对象才会被赋值epoch_new。</li><li>退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为（3）步骤里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作。</li></ol><h2 id="1-3-轻量级锁"><a href="#1-3-轻量级锁" class="headerlink" title="1.3 轻量级锁"></a>1.3 轻量级锁</h2><h3 id="1-3-1-轻量级锁的获取过程"><a href="#1-3-1-轻量级锁的获取过程" class="headerlink" title="1.3.1 轻量级锁的获取过程"></a>1.3.1 轻量级锁的获取过程</h3><ol><li>在代码进入同步块的时候，如果同步对象锁状态为偏向状态（就是锁标志位为“01”状态，是否为偏向锁标志位为“1”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。官方称之为 Displaced Mark Word（所以这里我们认为Lock Record和 Displaced Mark Word其实是同一个概念）。这时候线程堆栈与对象头的状态如图所示：<br><img src="/img/JavaLock/1.png" alt="github"></li><li><p>拷贝对象头中的Mark Word复制到锁记录中。</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象头的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象头的mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p></li><li><p>如果上面这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下所示：<br><img src="/img/JavaLock/2.png" alt="github"></p></li><li><p>如果上面这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧。</p></li></ol><ul><li>如果是就说明当前线程已经拥有了这个对象的锁，现在是重入状态，那么设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。重入之后然后结束。接着就可以直接进入同步块继续执行。</li><li>如果不是说明这个锁对象已经被其他线程抢占了，说明此时有多个线程竞争锁，那么它就会自旋等待锁，一定次数后仍未获得锁对象，说明发生了竞争，需要膨胀为重量级锁。</li></ul><p>下图为重入三次时的lock record示意图，左边为锁对象，右边为当前线程的栈帧，重入之后然后结束。接着就可以直接进入同步块继续执行。<br><img src="/img/JavaLock/6.png" alt="github"></p><p>自旋原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗 CPU 的，如果一直获取不到锁，那线程也不能一直占用 CPU 自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM 对于自旋周期的选择，JDK1.6 之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，自旋不会一直持续下去，这时争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁。</p><h3 id="1-3-2-轻量级锁的解锁过程"><a href="#1-3-2-轻量级锁的解锁过程" class="headerlink" title="1.3.2 轻量级锁的解锁过程"></a>1.3.2 轻量级锁的解锁过程</h3><ul><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</li><li>如果替换成功，整个同步过程就完成了。</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ul><h2 id="1-4-重量级锁"><a href="#1-4-重量级锁" class="headerlink" title="1.4 重量级锁"></a>1.4 重量级锁</h2><h3 id="1-4-1-重量级锁加锁和释放锁机制"><a href="#1-4-1-重量级锁加锁和释放锁机制" class="headerlink" title="1.4.1 重量级锁加锁和释放锁机制"></a>1.4.1 重量级锁加锁和释放锁机制</h3><p>调用omAlloc分配一个ObjectMonitor对象，把锁对象头的mark word锁标志位变成 “10 ”，然后在mark word存储指向ObjectMonitor对象的指针</p><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><img src="/img/JavaLock/3.png" alt="github"></p><ol><li>当多个线程同时访问一段同步代码时，首先会进入 _EntryList 队列中。</li><li>当某个线程获取到对象的Monitor后进入临界区域，并把Monitor中的 _owner 变量设置为当前线程，同时Monitor中的计数器 _count 加1。即获得对象锁。</li><li>若持有Monitor的线程调用 wait() 方法，将释放当前持有的Monitor，*owner变量恢复为null，*count自减1，同时该线程进入 _WaitSet 集合中等待被唤醒。</li><li>在WaitSet 集合中的线程会被再次放到EntryList 队列中，重新竞争获取锁。</li><li>若当前线程执行完毕也将释放Monitor并复位变量的值，以便其他线程进入获取锁。</li></ol><h3 id="1-4-2-Monitor-对象"><a href="#1-4-2-Monitor-对象" class="headerlink" title="1.4.2 Monitor 对象"></a>1.4.2 Monitor 对象</h3><p>本质上是一个管程：管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。<br>在HotSpot虚拟机中，Monitor是基于C++的ObjectMonitor类实现的，结构体如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>    _header       = NULL;<br>    _count        = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 约为 _WaitSet 和 _EntryList 的节点数之和</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录重入次数</span><br>    _object       = NULL;<br>    _owner        = NULL; <span class="hljs-comment">// _owner指向持有ObjectMonitor对象的线程</span><br>    _WaitSet      = NULL; <span class="hljs-comment">// 双向循环链表：存放处于wait状态的线程队列，即调用wait()方法的线程</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = NULL ;<br>    _succ         = NULL ;<br>    _cxq          = NULL ;  <span class="hljs-comment">// 单向链表：多个线程争抢锁，会先存入这个</span><br>    FreeNext      = NULL ;<br>    _EntryList    = NULL ;  <span class="hljs-comment">// 双向循环链表：存放处于等待锁block状态的线程队列</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h3 id="1-4-3-锁竞争机制"><a href="#1-4-3-锁竞争机制" class="headerlink" title="1.4.3 锁竞争机制"></a>1.4.3 锁竞争机制</h3><h4 id="1-4-3-1-ObjectMonitor的并发管理逻辑"><a href="#1-4-3-1-ObjectMonitor的并发管理逻辑" class="headerlink" title="1.4.3.1 ObjectMonitor的并发管理逻辑"></a>1.4.3.1 ObjectMonitor的并发管理逻辑</h4><p><code>ObjectMonitor::enter()</code> 和 <code>ObjectMonitor::exit()</code> 分别是ObjectMonitor获取锁和释放锁的方法。线程解锁后还会唤醒之前等待的线程，根据策略选择直接唤醒_cxq队列中的头部线程去竞争，或者将_cxq队列中的线程加入_EntryList，然后再唤醒_EntryList队列中的线程去竞争。<br><img src="/img/JavaLock/4.png" alt="github"></p><h4 id="1-4-3-2-ObjectMonitor-enter"><a href="#1-4-3-2-ObjectMonitor-enter" class="headerlink" title="1.4.3.2 ObjectMonitor::enter()"></a>1.4.3.2 ObjectMonitor::enter()</h4><p><img src="/img/JavaLock/5.png" alt="github"><br>看一下ObjectMonitor::enter()方法竞争锁的流程：</p><ol><li>首先尝试通过 CAS 把 ObjectMonitor 中的 _owner 设置为当前线程，设置成功就表示获取锁成功。通过 _recursions 的自增来表示重入。</li><li>如果没有CAS成功，那么就开始启动自适应自旋，自旋还不行的话，就包装成 ObjectWaiter 对象加入到 _cxq 单向链表之中。</li><li>加入_cxq链表后，再次尝试是否可以CAS拿到锁，再次失败就要阻塞(block)，底层调用了pthread_mutex_lock。</li></ol><h4 id="1-4-3-3-ObjectMonitor-exit-方法"><a href="#1-4-3-3-ObjectMonitor-exit-方法" class="headerlink" title="1.4.3.3 ObjectMonitor::exit()方法"></a>1.4.3.3 ObjectMonitor::exit()方法</h4><p><img src="/img/JavaLock/7.png" alt="github"></p><ol><li>线程执行 Object.wait()方法时，会将当前线程加入到 _waitSet 这个双向链表中，然后再运行ObjectMonitor::exit() 方法来释放锁。</li><li>可重入锁就是根据 _recursions 来判断的，重入一次就执行 _recursions++，解锁一次就执行 _recursions—，如果 _recursions 减到 0 ，就说明需要释放锁了。</li><li>线程解锁后还会唤醒之前等待的线程。当线程执行 Object.notify()方法时，从 _waitSet 头部拿线程节点，然后根据策略（QMode指定）决定将线程节点放在哪里，包括_cxq 或 _EntryList 的头部或者尾部，然后唤醒队列中的线程。</li></ol><h2 id="1-5-synchronized关键字"><a href="#1-5-synchronized关键字" class="headerlink" title="1.5 synchronized关键字"></a>1.5 synchronized关键字</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>同步代码块的加锁、解锁是通过 Javac 编译器实现的，底层是借助monitorenter和monitorerexit，为了能够保证无论代码块正常执行结束 or 抛出异常结束，都能正确释放锁，Javac 编译器在编译的时候，会对monitorerexit进行特殊处理<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 同步数据</span><br>            System.out.println(<span class="hljs-string">&quot;hehehe&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后通过<code>javap -c Test.class &gt;&gt; test.txt</code>查看其编译后的字节码:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.Test();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: dup<br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: monitorenter<br>       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       7: ldc           #3                  // String hehehe<br>       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>      <span class="hljs-number">12</span>: aload_1<br>      <span class="hljs-number">13</span>: monitorexit<br>      <span class="hljs-number">14</span>: goto          <span class="hljs-number">22</span><br>      <span class="hljs-number">17</span>: astore_2<br>      <span class="hljs-number">18</span>: aload_1<br>      <span class="hljs-number">19</span>: monitorexit<br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: athrow<br>      <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">4</span>    <span class="hljs-number">14</span>    <span class="hljs-number">17</span>   any<br>          <span class="hljs-number">17</span>    <span class="hljs-number">20</span>    <span class="hljs-number">17</span>   any<br>&#125;<br></code></pre></td></tr></table></figure><br>monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取mark word里面存储的monitor，当 monitor的进入计数器为 0，那线程可以成功取得monitor，并将计数器值设置为1，取锁成功。</p><p>值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从上面的字节码中也可以看出有两个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><h3 id="同步实例方法"><a href="#同步实例方法" class="headerlink" title="同步实例方法"></a>同步实例方法</h3><p>同步方法的加锁、解锁是通过 Javac 编译器实现的，底层是借助<code>ACC_SYNCHRONIZED</code>访问标识符来实现的，代码如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步数据</span><br>        System.out.println(<span class="hljs-string">&quot;hehehe&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.Test();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       3: ldc           #3                  // String hehehe<br>       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h3><p>给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀ 个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有 ⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤ 这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前 实例对象锁。</p><p><img src="/img/JavaLock/8.png" alt="github"></p><h2 id="二、处理器架构"><a href="#二、处理器架构" class="headerlink" title="二、处理器架构"></a>二、处理器架构</h2><p>在了解下面锁之前，我们先需要一些处理器架构基础知识。</p><h2 id="2-1-SMP架构"><a href="#2-1-SMP架构" class="headerlink" title="2.1 SMP架构"></a>2.1 SMP架构</h2><p>即对称多处理器结构，在这种架构中，一台计算机由多个CPU组成，并共享内存和其他资源，所有的CPU都可以平等的访问内存、I/O等。虽然可以同时使用多个CPU，但从外部表现来看，它们就如同一台单CPU机器一样，操作系统将任务队列对称地分布于多个CPU之上，从而极大地提高了整个系统的数据处理能力。<br><img src="/img/JavaLock/12.png" alt="github"><br>但是随着CPU数量的增加，每个CPU都要访问共享资源，而资源在某些场景下只能单线程访问，在某些场景下的操作又必须通知到其他CPU，那么这就带来了性能损耗、资源浪费，成为了系统瓶颈。</p><h2 id="2-2-NUMA架构"><a href="#2-2-NUMA架构" class="headerlink" title="2.2 NUMA架构"></a>2.2 NUMA架构</h2><p>即非一致存储访问，这种模型的是为了解决smp扩容性很差而提出的技术方案。它按组将CPU分为多模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O等，模块之间的访问通过互联模块完成（类似远程通信），访问本地资源的速度会远高于访问外部资源<br><img src="/img/JavaLock/13.png" alt="github"><br>NUMA架构相当于打包多个SMP架构的CPU，它能较好解决SMP架构存在的扩展问题；但是，在NUMA的单个CPU模块中，虽然控制了CPU数量减少了共享资源的操作时的性能损耗，由于存在互联模块的工作，在CPU模块增加时，并不能线性的增加系统性能。</p><h2 id="2-3-MPP架构"><a href="#2-3-MPP架构" class="headerlink" title="2.3 MPP架构"></a>2.3 MPP架构</h2><p>MPP 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。 其基本特征是由多个 SMP 服务器（每个 SMP 服务器称节点）通过节点互联网络连接而成，每个节点只访问自己的本地资源（内存、存储等），是一种完全无共享（Share Nothing）结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现512个节点互联，数千个 CPU。 实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU。<br><img src="/img/JavaLock/14.png" alt="github"><br>可以将MMP理解为刀片服务器，每个刀扇里的都是一台独立SMP架构服务器，并且每个刀扇之间均有高性能的网络设备进行交互，保证smp服务器之间的数据传输性能。MMP架构比较依赖管理系统的处理能力来保障通信。</p><h2 id="三、CLH-锁"><a href="#三、CLH-锁" class="headerlink" title="三、CLH 锁"></a>三、CLH 锁</h2><p>CLH队列锁是一种基于链表的可扩展、高性能、公平的自旋锁, 申请线程仅仅在本地变量上自旋，不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。能确保无饥饿性，提供先来先服务的公平性。<br>CLH 锁的核心思想：将众多线程长时间对某资源(比如锁状态)的竞争，通过有序化这些线程将其转化为只需对前驱节点的本地变量检测。而唯一存在竞争的地方就是在入队列之前对尾节点tail的竞争，但此时竞争的线程数量已经少了很多了。比起所有线程直接对某资源竞争的轮询次数也减少了很多，这也大大节省了CPU缓存同步的消耗，从而大大提升系统性能。</p><p>当一个线程需要获取锁时：</p><ol><li><p>创建一个QNode, 将其中的 locked 设置为 true，表示需要获取锁，myPred 表示对其前驱节点的引用。<br><img src="/img/JavaLock/9.png" alt="github"></p></li><li><p>线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred<br><img src="/img/JavaLock/10.png" alt="github"></p><p> 线程B需要获得锁，同样的流程再来一遍<br><img src="/img/JavaLock/11.png" alt="github"></p></li><li><p>线程就在前驱节点的 locked 字段上旋转，直到前驱结点释放锁(即前驱节点的锁值 locked == false)</p></li><li>当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点。<br><img src="/img/JavaLock/12.png" alt="github"></li></ol><p>由于自旋过程中，监控的是前置节点的变量，因此在SMP架构的共享内存模式，能更好的提供性能。<br>在NUMA架构下，如果当前节点与前驱节点不在同一CPU模块下，跨CPU模块会带来额外的系统开销，而MCS锁更适用于NUMA架构。</p><h2 id="四、MCS-锁"><a href="#四、MCS-锁" class="headerlink" title="四、MCS 锁"></a>四、MCS 锁</h2><p>MCS锁中线程只对当前节点的本地变量自旋，而前驱节点则负责通知其结束自旋操作。<br>正因为如此，它解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题 。<br>每个节点在解锁时更新后继节点的锁值（locked），在这一刻，该节点的后置节点会结束自旋，并进行加锁。</p><p>NUMA架构下MCS锁的性能略优于CLH锁。</p><h2 id="4-1-CLH锁在NUMA架构下低于MCS锁的原因"><a href="#4-1-CLH锁在NUMA架构下低于MCS锁的原因" class="headerlink" title="4.1 CLH锁在NUMA架构下低于MCS锁的原因"></a>4.1 CLH锁在NUMA架构下低于MCS锁的原因</h2><p>CLH锁和MCS锁为线程节点分配的内存通常都会分配到与对应线程执行cpu核心绑定的NUMA节点的存储器中，而不同线程对应的cpu则可能位于不同的NUMA节点中。CLH锁会无限轮训前驱节点的isLocked状态，这一操作在前驱节点线程与当前线程不位于同一NUMA节点时，会不断的进行远程节点访问，性能较低；而MCS锁中，当前线程则是无限轮训自己线程节点的isLocked，这种情况下都是本地NUMA节点内存的访问。</p><h2 id="五、AQS"><a href="#五、AQS" class="headerlink" title="五、AQS"></a>五、AQS</h2><p>AQS（AbstractQueuedSynchronizer，队列同步器）<br>核心思想：如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。<br>AQS 使用一个volatile int state（代表共享资源）成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><p>内部队列改造：</p><ol><li>在结构上引入了头节点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关</li><li>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段</li><li>在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋</li><li>head节点使用的是虚拟节点</li></ol><p>AQS的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管理同步状态，在 AQS 里由一个int型的state来代表这个状态。将资源封装为Node,通过cas改变state值。<br><img src="/img/JavaLock/15.png" alt="github"></p><p>AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>从这里看是基本都是JCU包中的功能，大致使用了volatile来管理变量，完成并发。</p><h2 id="5-1-源码部分"><a href="#5-1-源码部分" class="headerlink" title="5.1 源码部分"></a>5.1 源码部分</h2><h3 id="5-1-1-节点"><a href="#5-1-1-节点" class="headerlink" title="5.1.1 节点"></a>5.1.1 节点</h3><p>节点有AQS的静态内部类Node定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><br><span class="hljs-comment">// 共享模式</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br><br><span class="hljs-comment">// 独占模式</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CANCELLED，值为1，表示当前的线程被取消</span><br><span class="hljs-comment"> * SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="hljs-comment"> * CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="hljs-comment"> * PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="hljs-comment"> * 值为0，表示当前节点在sync队列中，等待着获取锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br><br><span class="hljs-comment">// 前驱结点</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">// 后继结点</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">// 与该结点绑定的线程</span><br><span class="hljs-keyword">volatile</span> Thread thread;<br><br><span class="hljs-comment">// 存储condition队列中的后继节点</span><br>Node nextWaiter;<br><br><span class="hljs-comment">// 是否为共享模式</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>&#125;<br><br><span class="hljs-comment">// 获取前驱结点</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>Node p = prev;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br>Node() &#123; <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>&#125;<br><br>Node(Thread thread, Node mode) &#123; <span class="hljs-comment">// Used by addWaiter</span><br><span class="hljs-keyword">this</span>.nextWaiter = mode;<br><span class="hljs-keyword">this</span>.thread = thread;<br>&#125;<br><br>Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br><span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br><span class="hljs-keyword">this</span>.thread = thread;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>类中有两个常量SHARE和EXCLUSIVE，顾名思义这两个常量用于表示这个节点支持共享模式还是独占模式</p><ul><li>共享模式指的是允许多个线程获取同一个锁而且可能获取成功</li><li>独占模式指的是一个锁如果被一个线程持有，其他线程必须等待</li></ul><p>多个线程读取一个文件可以采用共享模式，而当有一个线程在写文件时不会允许另一个线程写这个文件，这就是独占模式的应用场景。</p><h3 id="5-1-2-CAS操作"><a href="#5-1-2-CAS操作" class="headerlink" title="5.1.2 CAS操作"></a>5.1.2 CAS操作</h3><p>AQS有三个重要的变量：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队头结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 队尾结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 代表共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>&#123;<br>    state = newState;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><br><code>compareAndSetState</code>方法是以乐观锁的方式更新共享资源。<br>独占锁是一种悲观锁，就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，即Compare And Swap。</p><p>head、tail、state三个变量都是volatile的。，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果一个字段被声明成，Java线程内存模型确保所有线程看到这个变量的值是一致的。volatile保证共享变量的可见性，CAS保证更新操作的原子性。</p><ul><li>声明共享变量为volatile</li><li>使用CAS的原子条件更新来实现线程之间的同步</li><li>配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信</li></ul><p><img src="/img/JavaLock/16.png" alt="github"></p><h3 id="5-1-3-方法"><a href="#5-1-3-方法" class="headerlink" title="5.1.3 方法"></a>5.1.3 方法</h3><p>AQS定义两种资源共享方式：</p><ul><li>Exclusive：独占，只有一个线程能执行，如ReentrantLock</li><li>Share：共享，多个线程可同时执行，如CountDownLatch</li></ul><h4 id="5-1-3-1-模板方法"><a href="#5-1-3-1-模板方法" class="headerlink" title="5.1.3.1 模板方法"></a>5.1.3.1 模板方法</h4><h5 id="1-acquire-int"><a href="#1-acquire-int" class="headerlink" title="1. acquire(int)"></a>1. acquire(int)</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。获取到资源后，线程就可以去执行其临界区代码了。</p><p>流程如下：</p><ol><li>尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p>下面是每个方法的实现代码</p><h6 id="1-1-tryAcquire-int"><a href="#1-1-tryAcquire-int" class="headerlink" title="1.1 tryAcquire(int)"></a>1.1 tryAcquire(int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。</p><p>AQS只是一个框架，在这里定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS），至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了。当然，自定义同步器在进行资源访问时要考虑线程安全的影响。 这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire，而共享模式下只用实现tryAcquireShared。如果都定义成，那么每个模式也要去实现另一模式下的接口。说到底，还是站在咱们开发者的角度，尽量减少不必要的工作量。</p><h6 id="1-2-addWaiter-Node"><a href="#1-2-addWaiter-Node" class="headerlink" title="1.2 addWaiter(Node)"></a>1.2 addWaiter(Node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用当前线程构造结点</span><br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果队尾结点不为空，将当前节点插入队尾</span><br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 队尾结点为空（队列还没有初始化），则转调enq入队</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，compareAndSetTail方法也是调用Unsafe类实现CAS操作，更新队尾。</p><h6 id="1-3-enq-Node"><a href="#1-3-enq-Node" class="headerlink" title="1.3 enq(Node)"></a>1.3 enq(Node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// CAS自旋，直到插入成功</span><br>        Node t = tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 队尾为空，则先初始化队列，new一个虚拟节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                tail = head; <span class="hljs-comment">// 头尾指针都指向傀儡节点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 插入队尾</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码CAS自旋volatile变量，也是AtomicInteger、AtomicBoolean等原子量的灵魂。</p><h6 id="1-4-acquireQueued-Node-int"><a href="#1-4-acquireQueued-Node-int" class="headerlink" title="1.4 acquireQueued(Node, int)"></a>1.4 acquireQueued(Node, int)</h6><p>通过tryAcquire()和addWaiter()，如果线程获取资源失败，已经被放入等待队列尾部了。但是，后面还有一项重要的事没干，就是让线程进入阻塞状态，直到其他线程释放资源后唤醒自己。过程跟在银行办理业务时排队拿号有点相似，acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 是否获取到了资源</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 等待过程中有没有被中断</span><br>        <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 自旋，直到</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 前驱是head，则有资格去尝试获取资源</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 获取资源成功，将自己置为队头，并回收其前驱（旧的队头）</span><br>                setHead(node);<br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 获取资源失败，</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>如果获取资源失败后，会调用两个函数，shouldParkAfterFailedAcquire和parkAndCheckInterrupt，下面来看看它俩是干什么的。</p><h6 id="1-5-shouldParkAfterFailedAcquire-Node-Node"><a href="#1-5-shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="1.5 shouldParkAfterFailedAcquire(Node, Node)"></a>1.5 shouldParkAfterFailedAcquire(Node, Node)</h6><p>该函数的作用是“在获取资源失败后是否需要阻塞”：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus; <span class="hljs-comment">// 前驱状态</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">// Node.SIGNAL，代表前驱释放资源后会通知后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 代表前驱已取消任务，相当于退出了等待队列</span><br>        <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// 一个个往前找，找到最近一个正常等待的前驱，排在它的后面</span><br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 前驱状态正常，则将其状态置为SIGNAL，意为，释放资源后通知后继结点</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>整个流程中，如果前驱节点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><h6 id="1-6-parkAndCheckInterrupt"><a href="#1-6-parkAndCheckInterrupt" class="headerlink" title="1.6 parkAndCheckInterrupt()"></a>1.6 parkAndCheckInterrupt()</h6><p>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 使线程进入waiting状态</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><br>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：被unpark()或被interrupt()。</p><h6 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h6><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h5 id="2-release-int"><a href="#2-release-int" class="headerlink" title="2. release(int)"></a>2. release(int)</h5><p>release()是acquire()的逆操作，是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 状态不为0，证明需要唤醒后继结点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="2-1-tryRelease-int"><a href="#2-1-tryRelease-int" class="headerlink" title="2.1 tryRelease(int)"></a>2.1 tryRelease(int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可，也不需要考虑线程安全的问题。</p><h6 id="2-2-unparkSuccessor-Node"><a href="#2-2-unparkSuccessor-Node" class="headerlink" title="2.2 unparkSuccessor(Node)"></a>2.2 unparkSuccessor(Node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 将当前结点状态置零</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <br>    Node s = node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 后继结点为空或者已取消</span><br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 从队尾开始向前寻找，找到第一个正常的后继结点</span><br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        LockSupport.unpark(s.thread); <span class="hljs-comment">// 唤醒该结点上的线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程。</p><h5 id="3-acquireShared-int"><a href="#3-acquireShared-int" class="headerlink" title="3. acquireShared(int)"></a>3. acquireShared(int)</h5><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>    doAcquireShared(arg);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123; <span class="hljs-comment">// 留给子类实现</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><br>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</p><h6 id="3-1-doAcquireShared-int"><a href="#3-1-doAcquireShared-int" class="headerlink" title="3.1 doAcquireShared(int)"></a>3.1 doAcquireShared(int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="hljs-comment">// 以共享模式加入队尾</span><br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123; <span class="hljs-comment">// 前驱是队头（队头肯定是已经拿到资源的结点）</span><br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg); <span class="hljs-comment">// 尝试获取资源</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 获取资源成功</span><br>                    setHeadAndPropagate(node, r); <span class="hljs-comment">// 将自己置为队头，若还有剩余资源，向后传播</span><br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt(); <span class="hljs-comment">// 如果等待过程中被打断过，此时将中断补上。</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 判断状态，寻找合适的前驱，进入waiting状态，等着被unpark()或interrupt()</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的功能类似于独占模式下的acquireQueued()。</p><p>跟独占模式比，有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。因为老大先唤醒老二，老二一看资源不够自己用继续park()，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。</p><h6 id="3-2-setHeadAndPropagate-Node-int"><a href="#3-2-setHeadAndPropagate-Node-int" class="headerlink" title="3.2 setHeadAndPropagate(Node, int)"></a>3.2 setHeadAndPropagate(Node, int)</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    Node h = head;<br>    setHead(node); <span class="hljs-comment">// 将自己置为队头</span><br>    <br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) <span class="hljs-comment">// 后继结点也为共享模式，则触发释放资源函数</span><br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继节点，毕竟是共享模式。</p><h5 id="4-releaseShared-int"><a href="#4-releaseShared-int" class="headerlink" title="4. releaseShared(int)"></a>4. releaseShared(int)</h5><p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="hljs-comment">// 尝试释放资源</span><br>        doReleaseShared(); <span class="hljs-comment">// 释放成功，继续唤醒后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123; <span class="hljs-comment">// 留给子类实现</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><br>跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于可重入的考量；而共享模式下的releaseShared()则没有这种要求，多线程可并发执行，不适用于可重入。</p><h6 id="4-1-doReleaseShared"><a href="#4-1-doReleaseShared" class="headerlink" title="4.1 doReleaseShared()"></a>4.1 doReleaseShared()</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123; <span class="hljs-comment">// 头结点不为空且有后继结点</span><br>            <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>)) <span class="hljs-comment">// 头结点状态，SIGNAL——&gt;0</span><br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 状态更新失败则循环进行，直到成功</span><br>                unparkSuccessor(h); <span class="hljs-comment">// 唤醒后继结点</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-comment">// 头结点状态，0——&gt;PROPAGATE</span><br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 持续循环，直到状态更新成功</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// 头结点没变，则结束循环；否则继续</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，AQS的独占模式与共享模式下的实现原理剖析的差不多了。</p><h4 id="5-1-3-2-可重写的方法"><a href="#5-1-3-2-可重写的方法" class="headerlink" title="5.1.3.2 可重写的方法"></a>5.1.3.2 可重写的方法</h4><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。<br>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，成功则返回true，失败则返回false。</li></ul><p>初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。<br>任务分为N个子线程去执行，也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="5-2-为什么AQS框架底层使用CLH队列结构作为基础"><a href="#5-2-为什么AQS框架底层使用CLH队列结构作为基础" class="headerlink" title="5.2 为什么AQS框架底层使用CLH队列结构作为基础"></a>5.2 为什么AQS框架底层使用CLH队列结构作为基础</h2><p>由于AQS中需要让大量并发争用锁的线程频繁的被阻塞和唤醒，出于性能的考虑，为避免过多的线程上下文切换，AQS本身没有再利用操作系统底层提供的线程阻塞/唤醒机制通过互斥锁来保证同步队列的并发安全，而是使用基于CAS的乐观重试机制来构造一个无锁，并发安全的同步队列。<br>AQS作为一个通用的同步器框架，是需要支持超时、中断等取消加锁的，而前面提到基础版的CLH锁和MCS锁都存在一个缺陷，即无法很好的支持超时、中断等取消加锁的场景。<br>引入了显式前驱节点引用的CLH锁比起MCS锁可以更加简单的实现超时、中断等加锁过程中临时退出加锁的场景。而由于AQS中的线程在征用锁失败时不会占用CPU一直自旋等待，而是被设置为阻塞态让出CPU（LockSupport.park），因此MCS锁在NUMA架构下性能略高的优点也就不是那么重要了。</p><h2 id="5-3-一些锁"><a href="#5-3-一些锁" class="headerlink" title="5.3 一些锁"></a>5.3 一些锁</h2><h3 id="5-3-1-ReentrantLock"><a href="#5-3-1-ReentrantLock" class="headerlink" title="5.3.1 ReentrantLock"></a>5.3.1 ReentrantLock</h3><h4 id="5-3-1-1-公平和非公平锁"><a href="#5-3-1-1-公平和非公平锁" class="headerlink" title="5.3.1.1 公平和非公平锁"></a>5.3.1.1 公平和非公平锁</h4><p>Reentrantlock 可以是公平锁，也可以是非公平锁。<br>ReentrantLock 的构造函数中，默认的无参构造函数将会把Sync对象创建为 NonfairSync 对象，这是一个”非公平锁”; 而另一个构造函数ReentrantLock(boolean fair) 传入参数为 true 时将会把 Sync 对象创建为”公平锁”FairSync。</p><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">ReentrantLock()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NonfairSync()</span>;<br>&#125;<br><br>public <span class="hljs-constructor">ReentrantLock(<span class="hljs-params">boolean</span> <span class="hljs-params">fair</span>)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-constructor">FairSync()</span> : <span class="hljs-keyword">new</span> <span class="hljs-constructor">NonfairSync()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁中<code>tryAcquire</code>方法直接调用<code>nonfairTryAcquire(int acquires)</code>方法，对于非公平锁只要 CAS 设置同步状态成功，则表示当前线程获取了锁。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">final boolean nonfair<span class="hljs-constructor">TryAcquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>    final Thread current = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 通过自旋获取锁</span><br>        <span class="hljs-keyword">if</span> (compare<span class="hljs-constructor">AndSetState(0, <span class="hljs-params">acquires</span>)</span>) &#123;<br>            set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">current</span>)</span>;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 重入锁判断</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current<span class="hljs-operator"> == </span>get<span class="hljs-constructor">ExclusiveOwnerThread()</span>) &#123;<br>        <span class="hljs-built_in">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>)</span>;<br>        set<span class="hljs-constructor">State(<span class="hljs-params">nextc</span>)</span>;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>而公平锁则不同，<code>tryAcquire</code>方法进行了重写。唯一不同的位置为判断条件多了 <code>hasQueuedPredecessors()</code>，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>    final Thread current = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 获取锁逻辑</span><br>        <span class="hljs-keyword">if</span> (!has<span class="hljs-constructor">QueuedPredecessors()</span> &amp;&amp;<br>            compare<span class="hljs-constructor">AndSetState(0, <span class="hljs-params">acquires</span>)</span>) &#123;<br>            set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">current</span>)</span>;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 重入锁判断</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current<span class="hljs-operator"> == </span>get<span class="hljs-constructor">ExclusiveOwnerThread()</span>) &#123;<br>        <span class="hljs-built_in">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>)</span>;<br>        set<span class="hljs-constructor">State(<span class="hljs-params">nextc</span>)</span>;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>而这里的核心<code>hasQueuedPredecessors()</code>就是公平锁的核心，根据他可以了解为链表方式判断，即AQS或者CLH逻辑、即谁先排队而不是自旋。</p><h4 id="5-3-1-2-可重入"><a href="#5-3-1-2-可重入" class="headerlink" title="5.3.1.2 可重入"></a>5.3.1.2 可重入</h4><p>重进入是指任意线程在获取到锁之后，能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决两个问题：</p><ul><li>线程再次获取锁 ：锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li><li>锁的最终释放 ： 线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">final boolean nonfair<span class="hljs-constructor">TryAcquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>    final Thread current = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compare<span class="hljs-constructor">AndSetState(0, <span class="hljs-params">acquires</span>)</span>) &#123;<br>            set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">current</span>)</span>;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 可重入判断</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current<span class="hljs-operator"> == </span>get<span class="hljs-constructor">ExclusiveOwnerThread()</span>) &#123;<br>        <span class="hljs-built_in">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>)</span>;<br>        set<span class="hljs-constructor">State(<span class="hljs-params">nextc</span>)</span>;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看到这里判断是否为当前线程位置。通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。</p><p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回 false，而只有同步状态完全释放了，才能返回true。该方法将同步状态是否为 0 作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Release(<span class="hljs-params">int</span> <span class="hljs-params">releases</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span> - releases;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> != get<span class="hljs-constructor">ExclusiveOwnerThread()</span>)<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalMonitorStateException()</span>;<br>    boolean free = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">null</span>)</span>;<br>    &#125;<br>    set<span class="hljs-constructor">State(<span class="hljs-params">c</span>)</span>;<br>    return free;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="5-3-2-CountDownLatch"><a href="#5-3-2-CountDownLatch" class="headerlink" title="5.3.2 CountDownLatch"></a>5.3.2 CountDownLatch</h3><p>可以设置一个计数器，然后通过countDown方法来进行减1的操作，使用await方法等待计数器不大于0，然后继续执行await方法之后的语句。</p><ul><li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞</li><li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)</li><li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行</li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br><br>    <span class="hljs-comment">//创建CountDownLatch</span><br>    CountDownLatch countDownLatch=<span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(6)</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread( )</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;解锁&quot;</span>);<br>            countDownLatch.count<span class="hljs-constructor">Down()</span>;<br>        &#125;,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br>    <span class="hljs-comment">//等待</span><br>    countDownLatch.await<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread( )</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;全部解锁&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-CyclicBarrier"><a href="#5-3-3-CyclicBarrier" class="headerlink" title="5.3.3 CyclicBarrier"></a>5.3.3 CyclicBarrier</h3><p>允许一组线程全部等待彼此达到共同屏障点的同步辅助。循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    <span class="hljs-built_in">int</span> num = <span class="hljs-number">3</span>;<br>    CyclicBarrier cyclicBarrier=<span class="hljs-keyword">new</span> <span class="hljs-constructor">CyclicBarrier(<span class="hljs-params">num</span>,()</span>-&gt;&#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(num+<span class="hljs-string">&quot;已加载完成&quot;</span>);<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">7</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;完成&quot;</span>);<br>                <span class="hljs-comment">//等待</span><br>                cyclicBarrier.await<span class="hljs-literal">()</span>;<br>            &#125; catch (Exception e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>        &#125;,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="5-3-4-Semaphore"><a href="#5-3-4-Semaphore" class="headerlink" title="5.3.4 Semaphore"></a>5.3.4 Semaphore</h3><p>类似一个生产者消费者模型，更像一个占位模型，提供了n个空间给线程抢占，当达到了上限n时，就阻塞，直到空间被释放。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br>    Semaphore semaphore=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Semaphore(3)</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//抢占</span><br>                semaphore.acquire<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;抢到了&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>.next<span class="hljs-constructor">Int(5)</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;finally &#123;<br>                <span class="hljs-comment">// 释放</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;离开了&quot;</span>);<br>                semaphore.release<span class="hljs-literal">()</span>;<br>            &#125;<br>        &#125;, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="六、乐观锁和悲观锁"><a href="#六、乐观锁和悲观锁" class="headerlink" title="六、乐观锁和悲观锁"></a>六、乐观锁和悲观锁</h2><p>Java中，<code>synchronized关键字</code>和<code>Lock的实现类</code>都是悲观锁。悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 悲观锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    lock.lock();<br>    <span class="hljs-comment">// 同步数据</span><br>    lock.unlock();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 同步数据</span><br>&#125;<br><br><span class="hljs-comment">// 乐观锁</span><br><span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>atomicInteger.incrementAndGet();<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java锁</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中的CAS操作</title>
    <link href="http://example.com/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/"/>
    <id>http://example.com/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/</id>
    <published>2023-03-15T22:01:12.000Z</published>
    <updated>2023-04-25T06:15:18.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是CAS"><a href="#一、什么是CAS" class="headerlink" title="一、什么是CAS"></a>一、什么是CAS</h2><p>Compare And Swap的缩写，中文翻译成比较并交换。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><h2 id="二、引出CAS"><a href="#二、引出CAS" class="headerlink" title="二、引出CAS"></a>二、引出CAS</h2><p>看看下面代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> COUNT = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(COUNT);<br><br>    <span class="hljs-keyword">final</span> Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                count++;<br>                atomicInteger.getAndIncrement();<br>            &#125;<br>            latch.countDown();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; COUNT; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(runnable).start();<br>    &#125;<br>    latch.await();<br>    System.out.println(<span class="hljs-string">&quot;理论结果：&quot;</span> + <span class="hljs-number">1000</span>*COUNT);<br>    System.out.println(<span class="hljs-string">&quot;count:&quot;</span> + count);<br>    System.out.println(<span class="hljs-string">&quot;atomic:&quot;</span> + atomicInteger.intValue());<br>&#125;<br></code></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">理论结果：<span class="hljs-number">10000</span><br>count:<span class="hljs-number">9997</span><br>atomic:<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><br>多次允许后发现，count的结果永远不正确，而atomic的数据永远是正确的。</p><h2 id="三、Atomic"><a href="#三、Atomic" class="headerlink" title="三、Atomic"></a>三、Atomic</h2><p>根据操作的目标数据类型</p><ul><li>基本原子类</li><li>数组原子类</li><li>原子引用类型</li><li>字段更新原子类</li></ul><h2 id="3-1-基本原子类"><a href="#3-1-基本原子类" class="headerlink" title="3.1 基本原子类"></a>3.1 基本原子类</h2><p>基本原子类的功能，是通过原子方式更新 Java 基础类型变量的值。基本原子类主要包括了以下三个：</p><ul><li>AtomicInteger：整型原子类。</li><li>AtomicLong：长整型原子类。 </li><li>AtomicBoolean ：布尔型原子类。</li></ul><h2 id="3-2-数组原子类"><a href="#3-2-数组原子类" class="headerlink" title="3.2 数组原子类"></a>3.2 数组原子类</h2><p>数组原子类的功能，是通过原子方式更数组里的某个元素的值。数组原子类主要包括了以下三个：</p><ul><li>AtomicIntegerArray：整型数组原子类。</li><li>AtomicLongArray：长整型数组原子类。</li><li>AtomicReferenceArray ：引用类型数组原子类。</li></ul><h2 id="3-3-原子引用类型"><a href="#3-3-原子引用类型" class="headerlink" title="3.3 原子引用类型"></a>3.3 原子引用类型</h2><p>引用原子类主要包括了以下三个：</p><ul><li>AtomicReference：引用类型原子类。</li><li>AtomicMarkableReference ：带有更新标记位的原子引用类型。</li><li>AtomicStampedReference ：带有更新版本号的原子引用类型。<br><strong><em>AtomicStampedReference通过引入“版本”的概念，来解决ABA的问题。</em></strong></li></ul><h2 id="3-4-字段更新原子类"><a href="#3-4-字段更新原子类" class="headerlink" title="3.4 字段更新原子类"></a>3.4 字段更新原子类</h2><p>字段更新原子类主要包括了以下三个：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器。 </li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li></ul><h2 id="3-5-基本函数"><a href="#3-5-基本函数" class="headerlink" title="3.5 基本函数"></a>3.5 基本函数</h2><div class="table-container"><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取当前的值</td></tr><tr><td>public final int getAndSet(int newValue)</td><td>获取当前的值，然后设置新的值</td></tr><tr><td>public final int getAndIncrement()</td><td>获取当前的值，然后自增</td></tr><tr><td>public final int getAndDecrement()</td><td>获取当前的值，然后自减</td></tr><tr><td>public final int getAndAdd(int delta)</td><td>获取当前的值，并加上预期的值</td></tr><tr><td>boolean compareAndSet(int expect, int update)</td><td>通过 CAS 方式设置整数值</td></tr></tbody></table></div><h2 id="3-6-Unsafe类"><a href="#3-6-Unsafe类" class="headerlink" title="3.6 Unsafe类"></a>3.6 Unsafe类</h2><p>Unsafe 提供了CAS 方法，直接通过native 方式（封装 C++代码）调用了底层的 CPU 指令 cmpxchg。从名字中我们可以看出来这个类对普通程序员来说是“危险”的，一般应用开发者不会用到这个类。</p><h3 id="3-6-1-Unsafe-提供的-CAS-方法"><a href="#3-6-1-Unsafe-提供的-CAS-方法" class="headerlink" title="3.6.1 Unsafe 提供的 CAS 方法"></a>3.6.1 Unsafe 提供的 CAS 方法</h3><p>主要如下： 定义在 Unsafe 类中的三个 “比较并交换”原子方法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@param o 包含要修改的字段的对象</span><br><span class="hljs-comment">@param offset 字段在对象内的偏移量</span><br><span class="hljs-comment">@param expected 期望值（旧的值）</span><br><span class="hljs-comment">@param update 更新值（新的值）</span><br><span class="hljs-comment">@return true 更新成功 | false 更新失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object expected, Object update)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">( Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> update)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">( Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">long</span> expected, <span class="hljs-keyword">long</span> update)</span></span>;<br></code></pre></td></tr></table></figure><br>Unsafe 提供的 CAS 方法包含四个入参： 包含要修改的字段对象、字段内存位置、预期原值及新值。<br>在执行 Unsafe 的 CAS 方法的时候，这些方法首先将内存位置的值与预期值（旧的值）比较，如果相匹配，那么处理器会自动将该内存位置的值更新为新值，并返回 true ；如果不相匹配，处理器不做任何操作，并返回 false 。<br><img src="/img/CAS/1.png" alt="github"><br>CAS操作由处理器提供支持，是一种原语。原语是操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。如 Intel 处理器，比较并交换通过指令的 cmpxchg 系列实现。</p><h3 id="3-6-2-获取属性偏移量"><a href="#3-6-2-获取属性偏移量" class="headerlink" title="3.6.2 获取属性偏移量"></a>3.6.2 获取属性偏移量</h3><p>Unsafe 提供的获取字段（属性）偏移量的相关操作，主要如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> o 需要操作属性的反射 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 属性的偏移量 </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">staticFieldOffset</span><span class="hljs-params">(Field field)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field field)</span></span>;<br></code></pre></td></tr></table></figure></p><ul><li>staticFieldOffset 方法用于获取静态属性 Field 在 Class 对象中的偏移量，在 CAS 操作静态属性时，会用到这个偏移量。</li><li>objectFieldOffset 方法用于获取非静态 Field （非静态属性）在 Object 实例中的偏移量，在 CAS 操作对象的非静态属性时，会用到这个偏移量。</li></ul><h3 id="3-6-3-根据属性的偏移量获取属性的最新值"><a href="#3-6-3-根据属性的偏移量获取属性的最新值" class="headerlink" title="3.6.3 根据属性的偏移量获取属性的最新值:"></a>3.6.3 根据属性的偏移量获取属性的最新值:</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> o 字段所属于的对象实例</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> fieldOffset 字段的偏移量 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 字段的最新值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> fieldOffset)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="四、CAS的缺点"><a href="#四、CAS的缺点" class="headerlink" title="四、CAS的缺点"></a>四、CAS的缺点</h2><h2 id="4-1-ABA问题"><a href="#4-1-ABA问题" class="headerlink" title="4.1  ABA问题"></a>4.1  ABA问题</h2><p>一个线程先读取共享内存数据值A，随后因某种原因，线程暂时挂起，同时另一个线程临时将共享内存数据值先改为B，随后又改回为A。随后挂起线程恢复，并通过CAS比较，最终比较结果将会无变化。这样会通过检查，这就是ABA问题。<br>JDK 提供了两个类 AtomicStampedReference、AtomicMarkableReference 来解决 ABA 问题。</p><h2 id="4-2-只能保证一个共享变量的原子操作"><a href="#4-2-只能保证一个共享变量的原子操作" class="headerlink" title="4.2 只能保证一个共享变量的原子操作"></a>4.2 只能保证一个共享变量的原子操作</h2><p>一个比较简单的规避方法为：把多个共享变量合并成一个共享变量来操作。 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，可以把多个变量放在一个 AtomicReference 实例后再进行 CAS 操作。比如有两个共享变量 i＝1、j=2，可以将二者合并成一个对象，然后用 CAS 来操作该合并对象的 AtomicReference 引用。</p><h2 id="4-3-循环时间长开销大"><a href="#4-3-循环时间长开销大" class="headerlink" title="4.3 循环时间长开销大"></a>4.3 循环时间长开销大</h2><p>高并发下N多线程同时去操作一个变量，会造成大量线程CAS失败，然后处于自旋状态，导致严重浪费CPU资源，降低了并发性。</p><h4 id="解决-CAS-恶性空自旋的较为常见的方案为："><a href="#解决-CAS-恶性空自旋的较为常见的方案为：" class="headerlink" title="解决 CAS 恶性空自旋的较为常见的方案为："></a>解决 CAS 恶性空自旋的较为常见的方案为：</h4><ul><li>分散操作热点，使用 LongAdder 替代基础原子类 AtomicLong。</li><li>使用队列削峰，将发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度。JUC 中非常重要的基础类 AQS（抽象队列同步器）就是这么做的。</li></ul><h2 id="五、以空间换时间：LongAdder"><a href="#五、以空间换时间：LongAdder" class="headerlink" title="五、以空间换时间：LongAdder  "></a>五、以空间换时间：LongAdder  </h2><h2 id="5-1-LongAdder-DoubleAdder-的原理"><a href="#5-1-LongAdder-DoubleAdder-的原理" class="headerlink" title="5.1 LongAdder(DoubleAdder) 的原理"></a>5.1 LongAdder(DoubleAdder) 的原理</h2><p>LongAdder 的基本思路就是分散热点， 如果有竞争的话，内部维护了多个Cell变量，每个Cell里面有一个初始值为0的long型变量， 不同线程会命中到数组的不同Cell （槽 ）中，各个线程只对自己Cell（槽） 中的那个值进行 CAS 操作。这样热点就被分散了，冲突的概率就小很多。<br>在没有竞争的情况下，要累加的数通过 CAS 累加到 base 上。<br>如果要获得完整的 LongAdder 存储的值，只要将各个槽中的变量值累加，后的值即可。<br><img src="/img/CAS/0.png" alt="github"></p><h2 id="5-2-longAddr内部结构"><a href="#5-2-longAddr内部结构" class="headerlink" title="5.2 longAddr内部结构"></a>5.2 longAddr内部结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">|-----------|<br>| Striped64 |       |------------|<br>|___________|       |Serializable|<br>      ^             |____________|<br>      |                    ^<br>      |                    |<br>|-----------|              |<br>| LongAdder |--------------|<br>|___________|<br></code></pre></td></tr></table></figure><h3 id="5-2-1-Striped64类的重要成员属性"><a href="#5-2-1-Striped64类的重要成员属性" class="headerlink" title="5.2.1 Striped64类的重要成员属性"></a>5.2.1 Striped64类的重要成员属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cell表，当非空时，大小是2的幂。  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基础值，主要在没有争用时使用</span><br><span class="hljs-comment"> * 在没有争用时使用CAS更新这个值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自旋锁(通过CAS锁定) 在调整大小和或创建cell时使用,</span><br><span class="hljs-comment"> * 为 0 表示 cells 数组没有处于创建、扩容阶段,反之为1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p>内部包含一个 base 和一个 Cell[] 类型的 cells 数组 。 在没有竞争的情况下，要累加的数通过 CAS 累加到 base 上；如果有竞争的话，会将要累加的数累加到 Cells 数组中的某个 cell 元素里面。所以 Striped64 的整体值 value 为 base+ ∑ [0~n]cells 。</p><h3 id="5-2-2-LongAdder的整体值-value-的获取源码"><a href="#5-2-2-LongAdder的整体值-value-的获取源码" class="headerlink" title="5.2.2 LongAdder的整体值 value 的获取源码"></a>5.2.2 LongAdder的整体值 value 的获取源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">longValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sum();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Striped64.Cell[] as = cells;<br>    Striped64.Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>triped64 的设计核心思路就是通过内部的分散计算来避免竞争，以空间换时间。 LongAdder<br>的 base 类似于 AtomicInteger 里面的 value ，在没有竞争的情况，cells 数组为 null ，这时只使用 base 做累加；而一旦发生竞争，cells 数组就上场了。<br>cells 数组第一次初始化长度为 2 ，以后每次扩容都是变为原来的两倍，一直到 cells 数组的长<br>度大于等于当前服务器 CPU 的核数。为什么呢？同一时刻，能持有 CPU 时间片而去并发操作同<br>一个内存地址的最大线程数，最多也就是 CPU 的核数。<br>在存在线程争用的时候，每个线程被映射到 cells[threadLocalRandomProbe &amp; cells.length] 位置的 Cell 元素，该线程对 value 所做的累加操作，就执行在对应的 Cell 元素的值上，最终相当于将线程绑定到了 cells 中的某个 cell 对象上。</p><h2 id="5-3-LongAdder-类的-add-方法"><a href="#5-3-LongAdder-类的-add-方法" class="headerlink" title="5.3 LongAdder 类的 add 方法"></a>5.3 LongAdder 类的 add 方法</h2><h3 id="5-3-1-自增"><a href="#5-3-1-自增" class="headerlink" title="5.3.1 自增"></a>5.3.1 自增</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-自减"><a href="#5-3-2-自减" class="headerlink" title="5.3.2 自减"></a>5.3.2 自减</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>    add(-<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-add方法"><a href="#5-3-3-add方法" class="headerlink" title="5.3.3 add方法"></a>5.3.3 add方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//as: 表示cells引用</span><br>    <span class="hljs-comment">//b: base值</span><br>    <span class="hljs-comment">//v: 表示当前线程命中的cell的期望值</span><br>    <span class="hljs-comment">//m: 表示cells数组长度</span><br>    <span class="hljs-comment">//a: 表示当前线程命中的cell</span><br>    Striped64.Cell[] as;<br>    <span class="hljs-keyword">long</span> b, v;<br>    <span class="hljs-keyword">int</span> m;<br>    Striped64.Cell a;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    stop 1：true -&gt; 说明存在竞争，并且cells数组已经初始化了，当前线程需要将数据写入到对应的cell中</span><br><span class="hljs-comment">           false -&gt; 表示cells未初始化，当前所有线程应该将数据写到base中</span><br><span class="hljs-comment">    stop 2：true -&gt; 表示发生竞争了，可能需要重试或者扩容</span><br><span class="hljs-comment">           false -&gt; 表示当前线程cas替换数据成功</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (<br>            (as = cells) != <span class="hljs-keyword">null</span>  <span class="hljs-comment">//stop 1</span><br>            ||<br>            !casBase(b = base, b + x) <span class="hljs-comment">//stop 2</span><br>    ) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        进入的条件：</span><br><span class="hljs-comment">        1.cells数组已经初始化了，当前线程需要将数据写入到对应的cell中</span><br><span class="hljs-comment">        2.表示发生竞争了，可能需要重试或者扩容</span><br><span class="hljs-comment">        */</span><br> <br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">        是否有竞争：true -&gt; 没有竞争</span><br><span class="hljs-comment">                   false -&gt; 有竞争*/</span><br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        stop 3：as == null || (m = as.length - 1)&lt;0 代表 cells 没有初始化</span><br><span class="hljs-comment">        stop 4：表示当前线程命中的cell为空，意思是还没有其他线程在同一个位置做过累加操作。</span><br><span class="hljs-comment">        stop 5：表示当前线程命中的cell不为空， 然后在该Cell对象上进行CAS设置其值为v+x（x为该 Cell 需要累加的值），如果CAS操作失败，表示存在争用。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> || <span class="hljs-comment">//stop 3</span><br>                (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> || <span class="hljs-comment">//stop 4</span><br>                !(uncontended = a.cas(v = a.value, v + x))) <span class="hljs-comment">//stop 5</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            进入的条件：</span><br><span class="hljs-comment">            1.cells 未初始化</span><br><span class="hljs-comment">            2.当前线程对应下标的cell为空</span><br><span class="hljs-comment">            3.当前线程对应的cell有竞争并且cas失败</span><br><span class="hljs-comment">            */</span><br>            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CAS/2.png" alt="github"></p><h3 id="5-3-4-longAccumulate方法"><a href="#5-3-4-longAccumulate方法" class="headerlink" title="5.3.4 longAccumulate方法"></a>5.3.4 longAccumulate方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//条件成立: 说明当前线程还未分配hash值</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1.给当前线程分配hash值</span><br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        <span class="hljs-comment">//2.提取当前线程的hash值</span><br>        h = getProbe();<br>        <span class="hljs-comment">//3.因为上一步提取了重新分配的新的hash值，所以会重新分配cells数组的位置给当前线程写入，先假设它能找到一个元素不冲突的数组下标。</span><br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//扩容意向，collide=true 可以扩容，collide=false 不可扩容</span><br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-comment">//自旋，一直到操作成功</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//as: 表示cells引用</span><br>        <span class="hljs-comment">//a: 当前线程命中的cell</span><br>        <span class="hljs-comment">//n: cells数组长度</span><br>        <span class="hljs-comment">//a: 表示当前线程命中的cell的期望值</span><br>        Striped64.Cell[] as; Striped64.Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//CASE1: cells数组已经初始化了，当前线程将数据写入到对应的cell中</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//CASE1.1: true 表示下标位置的 cell 为 null，需要创建 new Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// cells 数组没有处于创建、扩容阶段</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    Striped64.Cell r = <span class="hljs-keyword">new</span> Striped64.Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-comment">// cas去加锁</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Striped64.Cell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">// 再次判断cells不为空 &amp; 槽位为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                    (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                    rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                rs[j] = r;<br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<span class="hljs-comment">//创建、扩容成功，退出自旋</span><br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// CASE1.2：当前线程竞争修改cell失败</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">// CASE 1.3：当前线程 rehash 过 hash 值,CAS 更新 Cell</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                    fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// CASE1.4:判断是否可以扩容</span><br>            <span class="hljs-comment">//  CASE1.4.1：n &gt;= NCPU</span><br>            <span class="hljs-comment">//      true -&gt; cells数组长度已经 &gt;= cpu核数，不可进行扩容，把扩容意向改为false</span><br>            <span class="hljs-comment">//      false -&gt; 可扩容</span><br>            <span class="hljs-comment">//  CASE1.4.2：cells != as</span><br>            <span class="hljs-comment">//      true -&gt; 其它线程已经扩容过了，当前线程rehash之后重试即可</span><br>            <span class="hljs-comment">//      false -&gt; 未有线程对cells进行修改</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 把扩容意向改为false</span><br>            <span class="hljs-comment">// CASE 1.5:设置扩容意向为 true，但是不一定真的发生扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//CASE1.6:真正扩容的逻辑</span><br>            <span class="hljs-comment">//  CASE1.6.1：cellsBusy == 0</span><br>            <span class="hljs-comment">//      true -&gt; 表示cells没有被其它线程占用，当前线程可以去竞争锁</span><br>            <span class="hljs-comment">//      false -&gt; 表示有其它线程正在操作cells</span><br>            <span class="hljs-comment">//  CASE1.6.2：casCellsBusy()</span><br>            <span class="hljs-comment">//      true -&gt; 表示当前线程获取锁成功，可以进行扩容操作</span><br>            <span class="hljs-comment">//      false -&gt; 表示当前线程获取锁失败，当前时刻有其它线程在做扩容相关的操作</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//重复判断一下当前线程的临时cells数组是否与原cells数组一致(防止有其它线程提前修改了cells数组，因为cells是volatile的全局变量)</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        <span class="hljs-comment">//n &lt;&lt; 1 表示数组长度翻一倍</span><br>                        Striped64.Cell[] rs = <span class="hljs-keyword">new</span> Striped64.Cell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//扩容后，将扩容意向置为false</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            <span class="hljs-comment">//重置当前线程hash值</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//CASE2：cells 还未初始化（as 为 null）,并且 cellsBusy 加锁成功</span><br>        <span class="hljs-comment">//  CASE2.1：判断锁是否被占用</span><br>        <span class="hljs-comment">//         true -&gt; 表示当前未加锁</span><br>        <span class="hljs-comment">//         false -&gt; 表示当前已加锁</span><br>        <span class="hljs-comment">//  CASE2.2：因为其它线程可能会在当前线程给as赋值之后修改了cells</span><br>        <span class="hljs-comment">//         true -&gt; cells没有被其它线程修改</span><br>        <span class="hljs-comment">//         false -&gt; cells已经被其它线程修改</span><br>        <span class="hljs-comment">// CASE2.3：获取锁</span><br>        <span class="hljs-comment">//         true -&gt; 获取锁成功 会把cellsBusy = 1</span><br>        <span class="hljs-comment">//         false -&gt; 表示其它线程正在持有这把锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//双重检查，防止其它线程已经初始化，当前线程再次初始化，会导致数据丢失</span><br>                <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    Striped64.Cell[] rs = <span class="hljs-keyword">new</span> Striped64.Cell[<span class="hljs-number">2</span>];<br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Striped64.Cell(x);<br>                    cells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//CASE3：当前线程 cellsBusy 加锁失败，表示其他线程正在初始化 cells</span><br>        <span class="hljs-comment">//所以当前线程将值累加到 base，注意 add(…)方法调用此方法时 fn 为 null</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CAS/3.png" alt="github"></p><h3 id="5-3-5-LongAdder-类的-casCellsBusy-方法"><a href="#5-3-5-LongAdder-类的-casCellsBusy-方法" class="headerlink" title="5.3.5 LongAdder 类的 casCellsBusy 方法"></a>5.3.5 LongAdder 类的 casCellsBusy 方法</h3><p>casCellsBusy 方法的代码很简单，就是将 cellsBusy 成员的值改为 1 ，表示目前的 cells 数组在初始化或扩容中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">casCellsBusy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="5-3-6-求和"><a href="#5-3-6-求和" class="headerlink" title="5.3.6 求和"></a>5.3.6 求和</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sum()方法很简单，就是将base值及所有cell值进行累加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、使用-AtomicStampedReference-解决-ABA-问题"><a href="#六、使用-AtomicStampedReference-解决-ABA-问题" class="headerlink" title="六、使用 AtomicStampedReference 解决 ABA 问题"></a>六、使用 AtomicStampedReference 解决 ABA 问题</h2><p>JDK 的提供了一个类似 AtomicStampedReference 类来解决 ABA 问题。<br>AtomicStampReference 在 CAS 的基础上增加了一个 Stamp 整型 印戳（或标记），使用这个印戳可以来觉察数据是否发生变化，给数据带上了一种实效性的检验。<br>AtomicStampReference 的 compareAndSet 方法首先检查当前的对象引用值是否等于预期引用，<br>并且当前印戳（ Stamp ）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳<br>（ Stamp ）标志的值更新为给定的更新值。</p><h2 id="6-1-AtomicStampReference-的构造器"><a href="#6-1-AtomicStampReference-的构造器" class="headerlink" title="6.1 AtomicStampReference 的构造器"></a>6.1 AtomicStampReference 的构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> initialRef初始引用  </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> initialStamp初始戳记  </span><br><span class="hljs-comment">*/</span><br>AtomicStampedReference(V initialRef, <span class="hljs-keyword">int</span> initialStamp)<br></code></pre></td></tr></table></figure><h2 id="6-2-AtomicStampReference-的常用的几个方法"><a href="#6-2-AtomicStampReference-的常用的几个方法" class="headerlink" title="6.2 AtomicStampReference 的常用的几个方法"></a>6.2 AtomicStampReference 的常用的几个方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>介绍                 </th></tr></thead><tbody><tr><td>public V getRerference()</td><td>引用的当前值</td></tr><tr><td>public int getStamp()</td><td>返回当前的”戳记”</td></tr><tr><td>public boolean weakCompareAndSet(V expectedReference,V newReference,int expectedStamp,int newStamp)</td><td>expectedReference 引用的旧值;newReference 引用的新值;expectedStamp 旧的戳记;newStamp 新的戳记  </td></tr></tbody></table></div><h2 id="6-3-例子"><a href="#6-3-例子" class="headerlink" title="6.3 例子"></a>6.3 例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>    AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();<br>    success = atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;success:&quot;</span> + success + <span class="hljs-string">&quot;;reference:&quot;</span> + <span class="hljs-string">&quot;&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;;stamp:&quot;</span> + atomicStampedReference.getStamp());<br>    <span class="hljs-comment">//修改印戳，更新失败</span><br>    stamp = <span class="hljs-number">0</span>;<br>    success = atomicStampedReference.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;success:&quot;</span> + success + <span class="hljs-string">&quot;;reference:&quot;</span> + <span class="hljs-string">&quot;&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;;stamp:&quot;</span> + atomicStampedReference.getStamp());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">java中的CAS操作</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
