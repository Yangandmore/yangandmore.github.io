<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小杨的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-13T14:49:43.920Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-行为型模式的讨论</title>
    <link href="http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/"/>
    <id>http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/</id>
    <published>2023-03-13T22:14:00.000Z</published>
    <updated>2023-03-13T14:49:43.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>封装变化是很多行为模式的主题。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式依据这个对象 来命名。例如，</p><ul><li>一个 Strategy 对象封装一个算法。</li><li>一个 State 对象封装一个与状态相关的行为。</li><li>一个 Mediator对象封装对象间的协。</li><li>一个 Iterator 对象封装访问和遍历一个聚集对象中的各个构件的方法。</li></ul><p>这些模式描述了程序中很可能会改变的方面。大多数模式有两种对象:封装该方面特征的新对象，和使用这些新的对象的已有对象。如果不使用这些模式的话，通常这些新对象的功能就会变成这些已有对象的难以分割的一部分。例如，一个 Strategy 的代码可能会被嵌入到其Context类中，而一个State的代码可能会在该状态的Context类中直接实现。<br>但不是所有的对象行为模式都象这样分割功能 。 例如 ， ChainofResponsibility 可以处理任意数目的对象(即一个链)，而所有这些对象可能已经存在于系统中了。<br>职责链说明了行为模式间的另一个不同点:并非所有的行为模式都定义类之间的静态通信关系。职责链提供在数目可变的对象间进行通信的机制。其他模式涉及到一些作为参数传递的对象。</p><h2 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h2><p>一些模式引入总是被用作参数的对象。例如 Visitor。一个Visitor对象是一个多态的Accept操作的参数 ， 这个操作作用于该Visitor对象访问的对象 。 虽然以前通常代替Visitor模式的方法是将Visitor代码分布在一些对象结构的类中，但visitor从来都不是它所访问的对象的一部分。<br>其他模式定义一些可作为令牌到处传递的对象，这些对象将在稍后被调用。Command和Memento都属于这一类。在Command中，令牌代表一个请求;而在Memento中，它代表在一个对象在某个特定时刻的内部状态。在这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会意识到这一点。但这里还有一些区别:在Command模式中多态很重要，因为执行Command对象是一个多态的操作。相反，Memento接口非常小，以至于备忘录只能作为一个值传递。因此它很可能根本不给它的客户提供任何多态操作。</p><h2 id="通信应该被封装还是被分布"><a href="#通信应该被封装还是被分布" class="headerlink" title="通信应该被封装还是被分布"></a>通信应该被封装还是被分布</h2><p>Mediator和Observer是相互竞争的模式。它们之间的差别是，Observer通过引入Observer和Subject对象来分布通信，而Mediator对象则封装了其他对象间的通信 。<br>在Observer模式中，不存在封装一个约束的单个对象，而必须是由Observer和Subject对象相互协作来维护这个约束。通信模式由观察者和目标连接的方式决定:一个目标通常有多个观察者，并且有时一个目标的观察者也是另一个观察者的目标。Mediator模式的目的是集中而不是分布。它将维护一个约束的职责直接放在一个中介者中。<br>我们发现生成可复用的Observer和Subject比生成可复用的Mediator容易一些。Observer模式有利于Observer和Subject间的分割和松耦合，同时这将产生粒度更细,从而更易于复用的类。<br>另一方面，相对于Observer，Mediator中的通信流更容易理解。观察者和目标通常在它们被创建后很快即被连接起来，并且很难看出此后它们在程序中是如何连接的。如果你了解Observer模式，你将知道观察者和目标间连接的方式是很重要的，并且你也知道寻找哪些连接。然而，Observer模式引入的间接性仍然会使得一个系统难以理解。<br>Smalltalk中的Observer可以用消息进行参数化以访问Subject的状态，因此与在C++中的Observer相比，它们具有更大的可复用性。这使得Smalltalk中Observer比Mediator更具吸引力。 因此一个Smalltalk程序员通常会使用Observer而一个C++程序员则会使用Mediator。</p><h2 id="对发送者和接收者解耦"><a href="#对发送者和接收者解耦" class="headerlink" title="对发送者和接收者解耦"></a>对发送者和接收者解耦</h2><p>当合作的对象直接互相引用时，它们变得互相依赖，这可能会对一个系统的分层和重用 性产生负面影响。命令、观察者、中介者，和职责链等模式都涉及如何对发送者和接收者解 耦，但它们又各有不同的权衡考虑。<br>命令模式使用一个 C o m m a n d 对 象 来 定 义 一 个 发 送 者 和 一 个 接 收 者 之 间 的 绑 定 关 系 ， 从 而 支持解耦，如下图所示。<br><img src="/img/DesignPatterns/26.png" alt="github"><br>C o m m a n d 对 象 提 供 了 一 个 提 交 请 求 的 简 单 接 口 ( 即 E x e c u t e 操作)。 将 发 送 者 和 接 收 者 之 间的连接定义在一个单独的对象使得该发送者可以与不同的接收者一起工作。这就将发送者 与接收者解耦，使发送者更易于复用。此外，可以复用 C o m m a n d 对 象 ， 用 不 同 的 发 送 者 参 数 化一个接收者。虽然 C o m m a n d模 式 描 述 了 避 免 使 用 生 成 子 类 的 实 现 技 术 ， 名 义 上 每 一 个 发 送 者-接收者连接都需要一个子类。<br>观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者(目标)与接收 者(观察者)解耦。 O b s e r v e r 定义了一个比 C o m m a n d 更 松 的 发 送 者 - 接 收 者 绑 定 ， 因 为 一 个 目标可能有多个观察者，并且其数目可以在运行时变化，如下图所示。<br><img src="/img/DesignPatterns/26_1.png" alt="github"><br>观察者模式中的 S u b j e c t 和 O b s e r v e r接口是为了处理 S u b j e c t 的 变 化 而 设 计 的 ， 因 此 当 对 象 间有数据依赖时，最好用观察者模式来对它们进行解耦。<br>中介者模式让对象通过一个 M e d i a t o r对 象 间 接 的 互 相 引 用 ， 从 而 对 它 们 解 耦 ， 如 下 图 所 示 。<br><img src="/img/DesignPatterns/26_2.png" alt="github"><br>一个 M e d i a t o r 对 象 为 各 C o l l e a g u e 对 象 间 的 请 求 提 供 路 由 并 集 中 它 们 的 通 信 。 因 此 各 C o l l e a g u e 对象仅能通过 M e d i a t o r 接口相互交谈。因为这个接口是固定的，为增加灵活性 M e d i a t o r 可能不得不实现它自己的分发策略。可以用一定方式对请求编码并打包参数，使得 C o l l e a g u e 对象可以请求的操作数目不限。<br>中介者模式可以减少一个系统中的子类生成，因为它将通信行为集中到一个类中而不是 将其分布在各个子类中。然而，特别的分发策略通常会降低类型安全性。<br>最后，职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦，如下图所示。<br><img src="/img/DesignPatterns/26_3.png" alt="github"><br>因为发送者和接收者之间的接口是固定的，职责链可能也需要一个定制的分发策略。因 此它与 M e d i a t o r 一 样 存 在 类 型 安 全 的 问 题 。 如 果 职 责 链 已 经 是 系 统 结 构 的 一 部 分 ， 同 时 在 链上的多个对象中总有一个可以处理请求，那么职责链将是一个很好的将发送者和接收者解耦的方法。此外，因为链可以被简单的改变和扩展，从而该模式提供了更大的灵活性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了少数例外情况，各个行为设计模式之间是相互补充和相互加强的关系。例如，一个 职责链中的类可能包括至少一个 Template Method(5.10)的应用。该模板方法可使用原语操作 确定该对象是否应处理该请求并选择应转发的对象。职责链可以使用 C o m m a n d模式将请求表 示为对象。I n t e r p r e t e r ( 2 4 3 ) 可以使用 S t a t e 模 式 定 义 语 法 分 析 上 下 文 。 迭 代 器 可 以 遍 历 一 个 聚 合 ， 而访问者可以对它的每一个元素进行一个操作。<br>行为模式也与能其他模式很好地协同工作。例如，一个使用 C o m p o s i t e ( 4 . 3 ) 模 式 的 系 统 可以使用一个访问者对该复合的各成分进行一些操作。它可以使用职责链使得各成分可以通 过它们的父类访问某些全局属性。它也可以使用 D e c o r a t e r ( 4 . 4 ) 对 该 复 合 的 某 些 部 分 的 这 些 属性进行改写。它可以使用 O b s e r v e r 模 式 将 一 个 对 象 结 构 与 另 一 个 对 象 结 构 联 系 起 来 ， 可 以 使用 S t a t e 模 式 使 得 一 个 构 件 在 状 态 改 变 时 可 以 改 变 自 身 的 行 为 。 复 合 本 身 可 以 使 用 B u i l d e r<br>( 3 . 2 ) 中 的 方 法 创 建 ， 并 且 它 可 以 被 系 统 中 的 其 他 部 分 当 作 一 个 P r o t o t y p e ( 3 . 4 )。 设计良好的面向对象式系统通常有多个模式镶嵌在其中，但其设计者却未必使用这些术 语进行思考。然而，在模式级别而不是在类或对象级别上的进行系统组装可以使我们更方便<br>地获取同等的协同性。</p>]]></content>
    
    
    <summary type="html">行为型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式的讨论</title>
    <link href="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/"/>
    <id>http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/</id>
    <published>2023-02-27T07:43:01.000Z</published>
    <updated>2023-03-13T10:03:20.937Z</updated>
    
    <content type="html"><![CDATA[<p>结构型模式依赖于同一个很小的语言机制集合构造代码和对象：单继承和多重继承机制用于基于类的模式，而对象组合机制用于对象式模式。但是这些相似性掩盖了这些模式的不同意图。</p><h2 id="适配器-与-桥接"><a href="#适配器-与-桥接" class="headerlink" title="适配器 与 桥接"></a>适配器 与 桥接</h2><p>具有一些共同的特征。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。</p><p>这些模式的不同之处主要在于它们各自的用途。<br>适配器模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。 这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。<br>另一方面， 桥接模式则对抽象接口与它的(可能是多个)实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。 桥接模式也会在系统演化时适应新的实现。</p><p>由于这些不同点，适配器和桥接模式通常被用于软件生命周期的不同阶段。当你发现两个不兼容的类必须同时工作时，就有必要使用适配器模式，其目的一般是为了避免代码重复。此处耦合不可预见。相反，桥接的使用者必须事先知道:一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的。适配器模式在类已经设计好后实施;而桥接模式在设计类之前实施。这并不意味着适配器模式不如桥接模式，只是因为它们针对了不同的问题。<br>外观模式定义一个新的接口吗，而适配器则复用一个原有的接口。记住，适配器使两个已有的接口协同工作，而不是定义一个全新的接口。</p><h2 id="组装、装饰者-与-代理"><a href="#组装、装饰者-与-代理" class="headerlink" title="组装、装饰者 与 代理"></a>组装、装饰者 与 代理</h2><p>组装模式和装饰者模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。这一共同点可能会使你认为， 装饰者对象是一个退化的组装 ， 但这一观点没有领会装饰者模式要点。相似点仅止于递归组合，同样，这是因为这两个模式的目的不同。<br>装饰者旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。 组装则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰， 而在于表示。<br>尽管它们的目的截然不同，但却具有互补性。因此组装和装饰者模式通常协同使用。在使用这两种模式进行设计时，我们无需定义新的类，仅需将一些对象插接在一起即可构建应用 。 这时系统中将会有一个抽象类 ，它有一些组装子类和装饰者子类 ， 还有一些实现系统的基本构建模块。此时， 组装和装饰者将拥有共同的接口。从装饰者模式的角度看， 组装是一个ConcreteComponent 。而从组装模式的角度看，装饰者则是一个Leaf。当然，他们不一定要同时使用，正如我们所见，它们的目的有很大的差别。<br>另一种与装饰者模式结构相似的模式是代理 。 这两种模式都描述了怎样为对象提供一定程度上的间接引用，代理和装饰者对象的实现部分都保留了指向另一个对象的指针 ， 它们向这个对象发送请求。然而同样，它们具有不同的设计目的。<br>像装饰者模式一样， 代理模式构成一个对象并为用户提供一致的接口。但与装饰者模式不同的是， 代理模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如，实体在远程设备上，访问受到限制或者实体是持久存储的。<br>在代理模式中，实体定义了关键功能，而代理提供(或拒绝)对它的访问。在装饰者模式中，组件仅提供了部分功能，而一个或多个装饰者负责完成其他功能。装饰者模式适用于编译时不能(至少不方便)确定对象的全部功能的情况。这种开放性使递归组合成为装饰者模式中一个必不可少的部分。而在代理模式中则不是这样，因为代理模式强调一种关系(代理与它的实体之间的关系)，这种关系可以静态的表达。<br>模式间的这些差异非常重要，因为它们针对了面向对象设计过程中一些特定的经常发生 问题的解决方法。但这并不意味着这些模式不能结合使用。可以设想有一个代理 - 装饰者 ， 它可以给代理添加功能，或是一个装饰者 - 代理用来修饰一个远程对象 。 尽管这种混合可能有用(我们手边还没有现成的例子)，但它们可以分割成一些有用的模式。</p>]]></content>
    
    
    <summary type="html">结构型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型模式的讨论</title>
    <link href="http://example.com/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/"/>
    <id>http://example.com/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/</id>
    <published>2023-02-25T17:01:24.000Z</published>
    <updated>2023-03-10T07:34:56.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建型模式的讨论"><a href="#创建型模式的讨论" class="headerlink" title="创建型模式的讨论"></a>创建型模式的讨论</h2><p>用一个系统创建的那些对象的类对系统进行参数化有两种常用方法。一种是生成创建对象的类的子类，这对应于使用工厂方法模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。<br>另一种对系统进行参数化的方法更多的依赖于对象复合:定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是抽象工厂、 构建者和原形模式的关键特征。这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”。</p><ul><li>抽象工厂由这个工厂对象产生多个类的对象。 </li><li>构建者由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。</li><li>原型由该工厂对象通过拷贝原型对象来创建产品对象。</li></ul>]]></content>
    
    
    <summary type="html">创建型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-目录</title>
    <link href="http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/"/>
    <id>http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/</id>
    <published>2023-02-18T15:04:05.000Z</published>
    <updated>2023-03-13T10:37:04.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我在看<strong>小鹏哥</strong>写的<strong>设计模式</strong>中一句话让我很有感触：<br><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">讲道理没有ifelse解决不了的逻辑，不⾏就在加⼀⾏!<br></code></pre></td></tr></table></figure><br>这个现象太真实了。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>模式在构造复杂系统时的重要性早已在其他领域中被认可。软件领域中的设计模式为开发人员提供了一种 使用专家设计经验的有效途径。在使用设计模式前，最好需要熟悉“类型”和“多态”，或“接口”继承与“实现”继承的关系。</p><p>设计模式捕获了随时间进化与发展 的问题的求解方法，因此它们并不是人们从一开始就采用的设计方案。它们反映了不为人知的 重新设计和重新编码的成果，而这些都来自软件开发者为了设计出灵活可复用的软件而长时间 进行的艰苦努力。设计模式捕获了这些解决方案，并用简洁易用的方式表达出来。</p><h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><h3 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2. 里氏代换原则"></a>2. 里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3. 依赖倒转原则"></a>3. 依赖倒转原则</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5-迪米特法则，又称最少知道原则"><a href="#5-迪米特法则，又称最少知道原则" class="headerlink" title="5. 迪米特法则，又称最少知道原则"></a>5. 迪米特法则，又称最少知道原则</h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6. 合成复用原则"></a>6. 合成复用原则</h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="23个设计模式"><a href="#23个设计模式" class="headerlink" title="23个设计模式"></a>23个设计模式</h1><p>下面介绍了各个模式的类型及大致范围</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">创建型</th><th style="text-align:center">结构型</th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center">范围</td><td style="text-align:center">类</td><td style="text-align:center">工厂函数</td><td style="text-align:center">适配器(类)</td><td style="text-align:center">模版方法、解释器</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">对象</td><td style="text-align:center">抽象工厂、构建者、原型模式、单例模式</td><td style="text-align:center">适配器(对象)、桥接模式、组成模式、装饰者、外观模式、享元模式、代理模式</td><td style="text-align:center">责任链、命令模式、迭代器、中介者、备忘录、观察者、状态模式、策略模式、访问者</td></tr></tbody></table></div><p>大致分类的方式：</p><ol><li>完成什么工作：创建型模式与对象的创建有关;结构型模式处理类或对象的组合;行为型 模式对类或对象怎样交互和怎样分配职责进行描述。</li><li>用于类还是用于对象：类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了；对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。</li></ol><p>下图中也描述了这些模式之间的关系<br><img src="/img/DesignPatterns/00.png" alt="github"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p><a href="https://yangandmore.github.io/2023/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/">工厂方法</a><br><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/">抽象工厂</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/">构建者</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/">原型模式</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5/">单例模式</a><br><a href="https://yangandmore.github.io/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/">总结</a></p><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">适配器(对象)</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/">桥接模式</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/">组成模式</a><br><a href="https://yangandmore.github.io/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/">装饰者</a><br><a href="https://yangandmore.github.io/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/">外观模式</a><br><a href="https://yangandmore.github.io/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">享元模式</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/">代理模式</a><br><a href="https://yangandmore.github.io/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/">总结</a></p><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/">责任链</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/">命令模式</a><br><a href="https://yangandmore.github.io/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/">迭代器</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/">中介者</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/">备忘录</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/">观察者</a><br><a href="https://yangandmore.github.io/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/">状态模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/">策略模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/">访问者</a></p>]]></content>
    
    
    <summary type="html">设计模式-目录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:09:19.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>提供一个接口来完成计算方式。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来，就创建需要对比的类型，并创建对应的对比起就可以了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">Number</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Number n1, Number n2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n1.a &gt; n2.a &amp;&amp; n1.b &gt; b2.b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后并使用这个对比工具即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Number n1 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        Number n2 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        <br>        Comparator com = <span class="hljs-keyword">new</span> NumberComparator();<br>        <span class="hljs-keyword">int</span> res = com.compara(n1, n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>如果需要修改算法，我们只需要增加对比器的实现即可。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一<br>个类的方法。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的<br>算法。当这些变体实现为一个算法的类层次时 [ H O 8 7 ] ,可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数<br>据结构。</li><li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。<br>将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/21.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Strategy 和 Context 相互作用以实现选定的算法。当算法被调用时, Context 可以将该算法 所需要的所有数据都传递给该 Strategy 。或者， Context 可以将自身作为一个参数传递给Strategy操作。这就让 Strategy在需要时可以回调 Context 。</li><li>Context 将它的客户的请求转发给它的 Strategy 。客户通常创建并传递一个 ContextStrategy对象给该 Context ;这样 , 客户仅与 Context 交互。通常有一系列的 ContextStrategy 类可供客户从中选择。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Strategy 模式有下面的一些优点和缺点 :</p><ol><li>相 关 算 法 系 列<br> Strategy类层次为Context定义了一系列的可供重用的算法或行为 。 继承有助于析取出这些算法中的公共功能。</li><li>一个替代继承的方法<br> 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类 ， 从而给它以不同的行为 。 但这会将行为硬行编制到Context中，而将 算法的实现与Context的实现混合起来 , 从而使Context难以理解 、 难以维护和难以扩展 ， 而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、 易于理解、易于扩展。</li><li>消除了一些条件语句<br> Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 , 很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句 。<br> 例如 , 不用Strategy, 正文换行的代码可能是象下面这样 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(type) &#123;<br>    <span class="hljs-keyword">case</span>: <br>    <span class="hljs-keyword">case</span><br>&#125;<br></code></pre></td></tr></table></figure> Strategy模式将换行的任务委托给一个Strategy对象从而消除了这些 case 语句 : <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">compositor.compose();<br></code></pre></td></tr></table></figure> 含有许多条件语句的代码通常意味着需要使用Strategy模式。</li><li>实现的选择<br> Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间/空间权衡取舍要求从不同策略中进行选择。</li><li>客户必须了解不同的Strategy<br> 本模式有一个潜在的缺点 ， 就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同 。 此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。</li><li>Strategy和Context之 间 的 通 信 开 销<br> 无论各个ContextStrategy实现的算法是简单还是复杂 , 它们都共享Strategy定义的接口。因此很可能某些ContextStrategy不会都用到所有通过这个接口传递给它们的信息;简单的ContextStrategy可能不使用其中的任何信息!这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。</li><li>增加了对象的数目<br> Strategy增加了一个应用中的对象的数目。有时你可以将Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的Strategy不应在各次调用之间维护状态。 </li></ol>]]></content>
    
    
    <summary type="html">策略模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模版模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:21:35.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>准备算法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>        water();<br>        eat();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>final表示无法重写，因此该方法只能使用，无法覆盖，该顺序已经被固定成一个模板。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowerTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>控制子类扩展。模板方法只在特定点调用“许在这些点进行扩展。hook”操作， 这样就只允许在这些点进行扩展。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/22.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>ConcreteClass 靠 AbstractClass 来实现算法中不变的步骤。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。 模板方法导致一种反向的控制结构，这种结构有时被称为“好莱坞法则”，即“别找我们，我们找你” [ S w e 8 5 ] 。 这指的是一个父类调用一个子类的操作，而不是相反 。 模板方法调用下列类型的操作:</p><ul><li>具体的操作(ConcreteClass或对客户类的操作)。</li><li>具体的AbstractClass的操作(即，通常对子类有用的操作)。</li><li>原语操作(即，抽象操作)。</li><li>FactoryMethod。</li><li>钩子操作(hook operations)，它提供了缺省的行为，子类可以在必要时进行扩展。一个钩子操作在缺省操作通常是一个空操作。</li></ul><p>很重要的一点是模板方法应该指明哪些操作是钩子操作(可以被重定义)以及哪些是抽象操作(必须被重定义)。要有效地重用一个抽象类，子类编写者必须明确了解哪些操作是设计为有待重定义的。<br>子类可以通过重定义父类的操作来扩展该操作的行为，其间可显式地调用父类操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DerivedClass::Operation() &#123;<br>    ParentClass::Operation();<br>&#125;<br></code></pre></td></tr></table></figure><br>不幸的是，人们很容易忘记去调用被继承的行为。我们可以将这样一个操作转换为一个模板方法，以使得父类可以对子类的扩展方式进行控制。也就是，在父类的模板方法中调用钩子操作。子类可以重定义这个钩子操作:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParentClass::Operation() &#123;<br>    HookOperation();<br>&#125;<br></code></pre></td></tr></table></figure><br>ParentClass本身的HookOperation什么也不做 :<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParentClass::HookOperation() &#123;&#125;<br></code></pre></td></tr></table></figure><br>子类重定义HookOperation以扩展它的行为:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DerivedClass::HookOperation &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">模版模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:29:51.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>专家在评审项目时，不同专家针对不同项目进行评审</p><p>首先项目部分<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Project</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>创建两个项目类型<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> FoodProject extends Project&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> safe;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FoodProject</span><span class="hljs-params">(String name, String safe)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.safe = safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToolProject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> quality;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToolProject</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> quality)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.quality = quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>针对项目，建立了食评项目和工具项目两个类型，针对他们的数据分别为食品安全等级和工具效率等级。</p><p>接下来就是不同的专家分别评审两者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject foodProject)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject toolProject)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后针对不同专家，处理两者的方式也不同<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVisitor</span> <span class="hljs-title">implement</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;食评项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,安全等级:&quot;</span>+project.getSafe());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;工具项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,质量等级:&quot;</span>+project.getQuality());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样大致完成基本功能</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 访问者使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/23.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>一个使用 Visitor模式的客户必须创建一个ConcreteVisitor对象 ， 然后遍历该对象结构 ，并用该访问者访问每一个元素。</li><li>当一个元素被访问时，它调用对应于它的类的 Visitor操作 。 如果必要 ，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。<br>下面的交互框图说明了一个对象结构、一个访问者和两个元素之间的协作。<br><img src="/img/DesignPatterns/23_1.png" alt="github"></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>下面是访问者模式的一些优缺点:</p><ol><li>访问者模式使得易于增加新的操作<br> 访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反， 如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。</li><li>访问者集中相关的操作而分离无关的操作<br> 相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。</li><li>增加新的ConcreteElement类很困难<br> Visitor模式使得难以增加新的 Element 的子类。每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个ConcretVisitor类中实现相应的操作。有时可以在 Visitor中提供一个缺省的实现，这一实现可 以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。<br> 所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化，是作用于对象结构上的算法呢还是构成该结构的各个对象的类。如果老是有新的ConcretElement 类加入进来的话，Vistor类层次将变得难以维护 。 在这种情况下 ，直接在构成该结构的类中定义这些操作可能更容易一些。如果Element类层次是稳定的 ，而你不断地增加操作获修改算法 ，访问者模式可以帮助你管理这些改动。</li><li>通过类层次进行访问<br> 个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构，同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作。</li><li>累积状态<br> 当访问者访问对象结构中的每一个元素时，它可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局变量。</li><li>破坏封装<br> 访问者方法假定ConcreteElement接口的功能足够强 ， 足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。</li></ol>]]></content>
    
    
    <summary type="html">访问者模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Spire包处理文档</title>
    <link href="http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-02-16T06:49:03.842Z</updated>
    
    
    <summary type="html">使用Spire包处理文档</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"/>
    <id>http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-03-13T13:36:52.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先创建状态机，或者说上下文。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        state.start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        state.close(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>再看看状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来建立对应的两个状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.close(<span class="hljs-keyword">new</span> CloseState());<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.start(<span class="hljs-keyword">new</span> StartState());<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>准备好后就可以使用了。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        <br>        context.setState(<span class="hljs-keyword">new</span> StartState());<br>        context.close();<br>        context.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/20.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。</li><li>Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context 。</li><li>Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context ，一旦一个Context配置完毕 , 它的客户不再需要直接与状态对象打交道。</li><li>Context 或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>State 模式有下面一些效果 :</p><ol><li>它将与特定状态相关的行为局部化 ， 并且将不同状态的行为分割开来<br> State 模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某 一个 State 子类中 ,所以通过定义新的子类可以很容易的增加新的状态和转换 。<br> 另一个方法是使用数据值定义内部状态并且让 Context 操 作 来 显 式 地 检 查 这 些 数 据 。 但 这 样将会使整个Context的实现中遍布看起来很相似的条件语句或case语句 。 增加一个新的状态可能需要改变若干个操作 , 这就使得维护变得复杂了。<br> State 模式避免了这个问题 , 但可能会引入另一个问题 , 因为该模式将不同状态的行为分布在多个State子类中 。 这就增加了子类的数目，相对于单个类的实现来说不够紧凑 。 但是如果有许多状态时这样的分布实际上更好一些 , 否则需要使用巨大的条件语句。<br> 正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码 。 决定状态转移的逻辑不在单块的 if 或 switch 语句中 , 而是分布在 State 子类之间。 将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。 这将使代码结构化并使其意图更加清晰。</li><li>它使得状态转换显式化<br> 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且,State对象可保证Context不会发生内部状态不一致的情况 ， 因为从Context的角度看 ， 状态转换是原子的—只需重新绑定一个变量 ( 即 Context 的 State对象变量 ) ， 而无需为多个变量赋值</li><li>State对象可被共享<br> 如果State对象没有实例变量 — 即它们表示的状态完全以它们的类型来编码 — 那么各 Context 对象可以共享一个 State 对象。当状态以这种方式被共享时 , 它们必然是没有内部状态 , 只有行为的轻量级对象</li></ol>]]></content>
    
    
    <summary type="html">状态模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:12:42.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先是中介者接口定义，接口中的提供了功能定义了赢的人是谁，输的人有谁，以及赢了多少<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及实现该接口的对象，主要对用户进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mediator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span> </span>&#123;<br>        winer.add(data);<br>        foreach(Colleage c : losers) &#123;<br>            c.subtraction(data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是用户的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后我们针对用户进行实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data += data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data -= data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>主要通过中介者来对同事的数据进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Mediator mediator = <span class="hljs-keyword">new</span> ConcreteMediator();<br>        <br>        Colleague c1 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">100</span>);<br>        Colleague c2 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">800</span>);<br>        Colleague c3 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">400</span>);<br>        <br>        mediator.win(c1, <span class="hljs-number">10</span>, c2, c3);<br>        mediator.win(c3, <span class="hljs-number">100</span>, c1);<br>        mediator.win(c2, -<span class="hljs-number">10</span>, c3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/17.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>中介者模式有以下优点和缺点 :</p><ol><li>减少了子类生成<br> Mediator 将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成 Mediator 的子类即可。这样各个 Colleague 类可被重用。</li><li>它将各 Colleague 解耦<br> Mediator 有利于各 Colleague 间的松耦合 . 你可以独立的改变和复用各 Colleague 类和 Mediator 类。</li><li>它简化了对象协议<br> 用 Mediator 和各 Colleague 间的一对多的交互来代替多对多的交互 。一对多的关系更易于理解、维护和扩展。</li><li>它对对象如何协作进行了抽象<br> 将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。</li><li>它使控制集中化<br> 中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议 , 它可能变得比任一个 Colleague 都复杂。 这可能使得中介者自身成为一个难于维护的庞然大物。</li></ol>]]></content>
    
    
    <summary type="html">中介者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:19:19.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mement <span class="hljs-title">saveCurrentStateToMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(state);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = m.getState();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面建立了原发器的状态字段，以及提供对当前状态的保存以及恢复功能，使用了另一个类来存储当前状态。但是他并不会保存这些状态，只是用这些记录来恢复。</p><p>针对每一次记录都使用下面的对象来单独保存。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后使用一个备忘录管理类来管理这些备忘录<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CareTaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Memento&gt; datas = <span class="hljs-keyword">new</span> ArrayList&lt;Memento&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        datas.add(m)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> datas.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Originator originator = <span class="hljs-keyword">new</span> Originator();<br>        CareTaker careTaker = <span class="hljs-keyword">new</span> CareTaker();<br>        originator.setState(<span class="hljs-string">&quot;状态1&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态2&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态3&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        <br>        originator.restore(careTaker.get(<span class="hljs-number">0</span>));<br>        originator.restore(careTaker.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>必须保存一个对象在某一个时刻的 (部分)状态, 这样以后需要时它才能恢复到先前的状态。</li><li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/18.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>管理器向原发器请求一个备忘录 , 保留一段时间后 ,将其送回给原发器 , 如下面的交互图所示。有时管理者不会将备忘录返回给原发器 , 因为原发器可能根本不需要退到先前的状态。</li><li>备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。<br><img src="/img/DesignPatterns/18_1.png" alt="github"></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>备忘录模式有以下一些效果 :</p><ol><li>保持封装边界<br> 使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发 器之外的信息。该模式把可能很复杂的 Originator 内部信息对其他对象屏蔽起来 , 从而保持了封装边界。</li><li>它简化了原发器<br> 在其他的保持封装性的设计中 , Originator负责保持客户请求过的内部 状态版本。这就把所有存储管理的重任交给了 Originator 。 让客户管理它们请求的状态将会简化 Originator, 并且使得客户工作结束时无需通知原发器 。</li><li>使用备忘录可能代价很高<br> 如果原发器在生成备忘录时必须拷贝并存储大量的信息 , 或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。除非封装和恢复 Originator 状态的开销不大 ,否则该模式可能并不合适。</li><li>定义窄接口和宽接口<br> 在一些语言中可能难以保证只有原发器可访问备忘录的状态。</li><li>维护备忘录的潜在代价<br> 管理器负责删除它所维护的备忘录。然而 , 管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。</li></ol>]]></content>
    
    
    <summary type="html">备忘录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:25:26.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先定义观察接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后创建多个观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user:&quot;</span>+arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是被观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; obs;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Observable</span><span class="hljs-params">()</span> </span>&#123;<br>        obs = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">if</span> (!obs.contains(o)) &#123;<br>            obs.addElement(o);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        obs.removeElement(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        notifyObservers(<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * a temporary array buffer, used as a snapshot of the state of</span><br><span class="hljs-comment">         * current Observers.</span><br><span class="hljs-comment">         */</span><br>        Object[] arrLocal;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!changed)<br>                <span class="hljs-keyword">return</span>;<br>            arrLocal = obs.toArray();<br>            clearChanged();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arrLocal.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>            ((Observer)arrLocal[i]).update(<span class="hljs-keyword">this</span>, arg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        obs.removeAllElements();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> changed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> obs.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后继承该类，创建被观察者。这里会发送一条消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setChanged();<br>        notifyObservers(msg);<br>        <span class="hljs-keyword">this</span>.clearChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Observer u1 = <span class="hljs-keyword">new</span> UserObserver();<br>        Observer u2 = <span class="hljs-keyword">new</span> UserObserver();<br>        Subject subject = <span class="hljs-keyword">new</span> Subject();<br>        subject.addObserver(u1);<br>        subject.addObserver(u2);<br>        <br>        subject.setMessage(<span class="hljs-string">&quot;消息1&quot;</span>);<br>        subject.setMessage(<span class="hljs-string">&quot;消息2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象是紧密耦合的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/19.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>当 ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。</li><li>在得到一个具体目标的改变通知后 , ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。</li></ul><p>下面的交互图说明了一个目标对象和两个观察者之间的协作 :<br><img src="/img/DesignPatterns/19_1.png" alt="github"></p><p>注意发出改变请求的 Observer对象并不立即更新 , 而是将其推迟到它从目标得到一个通知之后。 Notify不总是由目标对象调用。它也可被一个观察者或其它对象调用 。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Observer模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者, 反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。<br>下面是观察者模式其它一些优缺点 :</p><ol><li>目标和观察者间的抽象耦合<br> 一个目标所知道的仅仅是它有一系列观察者 , 每个都符合抽象的Observer类的简单接口 。 目标不知道任何一个观察者属于哪一个具体的类 。 这样目标和观察者之间的耦合是抽象的和最小的。<br> 因为目标和观察者不是紧密耦合的 , 它们可以属于一个系统中的不同抽象层次。一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它 , 这样就保持了系统层次的完整。如果目标和观察者混在一块 , 那么得到的对象要么横贯两个层次 (违反了层次性 ), 要么必须放在这两层的某一层中 (这可能会损害层次抽象 )。</li><li>支持广播通信<br> 不像通常的请求, 目标发送的通知不需指定它的接收者。通知被自动广播给所有已向该目标对象登记的有关对象。目标对象并不关心到底有多少对象对自己感兴趣 ; 它唯一的责任就是通知它的各观察者。这给了你在任何时刻增加和删除观察者的自由。处理还是忽略一个通知取决于观察者。</li><li>意外的更新<br> 因为一个观察者并不知道其它观察者的存在 , 它可能对改变目标的最终代价一无所知。在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外 , 如果依赖准则的定义或维护不当，常常会引起错误的更新 , 这种错误通常很难捕捉。<br> 简单的更新协议不提供具体细节说明目标中什么被改变了 , 这就使得上述问题更加严重。 如果没有其他协议帮助观察者发现什么发生了改变，它们可能会被迫尽力减少改变。</li></ol>]]></content>
    
    
    <summary type="html">观察者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器</title>
    <link href="http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"/>
    <id>http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/</id>
    <published>2023-02-12T20:34:01.000Z</published>
    <updated>2023-03-13T13:08:35.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>熟悉java就应该知道，Iterator模式这个在java中用的非常广泛。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用ArrayList<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span> </span>&#123;<br>    Object[] arr = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == arr.lenth) &#123;<br>            Object[] newArr = <span class="hljs-keyword">new</span> Object[arr.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(arr, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, arr.length);<br>            arr = newArr;<br>        &#125;<br>        arr[index] = item;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面是一个普通ArrayList下的构建，还不具备迭代器，只能使用索引下标来进行迭代。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里建立迭代器的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后让ArrayList实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E[] arr = (E[])<span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == arr.lenth) &#123;<br>            E[] newArr = (E[])<span class="hljs-keyword">new</span> Object[arr.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(arr, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, arr.length);<br>            arr = newArr;<br>        &#125;<br>        arr[index] = item;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayListIterator();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentIndex = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (currentIndex &gt;= index) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            E item = (E)arr[currentIndex];<br>            currentIndex++;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时使用新ArrayList中的Iterator，构建一个迭代器。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Iterator iterator = list.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>            String data = iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口 (即, 支持多态迭代)。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/16.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>迭代器模式有三个重要的作用:</p><ol><li>它支持以不同的方式遍历一个聚合<br> 复杂的聚合可用多种方式进行遍历。例如 , 代码生成和语义检查要遍历语法分析树。代码生成可以按中序或者按前序来遍历语法分析树。迭代器模式使得改变遍历算法变得很容易 : 仅需用一个不同的迭代器的实例代替原先的实例即可。 你也可以自己定义迭代器的子类以支持新的遍历。</li><li>迭代器简化了聚合的接口<br> 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。</li><li>在同一个聚合上可以有多个遍历<br> 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。</li></ol>]]></content>
    
    
    <summary type="html">迭代器</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-解释器</title>
    <link href="http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"/>
    <id>http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/</id>
    <published>2023-02-12T20:34:01.000Z</published>
    <updated>2023-03-13T13:05:56.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>给定一个语言，定义他的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>那么根据结构建立一个简单的解释器<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>参数解析<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String key;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VarExpression</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.get(<span class="hljs-keyword">this</span>.key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及符号解析，具备了符号左右的参数添加<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Expression leftVar, rightVar;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SymbolExpression</span><span class="hljs-params">(Expression leftVar, Expression rightVar)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.leftVar = leftVar;<br>        <span class="hljs-keyword">this</span>.rightVar = rightVar;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>首先准备一个加法符号<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SymbolExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddExpression</span><span class="hljs-params">(Expression leftVar, Expression rightVar)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(leftVar, rightVar);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.leftVar.interpreter(data) + <span class="hljs-keyword">super</span>.rightVar.interpreter(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来只需要使用配置的对象解决问题即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p><ol><li>该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。他们无需构建抽象语法树即可解释表达式，这也可以节省空间而且还可能节省时间。</li><li>效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将她们转换成另一个形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/15.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Client 构建 ( 或被给定 )一个句子 , 它是 NonterminalExpression和TerminalExpression的实例的一个抽象语法树. 然后初始化上下文并调用解释操作。</li><li>每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。</li><li>每一节点的解释操作用上下文来存储和访问解释器的状态。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>解释器模式有下列的优点和不足 :</p><ol><li>易于改变和扩展文法<br> 因为该模式使用类来表示文法规则 , 你可使用继承来改变或扩展该文法。已有的表达式可被增量式地改变 ,而新的表达式可定义为旧表达式的变体。</li><li>也易于实现文法<br> 定义抽象语法树中各个节点的类的实现大体类似。这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。</li><li>复杂的文法难以维护<br> 解释器模式为文法中的每一条规则至少定义了一个类 ( 使用BNF定义的文法规则需要更多的类 )。因此包含许多规则的文法可能难以管理和维护。可应用其他的设计模式来缓解这一问题。但当文法非常复杂时, 其他的技术如语法分析程序或编译器生成器更为合适。</li><li>增加了新的解释表达式的方式<br> 解释器模式使得实现新表达式“计算”变得容易。 例如, 你可以在表达式类上定义一个新的操作以支持优美打印或表达式的类型检查。如果你经常创建新的解释表达式的方式 , 那么可以考虑使用访问者模式以避免修改这些代表文法的类。</li></ol>]]></content>
    
    
    <summary type="html">解释器</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-命令</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/</id>
    <published>2023-02-11T13:12:56.000Z</published>
    <updated>2023-03-13T13:01:19.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤消的操作。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Receiver receiver = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenCommand</span><span class="hljs-params">(Receiver receiver)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        receiver.action();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是接收者如何处理消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收者处理消息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面大致是命令收到后会让接收者收到一条消息。</p><p>接下来就是发送消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Command command = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span> </span>&#123;<br>        command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>大致准备好后，就可以使用了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Command command = OpenCommand(<span class="hljs-keyword">new</span> Receiver());<br>        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();<br>        invoker.setCommand(command);<br>        invoker.invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>将可用过程语言中的回调函数表达这种参数化机制。回调函数是指函数先在某处注册，而他将在稍后某个需要的时候被调用。命令模式是回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求。一个命令对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那实现该请求。</li><li>支持取消操作。</li><li>支持修改日志。</li><li>用构建在原语操作上的高层操作构造一个系统，这样一种结构在支持事务的信息系统上很常见。一个事务封装了对数据的一组变动。命令模式提供了对事物进行组建的方法。命令模式有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事物以扩展系统。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/14.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Client创建一个 ConcreteCommand 对象并指定它的 Receiver 对象。</li><li>某 Invoker对象存储该 ConcreteCommand 对象。</li><li>该 Invoker 通过调用 Command对象的 Execute 操作来提交一个请求。若该命令是可撤消的， ConcreteCommand 就在执行 Excute操作之前存储当前状态以用于取消该命令。</li><li>ConcreteCommand 对象对调用它的 Receiver 的一些操作以执行该请求 。</li></ul><p><img src="/img/DesignPatterns/14_1.png" alt="github"></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>命令模式有以下效果 :</p><ol><li>命令模式将调用操作的对象与知道如何实现该操作的对象解耦。</li><li>命令是头等的对象。它们可像其他的对象一样被操纵和扩展。</li><li>你可将多个命令装配成一个复合命令 。 例如是前面描述的MacroCommand类 。 一般说来，复合命令是组合模式的一个实例。</li><li>增加新的命令很容易，因为这无需改变已有的类。</li></ol>]]></content>
    
    
    <summary type="html">命令</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/</id>
    <published>2023-02-11T07:43:01.000Z</published>
    <updated>2023-02-28T14:23:43.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代理。</li><li>虚拟代理（Virtual Proxy）根据需要创建开销很大的对象。</li><li>保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li><li>智能指引（Smart Reference）取代了简单的指针，他在访问对象时执行一些附加操作。典型用途包括：<ul><li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放他。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查是否已经锁定了他，以确保其他对象不能改变它。</li></ul></li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/12.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>代理根据其种类，在适当的时候向 RealSubject 转发请求。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Proxy模式在访问对象时引入了一定程度的间接性。根据代理的类型，附加的间接性有多种用途:</p><ol><li>RemoteProxy 可以隐藏一个对象存在于不同地址空间的事实。</li><li>Virtual Proxy 可以进行最优化，例如根据要求创建对象。</li><li>Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理</li></ol><p>Proxy 模式还可以对用户隐藏另一种称之为 copy-on-write的优化方式，该优化与根据需要创建对象有关。拷贝一个庞大而复杂的对象是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候才对它进行拷贝。<br>在实现 Copy-on-write 时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正的拷贝它。在这种情况下，代理还必须减少实体的引用计数。当引用的数目为零时，这个实体将被删除。<br>Copy-on-Write可以大幅度的降低拷贝庞大实体时的开销。</p>]]></content>
    
    
    <summary type="html">代理</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-职责链</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/</id>
    <published>2023-02-11T07:43:01.000Z</published>
    <updated>2023-03-13T12:23:36.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>有点像按钮点击，当我们点击按钮后，点击事件并不是直接传递给这个按钮，而是一层一层向下传递。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">window -&gt; groupView -&gt; view<br></code></pre></td></tr></table></figure><br>首先是点击事件<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> thisType;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后是组件父类<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    Weight parent;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Weight</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = w;<br>        <span class="hljs-keyword">this</span>.thisType = thisType;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来就可以使用它来构建控件了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Button</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, thisType);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (testType == thisType) &#123;<br>            System.out.println(<span class="hljs-string">&quot;BUTTON Click&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            w.click(testType);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextView</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, thisType);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (testType == thisType) &#123;<br>            System.out.println(<span class="hljs-string">&quot;TEXTVIEW Click&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            w.click(testType);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwitchView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SwitchView</span><span class="hljs-params">(Weight w, <span class="hljs-keyword">int</span> thisType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(w, thisType);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> testType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (testType == thisType) &#123;<br>            System.out.println(<span class="hljs-string">&quot;SWITCHVIEW Click&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w != <span class="hljs-keyword">null</span>) &#123;<br>            w.click(testType);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;该链无法完成任务&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来，创建这个链<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Weight w = <span class="hljs-keyword">new</span> SwitchView(<span class="hljs-keyword">new</span> Button(<span class="hljs-keyword">new</span> TextView(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>), <span class="hljs-number">2</span>);<br>        w.click(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里的点击事件如果提供返回值，则可以将参数中的责任移动到函数的返回值来处理。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>有多个的对象可以处理一个请求，具体哪个对象来处理，可以在运行时觉得。</li><li>想在不明确指定接收者的情况下，在多个对象中的有一个提交一个请求。</li><li>可处理一个请求的对象集合应被动态指定。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/13.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>当客户提交一个请求时，请求沿链传递直至有一个 ConcreteHandler 对象负责处理它。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>职责链链有下列优点和缺点 :</p><ol><li>降低耦合度<br> 该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。结果是，职责链可简化对象的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。</li><li>增强了给对象指派职责的灵活性<br> 当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。</li><li>不保证被接受<br> 既然一个请求没有明确的接收者，那么就不能保证它一定会被处理 — 该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。</li></ol>]]></content>
    
    
    <summary type="html">职责链</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-享元</title>
    <link href="http://example.com/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"/>
    <id>http://example.com/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/</id>
    <published>2023-02-10T23:12:38.000Z</published>
    <updated>2023-02-28T14:10:12.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>运用共享技术有效地支持大量细粒度的对象。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>面向对象编程，在面对事物时会针对面向对象建立映射。<br>但是如果同类的对象使用过多，就会面临内存占用率过高，产生难以预估的内存消耗。为此，享元模式，描述了如何共享对象，使得可以使用他们并无需高昂的代价。<br>例如需要提供一个富文本编。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Glyph</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFont</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是具备绘图功能。下面就负责存储富文本的每一个字符。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> <span class="hljs-title">implement</span> <span class="hljs-title">Glyph</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span> </span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFont</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>当然，这里不仅仅是字符具备该功能，比如一些线条等。</p><p>为了避免每一个字体属性都分配存储空间，可以将该属性存储到外部缓存中。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlyphContext</span> </span>&#123;<br>    List&lt;Font&gt; fonts;<br>    <span class="hljs-comment">// add</span><br>    <span class="hljs-comment">// remove</span><br>    <span class="hljs-comment">// get</span><br>&#125;<br></code></pre></td></tr></table></figure><br>接下来就需要提供一个工厂，他来负责构建一些Glyph，当需要字体属性时，就去存储空间去找；不需要，则直接创建即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlyphFactory</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Character&gt; chars;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Glyph <span class="hljs-title">createCharacter</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!chars.has(<span class="hljs-keyword">char</span>)) &#123;<br>            <span class="hljs-keyword">char</span>.add(<span class="hljs-keyword">new</span> Character(<span class="hljs-keyword">char</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> chars.get(<span class="hljs-keyword">char</span>);<br>    &#125;<br>    pubic GlyphContext context;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>享元模式的有效性很大程度上取决于如何使用它以及在何处使用它。以下情况都成立使用：</p><ol><li>一个应用程序使用了大量的对象</li><li>完全由于使用大量的对象，造成很大的存储开销</li><li>对象的大多数状态都可变为外部状态</li><li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li><li>应用程序不依赖于对象标识。由于flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/11.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ol><li>flyweight 执行时所需的状态必定是内部的或外部的。内部状态存储于 ConcreteFlyweight 对象之中;而外部对象则由 Client 对象存储或计算。当用户调用 flyweight 对象的操作时，将该状态传递给它。</li><li>用户不应直接对 ConcreteFlyweight 类进行实例化，而只能从 FlyweightFactory 对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。</li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>使用 flyweight 模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当 flyweight 原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的 flyweight 越多，空间节省也就越大。<br>存储节约由以下几个因素决定:</p><ol><li>因为共享，实例总数减少的数目</li><li>对象内部状态的平均数目</li><li>外部状态是计算的还是存储的</li></ol><p>共享的 flyweight 越多，存储节约也就越多。节约量随着共享状态的增多而增大。当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。所以，可以用两种方法来节约存储:用共享减少内部状态的消耗，用计算时间换取对外 部状态的存储。<br>flyweight 模式经常和 Composite模式结合起来表示一个层次式结构，这一层次式结构是一个共享叶节点的图。共享的结果是，Flyweight的叶节点不能存储指向父节点的指针。而父节点的指针将传给Flyweight作为它的外部状态的一部分。这对于该层次结构中对象之间相互通讯的方式将产生很大的影响。</p>]]></content>
    
    
    <summary type="html">享元</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-外观</title>
    <link href="http://example.com/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"/>
    <id>http://example.com/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/</id>
    <published>2023-02-08T19:59:30.000Z</published>
    <updated>2023-02-28T14:10:25.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>外观模式和对外提供的SDK非常相像。对外的出入口固定，所有子系统功能都由外观的出入口提供，内部单独完成一整套的信息并对外公开。<br>他与单例模式配合非常好，因为单例只会提供一个对象，即出入口，所有的对接只和这个对象对接即可。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变的越来越复杂。大多数模式使用时会产生更多更小的类。这使得子系统更具有可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。外观模式可以提供一个简单的缺省视图，这一视图对大多数用户已经足够，而那些需要更多可定制性的用户可以越过外观模式。</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入外观模式将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</li><li>当需要构建一个层次结构的子系统，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让他们仅通过外观模式进行通信，从而简化他们的依赖性。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/10.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ol><li>客户程序通过发送请求给 Facade 的方式与子系统通讯， Facade 将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但 Facade 模式本身也必须将它的接口转换成子系统的接口。</li><li>使用 Facade 的客户程序不需要直接访问子系统对象。</li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol><li>它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。</li><li>它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。 松耦合关系使得子系统的组件变化不会影响到它的客户。Facade模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要。在大型软件系统中降低编译依赖性至关重要。在子系统类改变时，希望尽量减少重编译工作以节省时间。用Facade可以降低编译依赖性，限制重要系统中较小的变化所需的重编译工作。Facade模式同样也有利于简化系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。</li><li>如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。</li></ol>]]></content>
    
    
    <summary type="html">外观</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰</title>
    <link href="http://example.com/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/"/>
    <id>http://example.com/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/</id>
    <published>2023-02-07T18:47:30.000Z</published>
    <updated>2023-02-28T13:32:27.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>最好的例子就是ui图，在针对富文本进行编辑的时候，工具栏、文本栏、保存/取消栏等，都是是在其基础上进行装饰的效果。</p><p>首先是基础绘图组件<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VisualComponent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>以及具备该功能抽象类<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">pubic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">abstract</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VisualComponet</span> </span>&#123;<br>    <br>    VisualComponent component;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        component.draw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>接下来就可以使用抽象类的子类完成工作<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BorderDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BorderDecorator</span><span class="hljs-params">(VIsualComponent component)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBorder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.draw();<br>        drawBorder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样在原有的基础draw上，增加了其他的操作。一层嵌套一层形成新的子类，并在原有基础上更具有针对性增加功能。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可能撤销的职责</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/9.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>Decorator 将请求转发给它的 Component 对象，并有可能在转发请求前后执行一些附加的动作。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Decorator 模式至少有两个主要优点和两个缺点:</p><ol><li>比静态继承更灵活<br>与对象的静态继承(多重继承)相比，Decorator模式提供了更加灵活的向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。相比之下，继承机制要求为每个添加的职责创建一个新的子类(例如，BorderScrollableTextView, BorderedTextView)。这会产生许多新的类，并且会增加系统的复杂度。此外，为一 个特定的Component类提供多个不同的Decorator类，这就使得你可以对一些职责进行混合和匹配。<br>使用 Decorator 模式可以很容易地重复添加一个特性，例如在 TextView 上添加双边框时， 仅需将添加两个 BorderDecorator 即可。而两次继承 Border 类则极容易出错的。</li><li>避免在层次结构高层的类有太多的特征<br>Decorator模式提供了一种“即用即付”的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用Decorator类给它逐渐地添加功能。可以从简单的部件组合出复杂的功能。这样，应用程序不必为不需要的特征付出代价。同时也更易于不依赖于 Decorator 所扩展(甚至是不可预知的扩展)的类而独立地定义新类型的Decorator。扩展一个复杂类的时候，很可能会暴露与添加的职责无关的细节。</li><li>Decorator 与它的 Component 不一样<br>Decorator是一个透明的包装。如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有差别的，因此，使用装饰时不应该依赖对象标识。</li><li>有许多小对象<br>采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是很难学习这些系统，排错也很困难。</li></ol>]]></content>
    
    
    <summary type="html">装饰</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
