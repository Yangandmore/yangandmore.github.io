<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小杨的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-20T02:24:14.348Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java字节码指令大全</title>
    <link href="http://example.com/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-20T02:24:14.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h2><p>指令码 | 操作码（助记符） | 操作数 | 描述（栈指操作数栈）</p><h2 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h2><h2 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h2><h2 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h2><h2 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h2><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h2 id="逻辑运算——移位运算"><a href="#逻辑运算——移位运算" class="headerlink" title="逻辑运算——移位运算"></a>逻辑运算——移位运算</h2><h2 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h2><h2 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h2><h2 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h2><h2 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h2><h2 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h2><h2 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h2><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><h2 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h2>]]></content>
    
    
    <summary type="html">Java字节码指令大全</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM—SafePoint</title>
    <link href="http://example.com/2023/03/15/JVM_SafePoint/"/>
    <id>http://example.com/2023/03/15/JVM_SafePoint/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-18T15:55:53.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h2><p>JVM的主要任务是执行Java程序，而JVM运行时本身也是一个程序，但是为了执行Java程序JVM还有不少辅助工作，比如进行GC、JIT编译等等。一般会把运行在JVM上的用户Java程序称为<code>mutator</code>。</p><p>在GC中，JVM中一般的GC都使用可达性分析，也就是从应用程序的一些GC Root(比如运行中的线程栈里的方法栈帧中本地变量表、操作数表中的引用、静态变量引用等)开始通过引用进行引用图遍历，如果在JVM遍历的过程中mutator也在运行，则mutator则可能会修改这个对象图的引用关系，如果JVM不对这种并发修改进行特殊处理，可能导致一些非可回收对象没有被遍历到，从而被标记成垃圾对象而被错误的回收。<br>如果要完全并发GC，JVM的实现成本会比较大，并且很多情况下整体的吞吐量是会降低的。<br>因此在很多GC收集器中都会有一些StopTheWorld阶段，这个StopTheWorld就是safepoint。在safepoint中不会有mutator操作对象，并且线程栈和heap中每个位置的数据类型也是确定的。</p><p>一个线程要么在safepoint中，要么不在safepoint中。上面提到的StopTheWorld指的是全局safepoint，也就是要求所有线程都处于safepoint状态。后面如果没有特别说明safepoint也指的是全局safepoint。</p><h2 id="SafePoint-如何实现的"><a href="#SafePoint-如何实现的" class="headerlink" title="SafePoint 如何实现的"></a>SafePoint 如何实现的</h2><p>可以这么理解，SafePoint 可以插入到代码的某些位置，每个线程运行到 SafePoint 代码时，主动去检查是否需要进入 SafePoint，这个主动检查的过程，被称为 Polling。<br>在hotspot实现中safepoint是协作式的，当JVM需要mutator进入safepoint时，会设置一个状态标记表示要进入safepoint了，每个mutator线程都会在合适的时机检查这个状态标记，如果发现需要进入safepoint则会暂停自己。</p><p>针对 SafePoint，线程有 5 种情况；假设现在有一个操作触发了某个 VM 线程所有线程需要进入 SafePoint（例如现在需要 GC），如果其他线程现在：</p><ul><li>运行字节码：运行字节码时，解释器会看线程是否被标记为 poll armed，如果是，VM 线程调用 <code>SafepointSynchronize::block(JavaThread *thread)</code>进行 block。</li><li>运行 native 代码：当运行 native 代码时，VM 线程略过这个线程，但是给这个线程设置 poll armed，让它在执行完 native 代码之后，它会检查是否 poll armed，如果还需要停在 SafePoint，则直接 block。</li><li>运行 JIT 编译好的代码：由于运行的是编译好的机器码，直接查看本地 local polling page 是否为脏，如果为脏则需要 block。这个特性是在 Java 10 引入的 JEP 312: Thread-Local Handshakes 之后，才是只用检查本地 local polling page 是否为脏就可以了。</li><li>处于 BLOCK 状态：在需要所有线程需要进入 SafePoint 的操作完成之前，不许离开 BLOCK 状态</li><li>处于线程切换状态或者处于 VM 运行状态：会一直轮询线程状态直到线程处于阻塞状态（线程肯定会变成上面说的那四种状态，变成哪个都会 block 住）。</li></ul><h2 id="如何排查safepoint相关问题"><a href="#如何排查safepoint相关问题" class="headerlink" title="如何排查safepoint相关问题"></a>如何排查safepoint相关问题</h2><p>在JVM启动参数上增加一些参数可以打印出应用暂停和safepoint相关信息。 如果版本&lt;=jdk8<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>如果版本&gt;jdk8<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-Xlog:gc*=info::time,tags,tid -Xlog:safepoint=info::time,tags,tid<br></code></pre></td></tr></table></figure></p><h2 id="深入Safepoint"><a href="#深入Safepoint" class="headerlink" title="深入Safepoint"></a>深入Safepoint</h2><p><img src="/img/Safepoint/0.png" alt="github"><br>可以看到，jvm中的每个子系统都或多或少的与安全点相关。因此在需要学会思考，编写的代码会与安全点有何关系之类的问题。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>java线程：他是jvm中线程概念的一种特殊化，是专门针对执行java代码的线程。线程本地gc根被定义为一个oop，它是指向java线程本地的java堆的指针，这里代表的java堆上对象，是可达性分析树的根。<br>可变线程状态：是一种java线程状态，特指可以改变java堆的线程状态。例如，分配对象或修改设置字段或其线程本地gc根，这种状态有时也被称为不安全状态。<br>安全点：他是一个全局JVM状态，这里的直观概念是在这个点或状态下，java世界停止了。所以他是安全的，因为所有其他应用线程停止了，这样jvm可以独占访问检查和处理。更技术性的定义是没有java线程在内部执行或可以转换到可变线程状态。技术定义的另一部分是所有java线程的线程本地gc根都可以访问或发布到JVM。<br>Safepointing作为动词，也称为stop the world，是jvm到达一个安全点的过程或者机制。并且有一个更古老的直观概念，这围绕着暂停或停止所有正在执行的java线程的过程，这对于抽象来说是可以的，但这次我们将了解到这是一种更加精细和进化的机制，它严重依赖于线程之间的协作，使用一种称为协作挂起的技术。<br>合作暂停：是一种基于轮询的技术。这意味着java线程将在VM中的指定位置检查或轮询线程本地状态。在暂停时，JVM会阻止java线程转换为可变线程状态，并且在暂停时，jvm会触发java线程从可变线程状态转换为不可变线程状态。并且由于这种转换，线程本地gc根将被发布。由于这种转换，线程本地gc根将被发布，传统上将系统带到安全点对于提供某种形式的自动内存管理的运行时来说是必要的<strong>邪恶机制</strong>。被称为如此的原因是，这是运行时延迟和不确定性的主要来源之一。<br>安全点就想轮回或苦难一样，我们想摆脱他们以达到涅槃。<br>新的衍生技术，例如线程握手和线程栈水位线，他们使得安全点机制可以更轻量级或更精细化。<br>谁需要安全点，因为某些操作因素，导致必须达到安全点才能完成任务，相反，某些操作必须在非安全点才能完成一样。</p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>java线程有一个叫做线程状态的字段（_thread_state），_thread_state的目的是跟踪java线程正在执行的代码的哪一部分。</p><p>这是java线程的状态转换：<br><img src="/img/Safepoint/2.png" alt="github"></p><ol><li>可变线程状态是一种线程可以改变java堆或其线程本地gc根的状态。</li><li>不可变线程状态是不能做这些事情的状态。</li><li>过渡状态，他们就像可变状态和不可变状态之间的桥梁。</li></ol><p>转换状态具有安全的检查或轮询指令以及适当的防护。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>看看下面的情况：<br>我们有了一个新线程，他开始在VM状态下运行。假设这个线程现在想要执行一些java代码；为了做到这一点，他需要遍历到java状态的转换；正如我们所说的状态转换包含安全点检查；这里的一些值得注意的状态转换时，处于运行java代码的状态可以在不执行安全点检查的情况下转换到状态VM和状态native，而是在线程返回状态java时执行安全点检查。<br>这里的另一个重要说明是，在native状态下执行的代码被认为是安全的，这意味着在安全点期间，java线程实际上可以继续运行native代码，这也意味着与安全点涉及阻塞或停止所有java线程的直观概念相悖。这只意味着她们不会在敏感的可变状态下执行。</p><h2 id="java线程本地gc根（Java-Thread-Local-GC-Roots）"><a href="#java线程本地gc根（Java-Thread-Local-GC-Roots）" class="headerlink" title="java线程本地gc根（Java Thread Local GC Roots）"></a>java线程本地gc根（Java Thread Local GC Roots）</h2><p>在我们将安全点定义为全局jvm状态时，所有java线程的线程本地gc根都可以访问或发不到jvm。当前所有的垃圾收集器都是跟踪型垃圾收集器，这意味着他们从所谓的根集开始跟踪可达性树，这是一组立即可以访问的oops（对象指针），是根集的一个子集，即java线程本地可访问的根集。</p><p>让我们看看这些线程本地gc根是什么</p><h3 id="本地jni句柄"><a href="#本地jni句柄" class="headerlink" title="本地jni句柄"></a>本地jni句柄</h3><p>java线程有一个成为活动句柄（_active_handles）的字段，他是一个本地jni句柄，提供给在本地状态下运行的jni代码对应的oop的间接访问，但是分配解除分配甚至取消引用jni句柄涉及首先执行vm状态，这将会执行安全点检查。本地jni句柄是自动管理的，因此，当代码从jni方法返回时，他会从进行安全点检查的状态native转换为状态java。由该方法分配的本地jni句柄被释放。</p><h3 id="句柄区域"><a href="#句柄区域" class="headerlink" title="句柄区域"></a>句柄区域</h3><p>java线程也有一个叫做句柄区域（_handle_area）的字段，句柄区域及其他伙伴句柄，提供与本地jni句柄几乎相同的间接功能，但是这些是针对在VM状态下运行的代码。<br>重要的区别是这些句柄不是自动管理的，而是必须由程序员手动管理。HandleMark用于描述句柄范围，并且HandleMark析构函数将为该特定范围是否分配的句柄，并且范围也可以嵌套。</p><h3 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h3><p>该线程还有一个内部结构体，并且有一个对应字段叫做锚（_anchor）。他由三个指针组成：</p><ul><li>_last_java_sp 表示最后一个java堆栈指针</li><li>_last_java_pc 表示最后一个java程序计数器</li><li>_last_java_fp 表示最后一个java帧指针</li></ul><p>最后一个java帧是外部遍历线程栈的入口点。我们排出JFR采集的帧。<br>如果线程在其堆栈上至少有一个java激活记录或帧，并且他当前不在状态java中，则设置他。所以处于状态java的线程在转换到其他状态之前，会设置这个锚（last java fram ljf）。<br>相反，他在线程重新进入状态java时被清除。</p><p>这里的anchor结构只需要设置_last_java_sp，因为其他字段要么与该上下文无关，要么可以通过堆栈便利代码推导出来。堆栈上的java帧可能包含普通、压缩的或派生的oops。所以，如果和之前讨论的句柄对比下，这些事裸oops，即他们没有处理引用定向，他们是直接指针。<br>ordinary指的是一般对象普通的oop；压缩oop是oop的压缩版本，他是32位大小；派生的oop是指向对象的指针，不是直接指向其对象头的。例如，我们可以考虑一个指针，他指向数组中的一个元素，派生oop始终与基址相关，对于java中的特定代码位置，对于像是代表特定的代码位置的程序计数器，堆栈槽和寄存器包含相对于该程序计数器的oops，是由编译器生成的一段元数据描述的，是叫做OopMap的一个东西。为了精确定位帧中的oop，OopMap使用栈指针的相对地址或RegisterMap的索引的相对地址来描述位置。<br>并非所有代码代码位置都有OopMap，他们主要与调用点和安全点轮询页面指令相关联。对于堆栈遍历，每帧的返回地址将于一个OopMap相关联。</p><h3 id="java线程-CPU上下文"><a href="#java线程-CPU上下文" class="headerlink" title="java线程 CPU上下文"></a>java线程 CPU上下文</h3><p>执行java代码的线程也有一个cpu上下文，并且根据调用约定和出于性能原因，理想情况下，oops由寄存器分配器直接放入寄存器中。<br>Hotspot广泛使用称为Stubs或StubRoutines的东西，他们是特定于平台的特殊程序集帮助程序。<br>Stub的一个重要特性就是在线程暂停他的工作让出CPU的时候保存CPU上下文，并且在线程回归之行的时候恢复CPU上下文，在某种程度上类似于上下文切换。</p><p>RegisterMap用于将oop映射描述的位置解析为寄存器，还有一些线程本地gc根。</p><p>例如潜在的未决异常和一些与jvmti相关的状态。</p><h1 id="将系统带到安全点的过程"><a href="#将系统带到安全点的过程" class="headerlink" title="将系统带到安全点的过程"></a>将系统带到安全点的过程</h1><h2 id="VMThread-is-the-coordinator"><a href="#VMThread-is-the-coordinator" class="headerlink" title="VMThread is the coordinator"></a>VMThread is the coordinator</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> VMThread::loop() &#123;<br>    ...<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (should_terminate()) <span class="hljs-keyword">break</span>;<br>        wait_for_operation();<br>        <span class="hljs-keyword">if</span> (should_terminate()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">assert</span>(_next_vm_operation != NULL, <span class="hljs-string">&quot;Must have one&quot;</span>);<br>        inner_execute(_next_vm_operation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该过程由从VMThread请求安全点操作的客户端启动，它通过将VM_Operation类型的对象排入队列并将其属性evaluate_at_safepoint()设置为true来实现。<br>VMThread将等待出队并启动安全点过程以服务提交的请求。</p><h2 id="VMThread-SafepointSynchronize-begin"><a href="#VMThread-SafepointSynchronize-begin" class="headerlink" title="VMThread - SafepointSynchronize::begin()"></a>VMThread - SafepointSynchronize::begin()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> SafepointSynchronize::begin() &#123;<br>    <span class="hljs-keyword">assert</span>(Thread::current()-&gt;is_VM_thread(), <span class="hljs-string">&quot;Only VM thread may execute a safepoint&quot;</span>);<br>    <br>    Threads_lock-&gt;lock();<br>    <span class="hljs-keyword">assert</span>(_state == _not_synchronized, <span class="hljs-string">&quot;trying to safepoint synchronize with wrong state&quot;</span>);<br>    <span class="hljs-keyword">int</span> nof_threads = Threads::number_of_threads();<br>    ...<br>    arm_safepoint();<br>    <br>    <span class="hljs-keyword">int</span> iterations = synchronize_threads(safepoint_limit_time, nof_threads, &amp;initial_running);<br>    <span class="hljs-keyword">assert</span>(_waiting_to_block == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;No thread should be running&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是VMThread运行的第一部分。他由三个部分组成：</p><ol><li><strong>组装</strong>java线程</li><li>同步，即等待所有java线程</li><li>当所有线程都被认为是安全的，即已经到达全局jvm安全点状态时，VMThread运行提交的操作</li></ol><p>首先看看组装部分</p><h3 id="VMThread-arm-safepoint"><a href="#VMThread-arm-safepoint" class="headerlink" title="VMThread - arm_safepoint()"></a>VMThread - arm_safepoint()</h3><p>java线程有一个嵌入的结构体。<br>_poll_data字段，由两个指针组成_polling_word和_polling_page。arming本质上意味着VMThread更改了安全点检查中使用的所谓轮询页面的内存保护。并且他从内存保护状态PAGE_READONLY更改为PAGE_NOACCESS。<br>这里VMThread大致完成了封装了java线程的内存页，它有效的删除了线程转换到任何红色不安全可变状态的能力。他切换了从蓝色到红色的所有链接。这意味着，VMThread通过这个进程所做的事情现在状态机制被替换成了一个临时的状态机制。</p><p>然而，这只是合作暂停的一部分。之前说的是，JVM阻止了java线程转变到被归类为可变的线程状态。</p><p>定义的第二部分是JVM触发java线程从可变状态为不可变状态。作为这个转换线程的结果，本地gc根被发布。<br>如何确保那些已经在可变状态下运行的线程变为不可变状态，对于在VM状态下运行的线程，他需要等待，知道线程自己执行转换。在VM状态中只有少数地方显式滴执行安全点检查。例如当争用VM下的互斥锁或监视器时。<br>这种设计的前提是java线程应该在状态VM中话费尽可能少的时间。</p><p>但是在状态Java中运行的现场就不一样了。<br>我们不能像在状态VM中那样，等待状态Java中的线程自行过渡。例如，一个线程可以执行无限循环，这是完全合法的，在这种情况下，JVM永远不会到达安全点。因此，要解决这个问题，需要有一种适当的机制来疏散或推出当前运行java代码的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (n == first) &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">int</span> second = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (scond == n) &#123;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>    <span class="hljs-keyword">int</span> nth = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        nth = getSuccressor(first, second);<br>        first = second;<br>        second = nth;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nth;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuccressor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> second)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码完成斐波那契数列，实现版本迭代。<br>但是在了解到细节时，最好谈谈x64调用约定或应用程序二进制接口，以及Hotspot Java调用约定以及他们之间的关系。<br>windows平台ABI按顺序在寄存器中传递前四个参数，其余的按从右到左（RTL）的顺序在堆栈上传递。还有32个字节的影子栈区域需要由调用者分配。System V ABI定义了参数在这六个寄存器中传递。而其余的也从右到左在堆栈上传递。<br>在栈下面有一个128字节的红色区域，Hotspot java调用约定定义了6个寄存器，用于在windows平台上参数传递，其余的从右到左在堆栈上传递，有一个自定义版本的堆栈保护，这只适用于System V平台。<br>对于所有这些，栈需要在16字节的边界上对齐。如果仔细观察，就会发现Hotspot java调用约定是平台ABI的一个移位或旋转版本，这种移位或旋转是因为通过跳过第一个ABI寄存器，我们可以调用非静态jni方法，而不必打乱参数。<br>相反，我们只将jni结束指针直接放在第一个ABI寄存器中。大多数寄存器都被认为是易失的，即调用方必须在调用过程中保留寄存器。除了RBP寄存器，是被调用的保存，如果存在压缩oops，R12就会保存java堆基址，而R15寄存器保存当前线程。所以这些寄存器可以被认为是常数。</p><p>JIT编译器在常规代码流中插入了安全点检查或轮询指令，他由两个指令组成：<br>第一个是从驻留在r15中的java线程加载轮询页面指针，然后执行一个test，解除轮询页面引用。除了在代码流中插入safepoint检查指令之外，JIT还确保这里的测试指令具有关联的OopMap，但对于这个特定的例子，这个特定的OopMap是空的。原因是，这段代码并没有真正使用任何java对象，因为他是一个静态方法，他没有接受对象，而且他只用了java原始类型。<br><img src="img/Safepoint/3.png" alt="github"><br>Safepoint检查由编译器插入到循环头中，就像这里这样，以便捕获长时间运行的循环，并且在方法返回之前。</p><p>让我们看一下被调用的方法getSuccessor<br><img src="img/Safepoint/4.png" alt="github"><br>这里可以看到安全点检查指令有点不同，这是一个cmp，而不是一个test，这是安全点检查的一个更优化版本。这与衍生技术如跨线程握手和线程水位线有关。不幸的事，这个版本不能应用于所有上下文中，后面会知道为什么在不同情况下需要不同的轮询指令。<br>在这段代码中，safepoint检查比较指令没有关联的OopMap，这是为什么？这是因为在方法末尾的safepoint调用指令是在栈帧出栈之后，但在返回指令之前插入的。这意味着调用者的返沪指令位于栈的顶部，通过表示一个调用点，他有一个关联的OopMap。<br>如果我们返回调用方，我们可以看到安全点检查，这是一个test指令，尝试解除对她从r15（java线程位于寄存器r15中）加载的轮询页面的引用。但是如果VMThread封装了轮询页面，即它将内存保护从PAGE_READONLY更改为PAGE_NO_ACCESS。<br>硬件将报非发访问或者segmentation fault，这又会通知操作系统，反过来通知寄存器信号或异常处理程序。Hotspot JVM将向各自的操作系统注册新号处理程序，以获取有关此事件的通知。利用硬件和操作系统提供的信息，我们可以确定发生了什么，所以在这个例子中，这是非法访问或者segmentation fault，并且还提供了有关哪个指令导致他的信息，内存地址。<br>所以在信号处理程序内部，我们可以确定内存地址是安全点轮询页面，所以我们知道这种非法访问或者segmentation fault并不是真正的崩溃，但它与合作暂停有关。<br>我们保存被困在名为saved_exception_pc的java线程字段中的指令，操作系统还为我们提供了处于trap时的状态和cpu上下文，我们可以在信号处理程序中重写cpu上下文，也就是说我们可以修改指令指针（IP），而不是指向捕获他的原始java代码，而是指向特定的StubRoutine。<br>当线程在展开所有异常处理程序后恢复时，操作系统重新加载这个现在修改的cpu上下文，并且线程继续在指定的StubRoutine中运行，而不是在原来的java代码中运行。</p><p>看一下Hotspot StubRoutine的代表性实例<br><img src="img/Safepoint/5.png" alt="github"><br>这个叫做StubRoutineBlob，代表了汇编代码。</p><ol><li>我们说在循环中间进行曲折进给，这意味着栈上没有正确的返回地址，所以我们要解决这个问题，所以我吗需要为他分配一个槽。</li><li>这里很重要，我们正在栈上建立一个新栈帧，一个与java代码本身没有直接关系的对象，而是一个元对象。并且因为jvm是java语言的元理论的实现，可以看到很多这些元结构与真正的java代码混合在一起，所以让我们称这个对象为合成帧或者Stub帧来表示这种差异。</li><li>rflags寄存器被推入栈</li><li>如果还记得调用约定，说过堆栈需要在16字节边界上对齐</li><li>然后将cpu上下文的通用寄存器溢出到栈上</li><li>此处浮点寄存器也被溢出，如果查看这些Stub帧的大小，会发现她们非常大，例如此帧大小为360个字或近3000个字节，而这样做的原因当然是大部分cpu上下文都溢出了</li><li>如果记得在信号处理程序中，我们保存了错误指令的地址，我们现在将这个地址写入我们一开始分配的栈槽，我们这样做是为了让他成为返回地址，这样做的原因不仅仅是为了以后能够返回到代码中断的地方，更重要的是，test指令有一个关联的OopMap，并且在安全点期间，栈必须具有所有返回地址的OopMaps，而StubRoutines发挥的另一个重要的作用是在java ABI和特定平台ABI之间切换，这也是为什么这些Stub帧是平台特定的原因。</li><li>可以看到，因为我吗即将调用进入JVM，改掉用需要在此处添加到平台ABI的调用，对于这个例子在windows上，首先需要分配一个32字节的栈空间，然后将线程作为rcx中的第一个参数传递</li><li>在我们对安全点定义中，说过所有java线程的线程本地gc根都可以访问或发布到jvm，并且详细说明了_last_java_frame是发布到jvm的重要部分，因为它提供了遍历栈的入口点，其cpu上下文的一部分，直接在寄存器中，因此出现了一个棘手的问题，即如何使线程的cpu上下文可访问或发布到jvm以使其到达安全点，答案是使用Stub帧提供解决方案，通过将cpu上下文溢出到栈中，进入这些Stub帧之一，她看起来就像一个常规帧。cpu上下被塑造成一个栈帧。</li><li>所以确实可以在这里看到_last_java_frame或锚字段将被设置为指向Stub帧而不是真正的java代码帧</li><li>重要的方面也是这些合成Stub帧也有OopMaps，这个特定的OopMap将详细说明每个寄存器在堆栈上的位置，OopMap的值类型表示栈位置，确实属于调用者帧，这里是fibonacci方法，之前提到了一个RegisterMap，其中也会填充那些Stub帧中的位置信息，并与调用者中的OopMap一起，即fibonacci方法的OopMap，表示放在寄存器中的oops可以被解析出</li></ol><h3 id="SafepointSynchronize-block"><a href="#SafepointSynchronize-block" class="headerlink" title="SafepointSynchronize::block()"></a>SafepointSynchronize::block()</h3><p>所以负责将这个特定线程的cpu上下文和堆栈导出到VM。当我们最终进入VM操作的时候，将java线程的线程状态字段设置为阻塞，连同Full Fence完全内存屏障指令，这对于线程本地gc根可见或发不到VM非常重要。线程现在将等待全局信号量，在VM线程运行VM操作之后，她发出信号量以及当线程恢复的时候，他将解除自己的轮询页并从中断的地方继续执行。<br><img src="img/Safepoint/6.png" alt="github"></p><p>至此，关于Hotspot JVM中的安全点到此结束。<br>Safepoint 可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，线程可以暂停。在 SafePoint 保存了其他位置没有的一些当前线程的运行信息，供其他线程读取。这些信息包括：线程上下文的任何信息，例如对象或者非对象的内部指针等等。我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息，才是确定的，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候，才会感知。</p>]]></content>
    
    
    <summary type="html">JVM—SafePoint</summary>
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java锁</title>
    <link href="http://example.com/2023/03/15/java%E9%94%81/"/>
    <id>http://example.com/2023/03/15/java%E9%94%81/</id>
    <published>2023-03-15T23:24:22.000Z</published>
    <updated>2023-03-16T11:08:07.649Z</updated>
    
    <content type="html"><![CDATA[<p>Java中常见锁分为两种：一种是<code>Synchronized</code>修饰的锁；另一种就是<code>java.util.concurrent</code>包下的各种同步锁，他们基于<code>AbstractQueuedSynchronizer（AQS）框架来构建的</code>，而<code>AQS</code>的核心数据结构是<code>CLH锁</code>的变体。</p><h2 id="一、无锁、偏向锁、轻量级锁和重量级锁"><a href="#一、无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="一、无锁、偏向锁、轻量级锁和重量级锁"></a>一、无锁、偏向锁、轻量级锁和重量级锁</h2><p>Synchronized 锁的底层类别</p><div class="table-container"><table><thead><tr><th>所状态</th><th>存储内容</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td>01</td><td></td></tr><tr><td>偏向锁</td><td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td>01</td><td></td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td><td></td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>10</td><td></td></tr></tbody></table></div><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。它会随着竞争情况逐渐升级。synchronized 同步锁可以升级但是不可以降级，目的是为了提高获取锁和释放锁的效率。<br><strong><em>在jdk1.6之前，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，这种方式就是synchronized最初实现同步的方式（依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步），synchronized 是重量级锁，效率低下。</em></strong></p><p>在jvm中，对象在内存中除了本身的数据外还会有个对象头，其对象头中有两类信息：<code>mark word</code>和<code>类型指针</code>；另外对于数组而言还会有一份记录数组长度的数据。类型指针是指向该对象所属类对象的指针，mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32bit，64位系统上长度为64bit。<br><img src="/img/JavaLock/0.png" alt="github"><br>表格中可以看到存储数据格式会随着锁的不同而不同。<br>当对象状态为偏向锁时，mark word存储的是偏向的线程ID；当状态为轻量级锁时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁时，为指向堆中的monitor对象的指针。</p><h2 id="1-1-全局安全点（safepoint）"><a href="#1-1-全局安全点（safepoint）" class="headerlink" title="1.1 全局安全点（safepoint）"></a>1.1 全局安全点（safepoint）</h2><p>代表了一个状态，在该状态下所有线程都是暂停的。</p><h2 id="1-2-偏向锁"><a href="#1-2-偏向锁" class="headerlink" title="1.2 偏向锁"></a>1.2 偏向锁</h2><p>偏向锁在获取资源的时候会在资源对象上记录该对象是偏向该线程的，偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。</p><h3 id="1-2-1-偏向锁获取过程"><a href="#1-2-1-偏向锁获取过程" class="headerlink" title="1.2.1 偏向锁获取过程"></a>1.2.1 偏向锁获取过程</h3><ol><li>访问Mark Word中偏向锁标志位是否设置成1，锁标志位是否为01——确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>执行同步代码。</li></ol><h3 id="1-2-2-偏向锁的释放"><a href="#1-2-2-偏向锁的释放" class="headerlink" title="1.2.2.偏向锁的释放"></a>1.2.2.偏向锁的释放</h3><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点safepoint，它会首先暂停拥有偏向锁的线程A，然后判断这个线程A，此时有两种情况：</p><ol><li>A线程已经退出了同步代码块，或者是已经不存活了，如果是上面两种情况之一的，此时就会直接撤销偏向锁，变成无锁状态</li><li>A线程还在同步代码块中，此时将A线程的偏向锁升级为轻量级锁。下面说明了怎么升级。</li></ol><h3 id="1-2-3-批量重偏向"><a href="#1-2-3-批量重偏向" class="headerlink" title="1.2.3 批量重偏向"></a>1.2.3 批量重偏向</h3><h4 id="为什么有批量重偏向"><a href="#为什么有批量重偏向" class="headerlink" title="为什么有批量重偏向"></a>为什么有批量重偏向</h4><p>当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。这个过程是要消耗一定的成本的，所以如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p><h4 id="批量重偏向的原理"><a href="#批量重偏向的原理" class="headerlink" title="批量重偏向的原理"></a>批量重偏向的原理</h4><ol><li>首先引入一个概念epoch，其本质是一个时间戳，代表了偏向锁的有效性，epoch存储在可偏向对象的MarkWord中。除了对象中的epoch，对象所属的类class信息中，也会保存一个epoch值。</li><li>每当遇到一个全局安全点时(这里的意思是说批量重偏向没有完全替代了全局安全点，全局安全点是一直存在的)，比如要对class C 进行批量再偏向，则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new</li><li>然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，仅将epoch_new的值赋给被锁定的对象中，也就是现在偏向锁还在被使用的对象才会被赋值epoch_new。</li><li>退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为（3）步骤里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作。</li></ol><h2 id="1-3-轻量级锁"><a href="#1-3-轻量级锁" class="headerlink" title="1.3 轻量级锁"></a>1.3 轻量级锁</h2><h3 id="1-3-1-轻量级锁的获取过程"><a href="#1-3-1-轻量级锁的获取过程" class="headerlink" title="1.3.1 轻量级锁的获取过程"></a>1.3.1 轻量级锁的获取过程</h3><ol><li>在代码进入同步块的时候，如果同步对象锁状态为偏向状态（就是锁标志位为“01”状态，是否为偏向锁标志位为“1”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。官方称之为 Displaced Mark Word（所以这里我们认为Lock Record和 Displaced Mark Word其实是同一个概念）。这时候线程堆栈与对象头的状态如图所示：<br><img src="/img/JavaLock/1.png" alt="github"></li><li><p>拷贝对象头中的Mark Word复制到锁记录中。</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象头的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象头的mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p></li><li><p>如果上面这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下所示：<br><img src="/img/JavaLock/2.png" alt="github"></p></li><li><p>如果上面这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧。</p></li></ol><ul><li>如果是就说明当前线程已经拥有了这个对象的锁，现在是重入状态，那么设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。重入之后然后结束。接着就可以直接进入同步块继续执行。</li><li>如果不是说明这个锁对象已经被其他线程抢占了，说明此时有多个线程竞争锁，那么它就会自旋等待锁，一定次数后仍未获得锁对象，说明发生了竞争，需要膨胀为重量级锁。</li></ul><p>自旋原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗 CPU 的，如果一直获取不到锁，那线程也不能一直占用 CPU 自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM 对于自旋周期的选择，JDK1.6 之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，自旋不会一直持续下去，这时争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁。</p><h3 id="1-3-2-轻量级锁的解锁过程"><a href="#1-3-2-轻量级锁的解锁过程" class="headerlink" title="1.3.2 轻量级锁的解锁过程"></a>1.3.2 轻量级锁的解锁过程</h3><ul><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</li><li>如果替换成功，整个同步过程就完成了。</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ul><h2 id="1-4-重量级锁"><a href="#1-4-重量级锁" class="headerlink" title="1.4 重量级锁"></a>1.4 重量级锁</h2><h3 id="1-4-1-重量级锁加锁和释放锁机制"><a href="#1-4-1-重量级锁加锁和释放锁机制" class="headerlink" title="1.4.1 重量级锁加锁和释放锁机制"></a>1.4.1 重量级锁加锁和释放锁机制</h3><p>调用omAlloc分配一个ObjectMonitor对象，把锁对象头的mark word锁标志位变成 “10 ”，然后在mark word存储指向ObjectMonitor对象的指针</p><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><img src="/img/JavaLock/3.png" alt="github"></p><ol><li>当多个线程同时访问一段同步代码时，首先会进入 _EntryList 队列中。</li><li>当某个线程获取到对象的Monitor后进入临界区域，并把Monitor中的 _owner 变量设置为当前线程，同时Monitor中的计数器 _count 加1。即获得对象锁。</li><li>若持有Monitor的线程调用 wait() 方法，将释放当前持有的Monitor，*owner变量恢复为null，*count自减1，同时该线程进入 _WaitSet 集合中等待被唤醒。</li><li>在WaitSet 集合中的线程会被再次放到EntryList 队列中，重新竞争获取锁。</li><li>若当前线程执行完毕也将释放Monitor并复位变量的值，以便其他线程进入获取锁。</li></ol><h3 id="1-4-2-Monitor-对象"><a href="#1-4-2-Monitor-对象" class="headerlink" title="1.4.2 Monitor 对象"></a>1.4.2 Monitor 对象</h3><p>本质上是一个管程：管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。<br>在HotSpot虚拟机中，Monitor是基于C++的ObjectMonitor类实现的，结构体如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>    _header       = NULL;<br>    _count        = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 约为 _WaitSet 和 _EntryList 的节点数之和</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录重入次数</span><br>    _object       = NULL;<br>    _owner        = NULL; <span class="hljs-comment">// _owner指向持有ObjectMonitor对象的线程</span><br>    _WaitSet      = NULL; <span class="hljs-comment">// 双向循环链表：存放处于wait状态的线程队列，即调用wait()方法的线程</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = NULL ;<br>    _succ         = NULL ;<br>    _cxq          = NULL ;  <span class="hljs-comment">// 单向链表：多个线程争抢锁，会先存入这个</span><br>    FreeNext      = NULL ;<br>    _EntryList    = NULL ;  <span class="hljs-comment">// 双向循环链表：存放处于等待锁block状态的线程队列</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h3 id="1-4-3-锁竞争机制"><a href="#1-4-3-锁竞争机制" class="headerlink" title="1.4.3 锁竞争机制"></a>1.4.3 锁竞争机制</h3><p><code>ObjectMonitor::enter()</code> 和 <code>ObjectMonitor::exit()</code> 分别是ObjectMonitor获取锁和释放锁的方法。线程解锁后还会唤醒之前等待的线程，根据策略选择直接唤醒_cxq队列中的头部线程去竞争，或者将_cxq队列中的线程加入_EntryList，然后再唤醒_EntryList队列中的线程去竞争。</p><h2 id="1-5-synchronized关键字"><a href="#1-5-synchronized关键字" class="headerlink" title="1.5 synchronized关键字"></a>1.5 synchronized关键字</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>同步代码块的加锁、解锁是通过 Javac 编译器实现的，底层是借助monitorenter和monitorerexit，为了能够保证无论代码块正常执行结束 or 抛出异常结束，都能正确释放锁，Javac 编译器在编译的时候，会对monitorerexit进行特殊处理<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 同步数据</span><br>            System.out.println(<span class="hljs-string">&quot;hehehe&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后通过<code>javap -c Test.class &gt;&gt; test.txt</code>查看其编译后的字节码:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.Test();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: dup<br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: monitorenter<br>       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       7: ldc           #3                  // String hehehe<br>       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>      <span class="hljs-number">12</span>: aload_1<br>      <span class="hljs-number">13</span>: monitorexit<br>      <span class="hljs-number">14</span>: goto          <span class="hljs-number">22</span><br>      <span class="hljs-number">17</span>: astore_2<br>      <span class="hljs-number">18</span>: aload_1<br>      <span class="hljs-number">19</span>: monitorexit<br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: athrow<br>      <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">4</span>    <span class="hljs-number">14</span>    <span class="hljs-number">17</span>   any<br>          <span class="hljs-number">17</span>    <span class="hljs-number">20</span>    <span class="hljs-number">17</span>   any<br>&#125;<br></code></pre></td></tr></table></figure><br>monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取mark word里面存储的monitor，当 monitor的进入计数器为 0，那线程可以成功取得monitor，并将计数器值设置为1，取锁成功。</p><p>值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从上面的字节码中也可以看出有两个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><h3 id="同步实例方法"><a href="#同步实例方法" class="headerlink" title="同步实例方法"></a>同步实例方法</h3><p>同步方法的加锁、解锁是通过 Javac 编译器实现的，底层是借助<code>ACC_SYNCHRONIZED</code>访问标识符来实现的，代码如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步数据</span><br>        System.out.println(<span class="hljs-string">&quot;hehehe&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.Test();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       3: ldc           #3                  // String hehehe<br>       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h3><p>给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀ 个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有 ⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤ 这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前 实例对象锁。</p><h2 id="、乐观锁和悲观锁"><a href="#、乐观锁和悲观锁" class="headerlink" title="、乐观锁和悲观锁"></a>、乐观锁和悲观锁</h2><p>Java中，<code>synchronized关键字</code>和<code>Lock的实现类</code>都是悲观锁。悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 悲观锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    lock.lock();<br>    <span class="hljs-comment">// 同步数据</span><br>    lock.unlock();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 同步数据</span><br>&#125;<br><br><span class="hljs-comment">// 乐观锁</span><br><span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>atomicInteger.incrementAndGet();<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">Java锁</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中的CAS操作</title>
    <link href="http://example.com/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/"/>
    <id>http://example.com/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/</id>
    <published>2023-03-15T22:01:12.000Z</published>
    <updated>2023-03-20T02:20:13.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是CAS"><a href="#一、什么是CAS" class="headerlink" title="一、什么是CAS"></a>一、什么是CAS</h2><p>Compare And Swap的缩写，中文翻译成比较并交换。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><h2 id="二、引出CAS"><a href="#二、引出CAS" class="headerlink" title="二、引出CAS"></a>二、引出CAS</h2><p>看看下面代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> COUNT = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(COUNT);<br><br>    <span class="hljs-keyword">final</span> Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                count++;<br>                atomicInteger.getAndIncrement();<br>            &#125;<br>            latch.countDown();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; COUNT; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(runnable).start();<br>    &#125;<br>    latch.await();<br>    System.out.println(<span class="hljs-string">&quot;理论结果：&quot;</span> + <span class="hljs-number">1000</span>*COUNT);<br>    System.out.println(<span class="hljs-string">&quot;count:&quot;</span> + count);<br>    System.out.println(<span class="hljs-string">&quot;atomic:&quot;</span> + atomicInteger.intValue());<br>&#125;<br></code></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">理论结果：<span class="hljs-number">10000</span><br>count:<span class="hljs-number">9997</span><br>atomic:<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><br>多次允许后发现，count的结果永远不正确，而atomic的数据永远是正确的。</p><h2 id="三、Atomic"><a href="#三、Atomic" class="headerlink" title="三、Atomic"></a>三、Atomic</h2><p>根据操作的目标数据类型</p><ul><li>基本原子类</li><li>数组原子类</li><li>原子引用类型</li><li>字段更新原子类</li></ul><h2 id="3-1-基本原子类"><a href="#3-1-基本原子类" class="headerlink" title="3.1 基本原子类"></a>3.1 基本原子类</h2><p>基本原子类的功能，是通过原子方式更新 Java 基础类型变量的值。基本原子类主要包括了以下三个：</p><ul><li>AtomicInteger：整型原子类。</li><li>AtomicLong：长整型原子类。 </li><li>AtomicBoolean ：布尔型原子类。</li></ul><h2 id="3-2-数组原子类"><a href="#3-2-数组原子类" class="headerlink" title="3.2 数组原子类"></a>3.2 数组原子类</h2><p>数组原子类的功能，是通过原子方式更数组里的某个元素的值。数组原子类主要包括了以下三个：</p><ul><li>AtomicIntegerArray：整型数组原子类。</li><li>AtomicLongArray：长整型数组原子类。</li><li>AtomicReferenceArray ：引用类型数组原子类。</li></ul><h2 id="3-3-原子引用类型"><a href="#3-3-原子引用类型" class="headerlink" title="3.3 原子引用类型"></a>3.3 原子引用类型</h2><p>引用原子类主要包括了以下三个：</p><ul><li>AtomicReference：引用类型原子类。</li><li>AtomicMarkableReference ：带有更新标记位的原子引用类型。</li><li>AtomicStampedReference ：带有更新版本号的原子引用类型。<br><strong><em>AtomicStampedReference通过引入“版本”的概念，来解决ABA的问题。</em></strong></li></ul><h2 id="3-4-字段更新原子类"><a href="#3-4-字段更新原子类" class="headerlink" title="3.4 字段更新原子类"></a>3.4 字段更新原子类</h2><p>字段更新原子类主要包括了以下三个：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器。 </li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li></ul><h2 id="3-5-基本函数"><a href="#3-5-基本函数" class="headerlink" title="3.5 基本函数"></a>3.5 基本函数</h2><div class="table-container"><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取当前的值</td></tr><tr><td>public final int getAndSet(int newValue)</td><td>获取当前的值，然后设置新的值</td></tr><tr><td>public final int getAndIncrement()</td><td>获取当前的值，然后自增</td></tr><tr><td>public final int getAndDecrement()</td><td>获取当前的值，然后自减</td></tr><tr><td>public final int getAndAdd(int delta)</td><td>获取当前的值，并加上预期的值</td></tr><tr><td>boolean compareAndSet(int expect, int update)</td><td>通过 CAS 方式设置整数值</td></tr></tbody></table></div><h2 id="3-6-Unsafe类"><a href="#3-6-Unsafe类" class="headerlink" title="3.6 Unsafe类"></a>3.6 Unsafe类</h2><p>Unsafe 提供了CAS 方法，直接通过native 方式（封装 C++代码）调用了底层的 CPU 指令 cmpxchg。从名字中我们可以看出来这个类对普通程序员来说是“危险”的，一般应用开发者不会用到这个类。</p><h3 id="3-6-1-Unsafe-提供的-CAS-方法"><a href="#3-6-1-Unsafe-提供的-CAS-方法" class="headerlink" title="3.6.1 Unsafe 提供的 CAS 方法"></a>3.6.1 Unsafe 提供的 CAS 方法</h3><p>主要如下： 定义在 Unsafe 类中的三个 “比较并交换”原子方法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@param o 包含要修改的字段的对象</span><br><span class="hljs-comment">@param offset 字段在对象内的偏移量</span><br><span class="hljs-comment">@param expected 期望值（旧的值）</span><br><span class="hljs-comment">@param update 更新值（新的值）</span><br><span class="hljs-comment">@return true 更新成功 | false 更新失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object expected, Object update)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">( Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> update)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">( Object o, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">long</span> expected, <span class="hljs-keyword">long</span> update)</span></span>;<br></code></pre></td></tr></table></figure><br>Unsafe 提供的 CAS 方法包含四个入参： 包含要修改的字段对象、字段内存位置、预期原值及新值。<br>在执行 Unsafe 的 CAS 方法的时候，这些方法首先将内存位置的值与预期值（旧的值）比较，如果相匹配，那么处理器会自动将该内存位置的值更新为新值，并返回 true ；如果不相匹配，处理器不做任何操作，并返回 false 。<br><img src="img/CAS/1.png" alt="github"><br>CAS操作由处理器提供支持，是一种原语。原语是操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。如 Intel 处理器，比较并交换通过指令的 cmpxchg 系列实现。</p><h3 id="3-6-2-获取属性偏移量"><a href="#3-6-2-获取属性偏移量" class="headerlink" title="3.6.2 获取属性偏移量"></a>3.6.2 获取属性偏移量</h3><p>Unsafe 提供的获取字段（属性）偏移量的相关操作，主要如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> o 需要操作属性的反射 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 属性的偏移量 </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">staticFieldOffset</span><span class="hljs-params">(Field field)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field field)</span></span>;<br></code></pre></td></tr></table></figure></p><ul><li>staticFieldOffset 方法用于获取静态属性 Field 在 Class 对象中的偏移量，在 CAS 操作静态属性时，会用到这个偏移量。</li><li>objectFieldOffset 方法用于获取非静态 Field （非静态属性）在 Object 实例中的偏移量，在 CAS 操作对象的非静态属性时，会用到这个偏移量。</li></ul><h3 id="3-6-3-根据属性的偏移量获取属性的最新值"><a href="#3-6-3-根据属性的偏移量获取属性的最新值" class="headerlink" title="3.6.3 根据属性的偏移量获取属性的最新值:"></a>3.6.3 根据属性的偏移量获取属性的最新值:</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> o 字段所属于的对象实例</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> fieldOffset 字段的偏移量 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 字段的最新值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> fieldOffset)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="四、CAS的缺点"><a href="#四、CAS的缺点" class="headerlink" title="四、CAS的缺点"></a>四、CAS的缺点</h2><h2 id="4-1-ABA问题"><a href="#4-1-ABA问题" class="headerlink" title="4.1  ABA问题"></a>4.1  ABA问题</h2><p>一个线程先读取共享内存数据值A，随后因某种原因，线程暂时挂起，同时另一个线程临时将共享内存数据值先改为B，随后又改回为A。随后挂起线程恢复，并通过CAS比较，最终比较结果将会无变化。这样会通过检查，这就是ABA问题。<br>JDK 提供了两个类 AtomicStampedReference、AtomicMarkableReference 来解决 ABA 问题。</p><h2 id="4-2-只能保证一个共享变量的原子操作"><a href="#4-2-只能保证一个共享变量的原子操作" class="headerlink" title="4.2 只能保证一个共享变量的原子操作"></a>4.2 只能保证一个共享变量的原子操作</h2><p>一个比较简单的规避方法为：把多个共享变量合并成一个共享变量来操作。 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，可以把多个变量放在一个 AtomicReference 实例后再进行 CAS 操作。比如有两个共享变量 i＝1、j=2，可以将二者合并成一个对象，然后用 CAS 来操作该合并对象的 AtomicReference 引用。</p><h2 id="4-3-循环时间长开销大"><a href="#4-3-循环时间长开销大" class="headerlink" title="4.3 循环时间长开销大"></a>4.3 循环时间长开销大</h2><p>高并发下N多线程同时去操作一个变量，会造成大量线程CAS失败，然后处于自旋状态，导致严重浪费CPU资源，降低了并发性。</p><h4 id="解决-CAS-恶性空自旋的较为常见的方案为："><a href="#解决-CAS-恶性空自旋的较为常见的方案为：" class="headerlink" title="解决 CAS 恶性空自旋的较为常见的方案为："></a>解决 CAS 恶性空自旋的较为常见的方案为：</h4><ul><li>分散操作热点，使用 LongAdder 替代基础原子类 AtomicLong。</li><li>使用队列削峰，将发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度。JUC 中非常重要的基础类 AQS（抽象队列同步器）就是这么做的。</li></ul><h2 id="五、以空间换时间：LongAdder"><a href="#五、以空间换时间：LongAdder" class="headerlink" title="五、以空间换时间：LongAdder  "></a>五、以空间换时间：LongAdder  </h2><h2 id="5-1-LongAdder-的原理"><a href="#5-1-LongAdder-的原理" class="headerlink" title="5.1 LongAdder 的原理"></a>5.1 LongAdder 的原理</h2><p>LongAdder 的基本思路就是分散热点， 如果有竞争的话，内部维护了多个Cell变量，每个Cell里面有一个初始值为0的long型变量， 不同线程会命中到数组的不同Cell （槽 ）中，各个线程只对自己Cell（槽） 中的那个值进行 CAS 操作。这样热点就被分散了，冲突的概率就小很多。<br>在没有竞争的情况下，要累加的数通过 CAS 累加到 base 上。<br>如果要获得完整的 LongAdder 存储的值，只要将各个槽中的变量值累加，后的值即可。<br><img src="img/CAS/0.png" alt="github"></p><h2 id="5-2-longAddr内部结构"><a href="#5-2-longAddr内部结构" class="headerlink" title="5.2 longAddr内部结构"></a>5.2 longAddr内部结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">|-----------|<br>| Striped64 |       |------------|<br>|___________|       |Serializable|<br>      ^             |____________|<br>      |                    ^<br>      |                    |<br>|-----------|              |<br>| LongAdder |--------------|<br>|___________|<br></code></pre></td></tr></table></figure><h3 id="5-2-1-Striped64类的重要成员属性"><a href="#5-2-1-Striped64类的重要成员属性" class="headerlink" title="5.2.1 Striped64类的重要成员属性"></a>5.2.1 Striped64类的重要成员属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cell表，当非空时，大小是2的幂。  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基础值，主要在没有争用时使用</span><br><span class="hljs-comment"> * 在没有争用时使用CAS更新这个值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自旋锁(通过CAS锁定) 在调整大小和或创建cell时使用,</span><br><span class="hljs-comment"> * 为 0 表示 cells 数组没有处于创建、扩容阶段,反之为1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p>内部包含一个 base 和一个 Cell[] 类型的 cells 数组 。 在没有竞争的情况下，要累加的数通过 CAS 累加到 base 上；如果有竞争的话，会将要累加的数累加到 Cells 数组中的某个 cell 元素里面。所以 Striped64 的整体值 value 为 base+ ∑ [0~n]cells 。</p><h3 id="5-2-2-LongAdder的整体值-value-的获取源码"><a href="#5-2-2-LongAdder的整体值-value-的获取源码" class="headerlink" title="5.2.2 LongAdder的整体值 value 的获取源码"></a>5.2.2 LongAdder的整体值 value 的获取源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">longValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sum();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Striped64.Cell[] as = cells;<br>    Striped64.Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>triped64 的设计核心思路就是通过内部的分散计算来避免竞争，以空间换时间。 LongAdder<br>的 base 类似于 AtomicInteger 里面的 value ，在没有竞争的情况，cells 数组为 null ，这时只使用 base 做累加；而一旦发生竞争，cells 数组就上场了。<br>cells 数组第一次初始化长度为 2 ，以后每次扩容都是变为原来的两倍，一直到 cells 数组的长<br>度大于等于当前服务器 CPU 的核数。为什么呢？同一时刻，能持有 CPU 时间片而去并发操作同<br>一个内存地址的最大线程数，最多也就是 CPU 的核数。<br>在存在线程争用的时候，每个线程被映射到 cells[threadLocalRandomProbe &amp; cells.length] 位置的 Cell 元素，该线程对 value 所做的累加操作，就执行在对应的 Cell 元素的值上，最终相当于将线程绑定到了 cells 中的某个 cell 对象上。</p><h2 id="5-3-LongAdder-类的-add-方法"><a href="#5-3-LongAdder-类的-add-方法" class="headerlink" title="5.3 LongAdder 类的 add 方法"></a>5.3 LongAdder 类的 add 方法</h2><h3 id="5-3-1-自增"><a href="#5-3-1-自增" class="headerlink" title="5.3.1 自增"></a>5.3.1 自增</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-自减"><a href="#5-3-2-自减" class="headerlink" title="5.3.2 自减"></a>5.3.2 自减</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>    add(-<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-add方法"><a href="#5-3-3-add方法" class="headerlink" title="5.3.3 add方法"></a>5.3.3 add方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//as: 表示cells引用</span><br>    <span class="hljs-comment">//b: base值</span><br>    <span class="hljs-comment">//v: 表示当前线程命中的cell的期望值</span><br>    <span class="hljs-comment">//m: 表示cells数组长度</span><br>    <span class="hljs-comment">//a: 表示当前线程命中的cell</span><br>    Striped64.Cell[] as;<br>    <span class="hljs-keyword">long</span> b, v;<br>    <span class="hljs-keyword">int</span> m;<br>    Striped64.Cell a;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    stop 1：true -&gt; 说明存在竞争，并且cells数组已经初始化了，当前线程需要将数据写入到对应的cell中</span><br><span class="hljs-comment">           false -&gt; 表示cells未初始化，当前所有线程应该将数据写到base中</span><br><span class="hljs-comment">    stop 2：true -&gt; 表示发生竞争了，可能需要重试或者扩容</span><br><span class="hljs-comment">           false -&gt; 表示当前线程cas替换数据成功</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (<br>            (as = cells) != <span class="hljs-keyword">null</span>  <span class="hljs-comment">//stop 1</span><br>            ||<br>            !casBase(b = base, b + x) <span class="hljs-comment">//stop 2</span><br>    ) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        进入的条件：</span><br><span class="hljs-comment">        1.cells数组已经初始化了，当前线程需要将数据写入到对应的cell中</span><br><span class="hljs-comment">        2.表示发生竞争了，可能需要重试或者扩容</span><br><span class="hljs-comment">        */</span><br> <br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">        是否有竞争：true -&gt; 没有竞争</span><br><span class="hljs-comment">                   false -&gt; 有竞争*/</span><br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        stop 3：as == null || (m = as.length - 1)&lt;0 代表 cells 没有初始化</span><br><span class="hljs-comment">        stop 4：表示当前线程命中的cell为空，意思是还没有其他线程在同一个位置做过累加操作。</span><br><span class="hljs-comment">        stop 5：表示当前线程命中的cell不为空， 然后在该Cell对象上进行CAS设置其值为v+x（x为该 Cell 需要累加的值），如果CAS操作失败，表示存在争用。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> || <span class="hljs-comment">//stop 3</span><br>                (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> || <span class="hljs-comment">//stop 4</span><br>                !(uncontended = a.cas(v = a.value, v + x))) <span class="hljs-comment">//stop 5</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            进入的条件：</span><br><span class="hljs-comment">            1.cells 未初始化</span><br><span class="hljs-comment">            2.当前线程对应下标的cell为空</span><br><span class="hljs-comment">            3.当前线程对应的cell有竞争并且cas失败</span><br><span class="hljs-comment">            */</span><br>            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="img/CAS/2.png" alt="github"></p><h3 id="5-3-4-longAccumulate方法"><a href="#5-3-4-longAccumulate方法" class="headerlink" title="5.3.4 longAccumulate方法"></a>5.3.4 longAccumulate方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//条件成立: 说明当前线程还未分配hash值</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1.给当前线程分配hash值</span><br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        <span class="hljs-comment">//2.提取当前线程的hash值</span><br>        h = getProbe();<br>        <span class="hljs-comment">//3.因为上一步提取了重新分配的新的hash值，所以会重新分配cells数组的位置给当前线程写入，先假设它能找到一个元素不冲突的数组下标。</span><br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//扩容意向，collide=true 可以扩容，collide=false 不可扩容</span><br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-comment">//自旋，一直到操作成功</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//as: 表示cells引用</span><br>        <span class="hljs-comment">//a: 当前线程命中的cell</span><br>        <span class="hljs-comment">//n: cells数组长度</span><br>        <span class="hljs-comment">//a: 表示当前线程命中的cell的期望值</span><br>        Striped64.Cell[] as; Striped64.Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//CASE1: cells数组已经初始化了，当前线程将数据写入到对应的cell中</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//CASE1.1: true 表示下标位置的 cell 为 null，需要创建 new Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// cells 数组没有处于创建、扩容阶段</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    Striped64.Cell r = <span class="hljs-keyword">new</span> Striped64.Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-comment">// cas去加锁</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Striped64.Cell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">// 再次判断cells不为空 &amp; 槽位为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                    (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                    rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                rs[j] = r;<br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<span class="hljs-comment">//创建、扩容成功，退出自旋</span><br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// CASE1.2：当前线程竞争修改cell失败</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">// CASE 1.3：当前线程 rehash 过 hash 值,CAS 更新 Cell</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                    fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// CASE1.4:判断是否可以扩容</span><br>            <span class="hljs-comment">//  CASE1.4.1：n &gt;= NCPU</span><br>            <span class="hljs-comment">//      true -&gt; cells数组长度已经 &gt;= cpu核数，不可进行扩容，把扩容意向改为false</span><br>            <span class="hljs-comment">//      false -&gt; 可扩容</span><br>            <span class="hljs-comment">//  CASE1.4.2：cells != as</span><br>            <span class="hljs-comment">//      true -&gt; 其它线程已经扩容过了，当前线程rehash之后重试即可</span><br>            <span class="hljs-comment">//      false -&gt; 未有线程对cells进行修改</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 把扩容意向改为false</span><br>            <span class="hljs-comment">// CASE 1.5:设置扩容意向为 true，但是不一定真的发生扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//CASE1.6:真正扩容的逻辑</span><br>            <span class="hljs-comment">//  CASE1.6.1：cellsBusy == 0</span><br>            <span class="hljs-comment">//      true -&gt; 表示cells没有被其它线程占用，当前线程可以去竞争锁</span><br>            <span class="hljs-comment">//      false -&gt; 表示有其它线程正在操作cells</span><br>            <span class="hljs-comment">//  CASE1.6.2：casCellsBusy()</span><br>            <span class="hljs-comment">//      true -&gt; 表示当前线程获取锁成功，可以进行扩容操作</span><br>            <span class="hljs-comment">//      false -&gt; 表示当前线程获取锁失败，当前时刻有其它线程在做扩容相关的操作</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//重复判断一下当前线程的临时cells数组是否与原cells数组一致(防止有其它线程提前修改了cells数组，因为cells是volatile的全局变量)</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        <span class="hljs-comment">//n &lt;&lt; 1 表示数组长度翻一倍</span><br>                        Striped64.Cell[] rs = <span class="hljs-keyword">new</span> Striped64.Cell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//扩容后，将扩容意向置为false</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            <span class="hljs-comment">//重置当前线程hash值</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//CASE2：cells 还未初始化（as 为 null）,并且 cellsBusy 加锁成功</span><br>        <span class="hljs-comment">//  CASE2.1：判断锁是否被占用</span><br>        <span class="hljs-comment">//         true -&gt; 表示当前未加锁</span><br>        <span class="hljs-comment">//         false -&gt; 表示当前已加锁</span><br>        <span class="hljs-comment">//  CASE2.2：因为其它线程可能会在当前线程给as赋值之后修改了cells</span><br>        <span class="hljs-comment">//         true -&gt; cells没有被其它线程修改</span><br>        <span class="hljs-comment">//         false -&gt; cells已经被其它线程修改</span><br>        <span class="hljs-comment">// CASE2.3：获取锁</span><br>        <span class="hljs-comment">//         true -&gt; 获取锁成功 会把cellsBusy = 1</span><br>        <span class="hljs-comment">//         false -&gt; 表示其它线程正在持有这把锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//双重检查，防止其它线程已经初始化，当前线程再次初始化，会导致数据丢失</span><br>                <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    Striped64.Cell[] rs = <span class="hljs-keyword">new</span> Striped64.Cell[<span class="hljs-number">2</span>];<br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Striped64.Cell(x);<br>                    cells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//CASE3：当前线程 cellsBusy 加锁失败，表示其他线程正在初始化 cells</span><br>        <span class="hljs-comment">//所以当前线程将值累加到 base，注意 add(…)方法调用此方法时 fn 为 null</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="img/CAS/3.png" alt="github"></p><h3 id="5-3-5-LongAdder-类的-casCellsBusy-方法"><a href="#5-3-5-LongAdder-类的-casCellsBusy-方法" class="headerlink" title="5.3.5 LongAdder 类的 casCellsBusy 方法"></a>5.3.5 LongAdder 类的 casCellsBusy 方法</h3><p>casCellsBusy 方法的代码很简单，就是将 cellsBusy 成员的值改为 1 ，表示目前的 cells 数组在初始化或扩容中：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">casCellsBusy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="5-3-6-求和"><a href="#5-3-6-求和" class="headerlink" title="5.3.6 求和"></a>5.3.6 求和</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sum()方法很简单，就是将base值及所有cell值进行累加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、使用-AtomicStampedReference-解决-ABA-问题"><a href="#六、使用-AtomicStampedReference-解决-ABA-问题" class="headerlink" title="六、使用 AtomicStampedReference 解决 ABA 问题"></a>六、使用 AtomicStampedReference 解决 ABA 问题</h2><p>JDK 的提供了一个类似 AtomicStampedReference 类来解决 ABA 问题。<br>AtomicStampReference 在 CAS 的基础上增加了一个 Stamp 整型 印戳（或标记），使用这个印戳可以来觉察数据是否发生变化，给数据带上了一种实效性的检验。<br>AtomicStampReference 的 compareAndSet 方法首先检查当前的对象引用值是否等于预期引用，<br>并且当前印戳（ Stamp ）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳<br>（ Stamp ）标志的值更新为给定的更新值。</p><h2 id="6-1-AtomicStampReference-的构造器"><a href="#6-1-AtomicStampReference-的构造器" class="headerlink" title="6.1 AtomicStampReference 的构造器"></a>6.1 AtomicStampReference 的构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> initialRef初始引用  </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> initialStamp初始戳记  </span><br><span class="hljs-comment">*/</span><br>AtomicStampedReference(V initialRef, <span class="hljs-keyword">int</span> initialStamp)<br></code></pre></td></tr></table></figure><h2 id="6-2-AtomicStampReference-的常用的几个方法"><a href="#6-2-AtomicStampReference-的常用的几个方法" class="headerlink" title="6.2 AtomicStampReference 的常用的几个方法"></a>6.2 AtomicStampReference 的常用的几个方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>介绍                 </th></tr></thead><tbody><tr><td>public V getRerference()</td><td>引用的当前值</td></tr><tr><td>public int getStamp()</td><td>返回当前的”戳记”</td></tr><tr><td>public boolean weakCompareAndSet(V expectedReference,V newReference,int expectedStamp,int newStamp)</td><td>expectedReference 引用的旧值;newReference 引用的新值;expectedStamp 旧的戳记;newStamp 新的戳记  </td></tr></tbody></table></div><h2 id="6-3-例子"><a href="#6-3-例子" class="headerlink" title="6.3 例子"></a>6.3 例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>    AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();<br>    success = atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;success:&quot;</span> + success + <span class="hljs-string">&quot;;reference:&quot;</span> + <span class="hljs-string">&quot;&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;;stamp:&quot;</span> + atomicStampedReference.getStamp());<br>    <span class="hljs-comment">//修改印戳，更新失败</span><br>    stamp = <span class="hljs-number">0</span>;<br>    success = atomicStampedReference.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;success:&quot;</span> + success + <span class="hljs-string">&quot;;reference:&quot;</span> + <span class="hljs-string">&quot;&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;;stamp:&quot;</span> + atomicStampedReference.getStamp());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">java中的CAS操作</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型模式的讨论</title>
    <link href="http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/"/>
    <id>http://example.com/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/</id>
    <published>2023-03-13T22:14:00.000Z</published>
    <updated>2023-03-14T10:43:18.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>封装变化是很多行为模式的主题。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式依据这个对象 来命名。例如，</p><ul><li>一个 Strategy 对象封装一个算法。</li><li>一个 State 对象封装一个与状态相关的行为。</li><li>一个 Mediator对象封装对象间的协议。</li><li>一个 Iterator 对象封装访问和遍历一个聚集对象中的各个构件的方法。</li></ul><p>这些模式描述了程序中很可能会改变的方面。大多数模式有两种对象:封装该方面特征的新对象，和使用这些新的对象的已有对象。如果不使用这些模式的话，通常这些新对象的功能就会变成这些已有对象的难以分割的一部分。例如，一个 Strategy 的代码可能会被嵌入到其Context类中，而一个State的代码可能会在该状态的Context类中直接实现。<br>但不是所有的对象行为模式都象这样分割功能 。 例如 ， ChainofResponsibility 可以处理任意数目的对象(即一个链)，而所有这些对象可能已经存在于系统中了。<br>职责链说明了行为模式间的另一个不同点:并非所有的行为模式都定义类之间的静态通信关系。职责链提供在数目可变的对象间进行通信的机制。其他模式涉及到一些作为参数传递的对象。</p><h2 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h2><p>一些模式引入总是被用作参数的对象。例如 Visitor。一个Visitor对象是一个多态的Accept操作的参数 ， 这个操作作用于该Visitor对象访问的对象 。 虽然以前通常代替Visitor模式的方法是将Visitor代码分布在一些对象结构的类中，但visitor从来都不是它所访问的对象的一部分。<br>其他模式定义一些可作为令牌到处传递的对象，这些对象将在稍后被调用。Command和Memento都属于这一类。在Command中，令牌代表一个请求;而在Memento中，它代表在一个对象在某个特定时刻的内部状态。在这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会意识到这一点。但这里还有一些区别:在Command模式中多态很重要，因为执行Command对象是一个多态的操作。相反，Memento接口非常小，以至于备忘录只能作为一个值传递。因此它很可能根本不给它的客户提供任何多态操作。</p><h2 id="通信应该被封装还是被分布"><a href="#通信应该被封装还是被分布" class="headerlink" title="通信应该被封装还是被分布"></a>通信应该被封装还是被分布</h2><p>Mediator和Observer是相互竞争的模式。它们之间的差别是，Observer通过引入Observer和Subject对象来分布通信，而Mediator对象则封装了其他对象间的通信 。<br>在Observer模式中，不存在封装一个约束的单个对象，而必须是由Observer和Subject对象相互协作来维护这个约束。通信模式由观察者和目标连接的方式决定:一个目标通常有多个观察者，并且有时一个目标的观察者也是另一个观察者的目标。Mediator模式的目的是集中而不是分布。它将维护一个约束的职责直接放在一个中介者中。<br>我们发现生成可复用的Observer和Subject比生成可复用的Mediator容易一些。Observer模式有利于Observer和Subject间的分割和松耦合，同时这将产生粒度更细,从而更易于复用的类。<br>另一方面，相对于Observer，Mediator中的通信流更容易理解。观察者和目标通常在它们被创建后很快即被连接起来，并且很难看出此后它们在程序中是如何连接的。如果你了解Observer模式，你将知道观察者和目标间连接的方式是很重要的，并且你也知道寻找哪些连接。然而，Observer模式引入的间接性仍然会使得一个系统难以理解。<br>Smalltalk中的Observer可以用消息进行参数化以访问Subject的状态，因此与在C++中的Observer相比，它们具有更大的可复用性。这使得Smalltalk中Observer比Mediator更具吸引力。 因此一个Smalltalk程序员通常会使用Observer而一个C++程序员则会使用Mediator。</p><h2 id="对发送者和接收者解耦"><a href="#对发送者和接收者解耦" class="headerlink" title="对发送者和接收者解耦"></a>对发送者和接收者解耦</h2><p>当合作的对象直接互相引用时，它们变得互相依赖，这可能会对一个系统的分层和重用性产生负面影响。命令、观察者、中介者，和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。<br>命令模式使用一个Command对象来定义一个发送者和一个接收者之间的绑定关系，从而支持解耦，如下图所示。<br><img src="/img/DesignPatterns/26.png" alt="github"><br>Command对象提供了一个提交请求的简单接口(即Execute操作)。 将发送者和接收者之间的连接定义在一个单独的对象使得该发送者可以与不同的接收者一起工作。这就将发送者与接收者解耦，使发送者更易于复用。此外，可以复用Command对象，用不同的发送者参数化一个接收者。虽然Command模式描述了避免使用生成子类的实现技术，名义上每一个发送者-接收者连接都需要一个子类。<br>观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者(目标)与接收 者(观察者)解耦。 O b s e r v e r 定义了一个比 C o m m a n d 更 松 的 发 送 者 - 接 收 者 绑 定 ， 因 为 一 个 目标可能有多个观察者，并且其数目可以在运行时变化，如下图所示。<br><img src="/img/DesignPatterns/26_1.png" alt="github"><br>观察者模式中的Subject和Observer接口是为了处理Subject的变化而设计的，因此当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。<br>中介者模式让对象通过一个Mediator对象间接的互相引用，从而对它们解耦，如下图所示。<br><img src="/img/DesignPatterns/26_2.png" alt="github"><br>一个Mediator对象为各Colleague对象间的请求提供路由并集中它们的通信 。 因此各Colleague对象仅能通过Mediator接口相互交谈。因为这个接口是固定的，为增加灵活性Mediator可能不得不实现它自己的分发策略。可以用一定方式对请求编码并打包参数，使得Colleague对象可以请求的操作数目不限。<br>中介者模式可以减少一个系统中的子类生成，因为它将通信行为集中到一个类中而不是 将其分布在各个子类中。然而，特别的分发策略通常会降低类型安全性。<br>最后，职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦，如下图所示。<br><img src="/img/DesignPatterns/26_3.png" alt="github"><br>因为发送者和接收者之间的接口是固定的，职责链可能也需要一个定制的分发策略。因此它与Mediator一样存在类型安全的问题 。 如果职责链已经是系统结构的一部分，同时在链上的多个对象中总有一个可以处理请求，那么职责链将是一个很好的将发送者和接收者解耦的方法。此外，因为链可以被简单的改变和扩展，从而该模式提供了更大的灵活性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了少数例外情况，各个行为设计模式之间是相互补充和相互加强的关系。例如，一个职责链中的类可能包括至少一个Template Method的应用。该模板方法可使用原语操作 确定该对象是否应处理该请求并选择应转发的对象。职责链可以使用Command模式将请求表示为对象。Interpreter可以使用State模式定义语法分析上下文 。 迭代器可以遍历一个聚合 ， 而访问者可以对它的每一个元素进行一个操作。行为模式也与能其他模式很好地协同工作。例如，一个使用Composite模 式 的 系 统 可以使用一个访问者对该复合的各成分进行一些操作。它可以使用职责链使得各成分可以通过它们的父类访问某些全局属性。它也可以使用Decorater对该复合的某些部分的这些属性进行改写。它可以使用Observer模式将一个对象结构与另一个对象结构联系起来，可以使用State模式使得一个构件在状态改变时可以改变自身的行为。复合本身可以使用构建者中的方法创建，并且它可以被系统中的其他部分当作一个原型模式。 设计良好的面向对象式系统通常有多个模式镶嵌在其中，但其设计者却未必使用这些术语进行思考。然而，在模式级别而不是在类或对象级别上的进行系统组装可以使我们更方便地获取同等的协同性。</p>]]></content>
    
    
    <summary type="html">行为型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式的讨论</title>
    <link href="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/"/>
    <id>http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/</id>
    <published>2023-02-27T07:43:01.000Z</published>
    <updated>2023-03-13T10:03:20.937Z</updated>
    
    <content type="html"><![CDATA[<p>结构型模式依赖于同一个很小的语言机制集合构造代码和对象：单继承和多重继承机制用于基于类的模式，而对象组合机制用于对象式模式。但是这些相似性掩盖了这些模式的不同意图。</p><h2 id="适配器-与-桥接"><a href="#适配器-与-桥接" class="headerlink" title="适配器 与 桥接"></a>适配器 与 桥接</h2><p>具有一些共同的特征。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。</p><p>这些模式的不同之处主要在于它们各自的用途。<br>适配器模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。 这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。<br>另一方面， 桥接模式则对抽象接口与它的(可能是多个)实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。 桥接模式也会在系统演化时适应新的实现。</p><p>由于这些不同点，适配器和桥接模式通常被用于软件生命周期的不同阶段。当你发现两个不兼容的类必须同时工作时，就有必要使用适配器模式，其目的一般是为了避免代码重复。此处耦合不可预见。相反，桥接的使用者必须事先知道:一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的。适配器模式在类已经设计好后实施;而桥接模式在设计类之前实施。这并不意味着适配器模式不如桥接模式，只是因为它们针对了不同的问题。<br>外观模式定义一个新的接口吗，而适配器则复用一个原有的接口。记住，适配器使两个已有的接口协同工作，而不是定义一个全新的接口。</p><h2 id="组装、装饰者-与-代理"><a href="#组装、装饰者-与-代理" class="headerlink" title="组装、装饰者 与 代理"></a>组装、装饰者 与 代理</h2><p>组装模式和装饰者模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。这一共同点可能会使你认为， 装饰者对象是一个退化的组装 ， 但这一观点没有领会装饰者模式要点。相似点仅止于递归组合，同样，这是因为这两个模式的目的不同。<br>装饰者旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。 组装则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰， 而在于表示。<br>尽管它们的目的截然不同，但却具有互补性。因此组装和装饰者模式通常协同使用。在使用这两种模式进行设计时，我们无需定义新的类，仅需将一些对象插接在一起即可构建应用 。 这时系统中将会有一个抽象类 ，它有一些组装子类和装饰者子类 ， 还有一些实现系统的基本构建模块。此时， 组装和装饰者将拥有共同的接口。从装饰者模式的角度看， 组装是一个ConcreteComponent 。而从组装模式的角度看，装饰者则是一个Leaf。当然，他们不一定要同时使用，正如我们所见，它们的目的有很大的差别。<br>另一种与装饰者模式结构相似的模式是代理 。 这两种模式都描述了怎样为对象提供一定程度上的间接引用，代理和装饰者对象的实现部分都保留了指向另一个对象的指针 ， 它们向这个对象发送请求。然而同样，它们具有不同的设计目的。<br>像装饰者模式一样， 代理模式构成一个对象并为用户提供一致的接口。但与装饰者模式不同的是， 代理模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如，实体在远程设备上，访问受到限制或者实体是持久存储的。<br>在代理模式中，实体定义了关键功能，而代理提供(或拒绝)对它的访问。在装饰者模式中，组件仅提供了部分功能，而一个或多个装饰者负责完成其他功能。装饰者模式适用于编译时不能(至少不方便)确定对象的全部功能的情况。这种开放性使递归组合成为装饰者模式中一个必不可少的部分。而在代理模式中则不是这样，因为代理模式强调一种关系(代理与它的实体之间的关系)，这种关系可以静态的表达。<br>模式间的这些差异非常重要，因为它们针对了面向对象设计过程中一些特定的经常发生 问题的解决方法。但这并不意味着这些模式不能结合使用。可以设想有一个代理 - 装饰者 ， 它可以给代理添加功能，或是一个装饰者 - 代理用来修饰一个远程对象 。 尽管这种混合可能有用(我们手边还没有现成的例子)，但它们可以分割成一些有用的模式。</p>]]></content>
    
    
    <summary type="html">结构型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型模式的讨论</title>
    <link href="http://example.com/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/"/>
    <id>http://example.com/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/</id>
    <published>2023-02-25T17:01:24.000Z</published>
    <updated>2023-03-10T07:34:56.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建型模式的讨论"><a href="#创建型模式的讨论" class="headerlink" title="创建型模式的讨论"></a>创建型模式的讨论</h2><p>用一个系统创建的那些对象的类对系统进行参数化有两种常用方法。一种是生成创建对象的类的子类，这对应于使用工厂方法模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。<br>另一种对系统进行参数化的方法更多的依赖于对象复合:定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是抽象工厂、 构建者和原形模式的关键特征。这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”。</p><ul><li>抽象工厂由这个工厂对象产生多个类的对象。 </li><li>构建者由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。</li><li>原型由该工厂对象通过拷贝原型对象来创建产品对象。</li></ul>]]></content>
    
    
    <summary type="html">创建型模式的讨论</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-目录</title>
    <link href="http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/"/>
    <id>http://example.com/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/</id>
    <published>2023-02-18T15:04:05.000Z</published>
    <updated>2023-03-14T09:30:08.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我在看<strong>小鹏哥</strong>写的<strong>设计模式</strong>中一句话让我很有感触：<br><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">讲道理没有ifelse解决不了的逻辑，不⾏就在加⼀⾏!<br></code></pre></td></tr></table></figure><br>这个现象太真实了。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>模式在构造复杂系统时的重要性早已在其他领域中被认可。软件领域中的设计模式为开发人员提供了一种 使用专家设计经验的有效途径。在使用设计模式前，最好需要熟悉“类型”和“多态”，或“接口”继承与“实现”继承的关系。</p><p>设计模式捕获了随时间进化与发展 的问题的求解方法，因此它们并不是人们从一开始就采用的设计方案。它们反映了不为人知的 重新设计和重新编码的成果，而这些都来自软件开发者为了设计出灵活可复用的软件而长时间 进行的艰苦努力。设计模式捕获了这些解决方案，并用简洁易用的方式表达出来。</p><h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><h3 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2. 里氏代换原则"></a>2. 里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3. 依赖倒转原则"></a>3. 依赖倒转原则</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5-迪米特法则，又称最少知道原则"><a href="#5-迪米特法则，又称最少知道原则" class="headerlink" title="5. 迪米特法则，又称最少知道原则"></a>5. 迪米特法则，又称最少知道原则</h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6. 合成复用原则"></a>6. 合成复用原则</h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="23个设计模式"><a href="#23个设计模式" class="headerlink" title="23个设计模式"></a>23个设计模式</h1><p>下面介绍了各个模式的类型及大致范围</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">创建型</th><th style="text-align:center">结构型</th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center">范围</td><td style="text-align:center">类</td><td style="text-align:center">工厂函数</td><td style="text-align:center">适配器(类)</td><td style="text-align:center">模版方法、解释器</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">对象</td><td style="text-align:center">抽象工厂、构建者、原型模式、单例模式</td><td style="text-align:center">适配器(对象)、桥接模式、组成模式、装饰者、外观模式、享元模式、代理模式</td><td style="text-align:center">责任链、命令模式、迭代器、中介者、备忘录、观察者、状态模式、策略模式、访问者</td></tr></tbody></table></div><p>大致分类的方式：</p><ol><li>完成什么工作：创建型模式与对象的创建有关;结构型模式处理类或对象的组合;行为型 模式对类或对象怎样交互和怎样分配职责进行描述。</li><li>用于类还是用于对象：类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了；对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。</li></ol><p>下图中也描述了这些模式之间的关系<br><img src="/img/DesignPatterns/00.png" alt="github"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p><a href="https://yangandmore.github.io/2023/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/">工厂方法</a><br><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/">抽象工厂</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/">构建者</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/">原型模式</a><br><a href="https://yangandmore.github.io/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5/">单例模式</a><br><a href="https://yangandmore.github.io/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/">总结</a></p><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p><a href="https://yangandmore.github.io/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">适配器(对象)</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/">桥接模式</a><br><a href="https://yangandmore.github.io/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/">组成模式</a><br><a href="https://yangandmore.github.io/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/">装饰者</a><br><a href="https://yangandmore.github.io/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/">外观模式</a><br><a href="https://yangandmore.github.io/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">享元模式</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/">代理模式</a><br><a href="https://yangandmore.github.io/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/">总结</a></p><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/">责任链</a><br><a href="https://yangandmore.github.io/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/">命令模式</a><br><a href="https://yangandmore.github.io/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/">迭代器</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/">中介者</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/">备忘录</a><br><a href="https://yangandmore.github.io/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/">观察者</a><br><a href="https://yangandmore.github.io/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/">状态模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/">策略模式</a><br><a href="https://yangandmore.github.io/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/">访问者</a><br><a href="https://yangandmore.github.io/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/">总结</a></p>]]></content>
    
    
    <summary type="html">设计模式-目录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-14T09:54:01.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>提供一个接口来完成计算方式。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来，就创建需要对比的类型，并创建对应的对比起就可以了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Complarator</span>&lt;<span class="hljs-title">Number</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Number n1, Number n2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n1.a &gt; n2.a &amp;&amp; n1.b &gt; b2.b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后并使用这个对比工具即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Number n1 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        Number n2 = <span class="hljs-keyword">new</span> Number(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        <br>        Comparator com = <span class="hljs-keyword">new</span> NumberComparator();<br>        <span class="hljs-keyword">int</span> res = com.compara(n1, n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>如果需要修改算法，我们只需要增加对比器的实现即可。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一<br>个类的方法。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的<br>算法。当这些变体实现为一个算法的类层次时 [ H O 8 7 ] ,可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数<br>据结构。</li><li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。<br>将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/21.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Strategy 和 Context 相互作用以实现选定的算法。当算法被调用时, Context 可以将该算法 所需要的所有数据都传递给该 Strategy 。或者， Context 可以将自身作为一个参数传递给Strategy操作。这就让 Strategy在需要时可以回调 Context 。</li><li>Context 将它的客户的请求转发给它的 Strategy 。客户通常创建并传递一个 ContextStrategy对象给该 Context ;这样 , 客户仅与 Context 交互。通常有一系列的 ContextStrategy 类可供客户从中选择。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Strategy 模式有下面的一些优点和缺点 :</p><ol><li>相关算法系列<br> Strategy类层次为Context定义了一系列的可供重用的算法或行为 。 继承有助于析取出这些算法中的公共功能。</li><li>一个替代继承的方法<br> 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类 ， 从而给它以不同的行为 。 但这会将行为硬行编制到Context中，而将 算法的实现与Context的实现混合起来 , 从而使Context难以理解 、 难以维护和难以扩展 ， 而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、 易于理解、易于扩展。</li><li>消除了一些条件语句<br> Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 , 很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句 。<br> 例如 , 不用Strategy, 正文换行的代码可能是象下面这样 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(type) &#123;<br>    <span class="hljs-keyword">case</span>: <br>    <span class="hljs-keyword">case</span><br>&#125;<br></code></pre></td></tr></table></figure> Strategy模式将换行的任务委托给一个Strategy对象从而消除了这些 case 语句 : <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">compositor.compose();<br></code></pre></td></tr></table></figure> 含有许多条件语句的代码通常意味着需要使用Strategy模式。</li><li>实现的选择<br> Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间/空间权衡取舍要求从不同策略中进行选择。</li><li>客户必须了解不同的Strategy<br> 本模式有一个潜在的缺点 ， 就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同 。 此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。</li><li>Strategy和Context之 间 的 通 信 开 销<br> 无论各个ContextStrategy实现的算法是简单还是复杂 , 它们都共享Strategy定义的接口。因此很可能某些ContextStrategy不会都用到所有通过这个接口传递给它们的信息;简单的ContextStrategy可能不使用其中的任何信息!这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。</li><li>增加了对象的数目<br> Strategy增加了一个应用中的对象的数目。有时你可以将Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的Strategy不应在各次调用之间维护状态。 </li></ol>]]></content>
    
    
    <summary type="html">策略模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模版模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:21:35.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>准备算法<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>        water();<br>        eat();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>final表示无法重写，因此该方法只能使用，无法覆盖，该顺序已经被固定成一个模板。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowerTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tea</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">water</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>控制子类扩展。模板方法只在特定点调用“许在这些点进行扩展。hook”操作， 这样就只允许在这些点进行扩展。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/22.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>ConcreteClass 靠 AbstractClass 来实现算法中不变的步骤。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。 模板方法导致一种反向的控制结构，这种结构有时被称为“好莱坞法则”，即“别找我们，我们找你” [ S w e 8 5 ] 。 这指的是一个父类调用一个子类的操作，而不是相反 。 模板方法调用下列类型的操作:</p><ul><li>具体的操作(ConcreteClass或对客户类的操作)。</li><li>具体的AbstractClass的操作(即，通常对子类有用的操作)。</li><li>原语操作(即，抽象操作)。</li><li>FactoryMethod。</li><li>钩子操作(hook operations)，它提供了缺省的行为，子类可以在必要时进行扩展。一个钩子操作在缺省操作通常是一个空操作。</li></ul><p>很重要的一点是模板方法应该指明哪些操作是钩子操作(可以被重定义)以及哪些是抽象操作(必须被重定义)。要有效地重用一个抽象类，子类编写者必须明确了解哪些操作是设计为有待重定义的。<br>子类可以通过重定义父类的操作来扩展该操作的行为，其间可显式地调用父类操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DerivedClass::Operation() &#123;<br>    ParentClass::Operation();<br>&#125;<br></code></pre></td></tr></table></figure><br>不幸的是，人们很容易忘记去调用被继承的行为。我们可以将这样一个操作转换为一个模板方法，以使得父类可以对子类的扩展方式进行控制。也就是，在父类的模板方法中调用钩子操作。子类可以重定义这个钩子操作:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParentClass::Operation() &#123;<br>    HookOperation();<br>&#125;<br></code></pre></td></tr></table></figure><br>ParentClass本身的HookOperation什么也不做 :<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParentClass::HookOperation() &#123;&#125;<br></code></pre></td></tr></table></figure><br>子类重定义HookOperation以扩展它的行为:<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DerivedClass::HookOperation &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">模版模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <id>http://example.com/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/</id>
    <published>2023-02-17T15:13:59.000Z</published>
    <updated>2023-03-13T14:29:51.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>专家在评审项目时，不同专家针对不同项目进行评审</p><p>首先项目部分<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Project</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>创建两个项目类型<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> FoodProject extends Project&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> safe;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FoodProject</span><span class="hljs-params">(String name, String safe)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.safe = safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> safe;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToolProject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Project</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> quality;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToolProject</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> quality)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.quality = quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quality;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>针对项目，建立了食评项目和工具项目两个类型，针对他们的数据分别为食品安全等级和工具效率等级。</p><p>接下来就是不同的专家分别评审两者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject foodProject)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject toolProject)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后针对不同专家，处理两者的方式也不同<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVisitor</span> <span class="hljs-title">implement</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FoodProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;食评项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,安全等级:&quot;</span>+project.getSafe());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ToolProject project)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;工具项目：&quot;</span>+project.name + <span class="hljs-string">&quot;,质量等级:&quot;</span>+project.getQuality());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样大致完成基本功能</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 访问者使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/23.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>一个使用 Visitor模式的客户必须创建一个ConcreteVisitor对象 ， 然后遍历该对象结构 ，并用该访问者访问每一个元素。</li><li>当一个元素被访问时，它调用对应于它的类的 Visitor操作 。 如果必要 ，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。<br>下面的交互框图说明了一个对象结构、一个访问者和两个元素之间的协作。<br><img src="/img/DesignPatterns/23_1.png" alt="github"></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>下面是访问者模式的一些优缺点:</p><ol><li>访问者模式使得易于增加新的操作<br> 访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反， 如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。</li><li>访问者集中相关的操作而分离无关的操作<br> 相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。</li><li>增加新的ConcreteElement类很困难<br> Visitor模式使得难以增加新的 Element 的子类。每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个ConcretVisitor类中实现相应的操作。有时可以在 Visitor中提供一个缺省的实现，这一实现可 以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。<br> 所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化，是作用于对象结构上的算法呢还是构成该结构的各个对象的类。如果老是有新的ConcretElement 类加入进来的话，Vistor类层次将变得难以维护 。 在这种情况下 ，直接在构成该结构的类中定义这些操作可能更容易一些。如果Element类层次是稳定的 ，而你不断地增加操作获修改算法 ，访问者模式可以帮助你管理这些改动。</li><li>通过类层次进行访问<br> 个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构，同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作。</li><li>累积状态<br> 当访问者访问对象结构中的每一个元素时，它可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局变量。</li><li>破坏封装<br> 访问者方法假定ConcreteElement接口的功能足够强 ， 足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。</li></ol>]]></content>
    
    
    <summary type="html">访问者模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Spire包处理文档</title>
    <link href="http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-02-16T06:49:03.842Z</updated>
    
    
    <summary type="html">使用Spire包处理文档</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"/>
    <id>http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/</id>
    <published>2023-02-15T16:54:16.000Z</published>
    <updated>2023-03-13T13:36:52.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先创建状态机，或者说上下文。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        state.start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        state.close(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>再看看状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来建立对应的两个状态<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.close(<span class="hljs-keyword">new</span> CloseState());<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        context.start(<span class="hljs-keyword">new</span> StartState());<br>        System.out.println(<span class="hljs-string">&quot;Start!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Close!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>准备好后就可以使用了。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        <br>        context.setState(<span class="hljs-keyword">new</span> StartState());<br>        context.close();<br>        context.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/20.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。</li><li>Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context 。</li><li>Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context ，一旦一个Context配置完毕 , 它的客户不再需要直接与状态对象打交道。</li><li>Context 或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>State 模式有下面一些效果 :</p><ol><li>它将与特定状态相关的行为局部化 ， 并且将不同状态的行为分割开来<br> State 模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某 一个 State 子类中 ,所以通过定义新的子类可以很容易的增加新的状态和转换 。<br> 另一个方法是使用数据值定义内部状态并且让 Context 操 作 来 显 式 地 检 查 这 些 数 据 。 但 这 样将会使整个Context的实现中遍布看起来很相似的条件语句或case语句 。 增加一个新的状态可能需要改变若干个操作 , 这就使得维护变得复杂了。<br> State 模式避免了这个问题 , 但可能会引入另一个问题 , 因为该模式将不同状态的行为分布在多个State子类中 。 这就增加了子类的数目，相对于单个类的实现来说不够紧凑 。 但是如果有许多状态时这样的分布实际上更好一些 , 否则需要使用巨大的条件语句。<br> 正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码 。 决定状态转移的逻辑不在单块的 if 或 switch 语句中 , 而是分布在 State 子类之间。 将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。 这将使代码结构化并使其意图更加清晰。</li><li>它使得状态转换显式化<br> 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且,State对象可保证Context不会发生内部状态不一致的情况 ， 因为从Context的角度看 ， 状态转换是原子的—只需重新绑定一个变量 ( 即 Context 的 State对象变量 ) ， 而无需为多个变量赋值</li><li>State对象可被共享<br> 如果State对象没有实例变量 — 即它们表示的状态完全以它们的类型来编码 — 那么各 Context 对象可以共享一个 State 对象。当状态以这种方式被共享时 , 它们必然是没有内部状态 , 只有行为的轻量级对象</li></ol>]]></content>
    
    
    <summary type="html">状态模式</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:12:42.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先是中介者接口定义，接口中的提供了功能定义了赢的人是谁，输的人有谁，以及赢了多少<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及实现该接口的对象，主要对用户进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mediator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">(Colleague winer, <span class="hljs-keyword">int</span> data, Colleague ...losers)</span> </span>&#123;<br>        winer.add(data);<br>        foreach(Colleage c : losers) &#123;<br>            c.subtraction(data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是用户的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后我们针对用户进行实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data += data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data -= data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>主要通过中介者来对同事的数据进行计算<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Mediator mediator = <span class="hljs-keyword">new</span> ConcreteMediator();<br>        <br>        Colleague c1 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">100</span>);<br>        Colleague c2 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">800</span>);<br>        Colleague c3 = <span class="hljs-keyword">new</span> ConcreteColleague(<span class="hljs-number">400</span>);<br>        <br>        mediator.win(c1, <span class="hljs-number">10</span>, c2, c3);<br>        mediator.win(c3, <span class="hljs-number">100</span>, c1);<br>        mediator.win(c2, -<span class="hljs-number">10</span>, c3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/17.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>中介者模式有以下优点和缺点 :</p><ol><li>减少了子类生成<br> Mediator 将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成 Mediator 的子类即可。这样各个 Colleague 类可被重用。</li><li>它将各 Colleague 解耦<br> Mediator 有利于各 Colleague 间的松耦合 . 你可以独立的改变和复用各 Colleague 类和 Mediator 类。</li><li>它简化了对象协议<br> 用 Mediator 和各 Colleague 间的一对多的交互来代替多对多的交互 。一对多的关系更易于理解、维护和扩展。</li><li>它对对象如何协作进行了抽象<br> 将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。</li><li>它使控制集中化<br> 中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议 , 它可能变得比任一个 Colleague 都复杂。 这可能使得中介者自身成为一个难于维护的庞然大物。</li></ol>]]></content>
    
    
    <summary type="html">中介者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:25:26.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>首先定义观察接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后创建多个观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user:&quot;</span>+arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来是被观察者<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; obs;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Observable</span><span class="hljs-params">()</span> </span>&#123;<br>        obs = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">if</span> (!obs.contains(o)) &#123;<br>            obs.addElement(o);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>        obs.removeElement(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        notifyObservers(<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * a temporary array buffer, used as a snapshot of the state of</span><br><span class="hljs-comment">         * current Observers.</span><br><span class="hljs-comment">         */</span><br>        Object[] arrLocal;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!changed)<br>                <span class="hljs-keyword">return</span>;<br>            arrLocal = obs.toArray();<br>            clearChanged();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arrLocal.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>            ((Observer)arrLocal[i]).update(<span class="hljs-keyword">this</span>, arg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        obs.removeAllElements();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        changed = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> changed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> obs.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后继承该类，创建被观察者。这里会发送一条消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setChanged();<br>        notifyObservers(msg);<br>        <span class="hljs-keyword">this</span>.clearChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Observer u1 = <span class="hljs-keyword">new</span> UserObserver();<br>        Observer u2 = <span class="hljs-keyword">new</span> UserObserver();<br>        Subject subject = <span class="hljs-keyword">new</span> Subject();<br>        subject.addObserver(u1);<br>        subject.addObserver(u2);<br>        <br>        subject.setMessage(<span class="hljs-string">&quot;消息1&quot;</span>);<br>        subject.setMessage(<span class="hljs-string">&quot;消息2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象是紧密耦合的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/19.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>当 ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。</li><li>在得到一个具体目标的改变通知后 , ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。</li></ul><p>下面的交互图说明了一个目标对象和两个观察者之间的协作 :<br><img src="/img/DesignPatterns/19_1.png" alt="github"></p><p>注意发出改变请求的 Observer对象并不立即更新 , 而是将其推迟到它从目标得到一个通知之后。 Notify不总是由目标对象调用。它也可被一个观察者或其它对象调用 。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Observer模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者, 反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。<br>下面是观察者模式其它一些优缺点 :</p><ol><li>目标和观察者间的抽象耦合<br> 一个目标所知道的仅仅是它有一系列观察者 , 每个都符合抽象的Observer类的简单接口 。 目标不知道任何一个观察者属于哪一个具体的类 。 这样目标和观察者之间的耦合是抽象的和最小的。<br> 因为目标和观察者不是紧密耦合的 , 它们可以属于一个系统中的不同抽象层次。一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它 , 这样就保持了系统层次的完整。如果目标和观察者混在一块 , 那么得到的对象要么横贯两个层次 (违反了层次性 ), 要么必须放在这两层的某一层中 (这可能会损害层次抽象 )。</li><li>支持广播通信<br> 不像通常的请求, 目标发送的通知不需指定它的接收者。通知被自动广播给所有已向该目标对象登记的有关对象。目标对象并不关心到底有多少对象对自己感兴趣 ; 它唯一的责任就是通知它的各观察者。这给了你在任何时刻增加和删除观察者的自由。处理还是忽略一个通知取决于观察者。</li><li>意外的更新<br> 因为一个观察者并不知道其它观察者的存在 , 它可能对改变目标的最终代价一无所知。在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外 , 如果依赖准则的定义或维护不当，常常会引起错误的更新 , 这种错误通常很难捕捉。<br> 简单的更新协议不提供具体细节说明目标中什么被改变了 , 这就使得上述问题更加严重。 如果没有其他协议帮助观察者发现什么发生了改变，它们可能会被迫尽力减少改变。</li></ol>]]></content>
    
    
    <summary type="html">观察者</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录</title>
    <link href="http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"/>
    <id>http://example.com/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/</id>
    <published>2023-02-14T10:50:00.000Z</published>
    <updated>2023-03-13T13:19:19.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mement <span class="hljs-title">saveCurrentStateToMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(state);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = m.getState();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面建立了原发器的状态字段，以及提供对当前状态的保存以及恢复功能，使用了另一个类来存储当前状态。但是他并不会保存这些状态，只是用这些记录来恢复。</p><p>针对每一次记录都使用下面的对象来单独保存。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后使用一个备忘录管理类来管理这些备忘录<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CareTaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Memento&gt; datas = <span class="hljs-keyword">new</span> ArrayList&lt;Memento&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        datas.add(m)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> datas.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Originator originator = <span class="hljs-keyword">new</span> Originator();<br>        CareTaker careTaker = <span class="hljs-keyword">new</span> CareTaker();<br>        originator.setState(<span class="hljs-string">&quot;状态1&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态2&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        originator.setState(<span class="hljs-string">&quot;状态3&quot;</span>);<br>        careTaker.save(originator.saveCurrentStateToMemento());<br>        <br>        originator.restore(careTaker.get(<span class="hljs-number">0</span>));<br>        originator.restore(careTaker.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>必须保存一个对象在某一个时刻的 (部分)状态, 这样以后需要时它才能恢复到先前的状态。</li><li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/18.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>管理器向原发器请求一个备忘录 , 保留一段时间后 ,将其送回给原发器 , 如下面的交互图所示。有时管理者不会将备忘录返回给原发器 , 因为原发器可能根本不需要退到先前的状态。</li><li>备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。<br><img src="/img/DesignPatterns/18_1.png" alt="github"></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>备忘录模式有以下一些效果 :</p><ol><li>保持封装边界<br> 使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发 器之外的信息。该模式把可能很复杂的 Originator 内部信息对其他对象屏蔽起来 , 从而保持了封装边界。</li><li>它简化了原发器<br> 在其他的保持封装性的设计中 , Originator负责保持客户请求过的内部 状态版本。这就把所有存储管理的重任交给了 Originator 。 让客户管理它们请求的状态将会简化 Originator, 并且使得客户工作结束时无需通知原发器 。</li><li>使用备忘录可能代价很高<br> 如果原发器在生成备忘录时必须拷贝并存储大量的信息 , 或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。除非封装和恢复 Originator 状态的开销不大 ,否则该模式可能并不合适。</li><li>定义窄接口和宽接口<br> 在一些语言中可能难以保证只有原发器可访问备忘录的状态。</li><li>维护备忘录的潜在代价<br> 管理器负责删除它所维护的备忘录。然而 , 管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。</li></ol>]]></content>
    
    
    <summary type="html">备忘录</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-解释器</title>
    <link href="http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"/>
    <id>http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/</id>
    <published>2023-02-12T20:34:01.000Z</published>
    <updated>2023-03-13T13:05:56.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>给定一个语言，定义他的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>那么根据结构建立一个简单的解释器<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>参数解析<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String key;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VarExpression</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.get(<span class="hljs-keyword">this</span>.key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>以及符号解析，具备了符号左右的参数添加<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Expression</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Expression leftVar, rightVar;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SymbolExpression</span><span class="hljs-params">(Expression leftVar, Expression rightVar)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.leftVar = leftVar;<br>        <span class="hljs-keyword">this</span>.rightVar = rightVar;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>首先准备一个加法符号<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SymbolExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddExpression</span><span class="hljs-params">(Expression leftVar, Expression rightVar)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(leftVar, rightVar);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(HashMap&lt;String, Integer&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.leftVar.interpreter(data) + <span class="hljs-keyword">super</span>.rightVar.interpreter(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来只需要使用配置的对象解决问题即可<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p><ol><li>该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。他们无需构建抽象语法树即可解释表达式，这也可以节省空间而且还可能节省时间。</li><li>效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将她们转换成另一个形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/15.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Client 构建 ( 或被给定 )一个句子 , 它是 NonterminalExpression和TerminalExpression的实例的一个抽象语法树. 然后初始化上下文并调用解释操作。</li><li>每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。</li><li>每一节点的解释操作用上下文来存储和访问解释器的状态。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>解释器模式有下列的优点和不足 :</p><ol><li>易于改变和扩展文法<br> 因为该模式使用类来表示文法规则 , 你可使用继承来改变或扩展该文法。已有的表达式可被增量式地改变 ,而新的表达式可定义为旧表达式的变体。</li><li>也易于实现文法<br> 定义抽象语法树中各个节点的类的实现大体类似。这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。</li><li>复杂的文法难以维护<br> 解释器模式为文法中的每一条规则至少定义了一个类 ( 使用BNF定义的文法规则需要更多的类 )。因此包含许多规则的文法可能难以管理和维护。可应用其他的设计模式来缓解这一问题。但当文法非常复杂时, 其他的技术如语法分析程序或编译器生成器更为合适。</li><li>增加了新的解释表达式的方式<br> 解释器模式使得实现新表达式“计算”变得容易。 例如, 你可以在表达式类上定义一个新的操作以支持优美打印或表达式的类型检查。如果你经常创建新的解释表达式的方式 , 那么可以考虑使用访问者模式以避免修改这些代表文法的类。</li></ol>]]></content>
    
    
    <summary type="html">解释器</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器</title>
    <link href="http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"/>
    <id>http://example.com/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/</id>
    <published>2023-02-12T20:34:01.000Z</published>
    <updated>2023-03-13T13:08:35.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>熟悉java就应该知道，Iterator模式这个在java中用的非常广泛。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>接下来使用ArrayList<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span> </span>&#123;<br>    Object[] arr = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == arr.lenth) &#123;<br>            Object[] newArr = <span class="hljs-keyword">new</span> Object[arr.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(arr, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, arr.length);<br>            arr = newArr;<br>        &#125;<br>        arr[index] = item;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面是一个普通ArrayList下的构建，还不具备迭代器，只能使用索引下标来进行迭代。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里建立迭代器的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>最后让ArrayList实现<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E[] arr = (E[])<span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == arr.lenth) &#123;<br>            E[] newArr = (E[])<span class="hljs-keyword">new</span> Object[arr.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(arr, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, arr.length);<br>            arr = newArr;<br>        &#125;<br>        arr[index] = item;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayListIterator();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentIndex = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (currentIndex &gt;= index) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            E item = (E)arr[currentIndex];<br>            currentIndex++;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时使用新ArrayList中的Iterator，构建一个迭代器。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Iterator iterator = list.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>            String data = iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口 (即, 支持多态迭代)。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/16.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>迭代器模式有三个重要的作用:</p><ol><li>它支持以不同的方式遍历一个聚合<br> 复杂的聚合可用多种方式进行遍历。例如 , 代码生成和语义检查要遍历语法分析树。代码生成可以按中序或者按前序来遍历语法分析树。迭代器模式使得改变遍历算法变得很容易 : 仅需用一个不同的迭代器的实例代替原先的实例即可。 你也可以自己定义迭代器的子类以支持新的遍历。</li><li>迭代器简化了聚合的接口<br> 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。</li><li>在同一个聚合上可以有多个遍历<br> 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。</li></ol>]]></content>
    
    
    <summary type="html">迭代器</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-命令</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/</id>
    <published>2023-02-11T13:12:56.000Z</published>
    <updated>2023-03-13T13:01:19.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤消的操作。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Receiver receiver = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenCommand</span><span class="hljs-params">(Receiver receiver)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        receiver.action();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是接收者如何处理消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收者处理消息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面大致是命令收到后会让接收者收到一条消息。</p><p>接下来就是发送消息<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Command command = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span> </span>&#123;<br>        command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>大致准备好后，就可以使用了<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        Command command = OpenCommand(<span class="hljs-keyword">new</span> Receiver());<br>        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();<br>        invoker.setCommand(command);<br>        invoker.invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>将可用过程语言中的回调函数表达这种参数化机制。回调函数是指函数先在某处注册，而他将在稍后某个需要的时候被调用。命令模式是回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求。一个命令对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那实现该请求。</li><li>支持取消操作。</li><li>支持修改日志。</li><li>用构建在原语操作上的高层操作构造一个系统，这样一种结构在支持事务的信息系统上很常见。一个事务封装了对数据的一组变动。命令模式提供了对事物进行组建的方法。命令模式有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事物以扩展系统。</li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/14.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li>Client创建一个 ConcreteCommand 对象并指定它的 Receiver 对象。</li><li>某 Invoker对象存储该 ConcreteCommand 对象。</li><li>该 Invoker 通过调用 Command对象的 Execute 操作来提交一个请求。若该命令是可撤消的， ConcreteCommand 就在执行 Excute操作之前存储当前状态以用于取消该命令。</li><li>ConcreteCommand 对象对调用它的 Receiver 的一些操作以执行该请求 。</li></ul><p><img src="/img/DesignPatterns/14_1.png" alt="github"></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>命令模式有以下效果 :</p><ol><li>命令模式将调用操作的对象与知道如何实现该操作的对象解耦。</li><li>命令是头等的对象。它们可像其他的对象一样被操纵和扩展。</li><li>你可将多个命令装配成一个复合命令 。 例如是前面描述的MacroCommand类 。 一般说来，复合命令是组合模式的一个实例。</li><li>增加新的命令很容易，因为这无需改变已有的类。</li></ol>]]></content>
    
    
    <summary type="html">命令</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理</title>
    <link href="http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"/>
    <id>http://example.com/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/</id>
    <published>2023-02-11T07:43:01.000Z</published>
    <updated>2023-02-28T14:23:43.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ol><li>远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代理。</li><li>虚拟代理（Virtual Proxy）根据需要创建开销很大的对象。</li><li>保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li><li>智能指引（Smart Reference）取代了简单的指针，他在访问对象时执行一些附加操作。典型用途包括：<ul><li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放他。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查是否已经锁定了他，以确保其他对象不能改变它。</li></ul></li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/img/DesignPatterns/12.png" alt="github"></p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>代理根据其种类，在适当的时候向 RealSubject 转发请求。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>Proxy模式在访问对象时引入了一定程度的间接性。根据代理的类型，附加的间接性有多种用途:</p><ol><li>RemoteProxy 可以隐藏一个对象存在于不同地址空间的事实。</li><li>Virtual Proxy 可以进行最优化，例如根据要求创建对象。</li><li>Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理</li></ol><p>Proxy 模式还可以对用户隐藏另一种称之为 copy-on-write的优化方式，该优化与根据需要创建对象有关。拷贝一个庞大而复杂的对象是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候才对它进行拷贝。<br>在实现 Copy-on-write 时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正的拷贝它。在这种情况下，代理还必须减少实体的引用计数。当引用的数目为零时，这个实体将被删除。<br>Copy-on-Write可以大幅度的降低拷贝庞大实体时的开销。</p>]]></content>
    
    
    <summary type="html">代理</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
