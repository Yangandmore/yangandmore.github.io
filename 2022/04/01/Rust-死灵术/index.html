<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Rust-死灵书（一） | 杨小杨的博客</title>
  <meta name="keywords" content=" rust ">
  <meta name="description" content="Rust-死灵书（一） | 杨小杨的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="带锁的Map">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql学习">
<meta property="og:url" content="http://example.com/2023/08/18/Mysql%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="杨小杨的博客">
<meta property="og:description" content="带锁的Map">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-08-18T20:31:00.000Z">
<meta property="article:modified_time" content="2023-08-30T13:33:39.849Z">
<meta property="article:author" content="Yang">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/header.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="杨小杨的博客" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/header.png"/>
</a>
<div class="author">
    <span>Yang</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/Yangandmore"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:635408602@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=635408602&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(202)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="数据库">
                        
                        数据库
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="包管理">
                        
                        包管理
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="编译的库">
                        
                        编译的库
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分布式事务">
                        
                        分布式事务
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分布式搜索">
                        
                        分布式搜索
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后台">
                        
                        后台
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="机器学习">
                        
                        机器学习
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="快捷键">
                        
                        快捷键
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="流程引擎">
                        
                        流程引擎
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="设计模式">
                        
                        设计模式
                        <small>(27)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构">
                        <i class="fold iconfont icon-right"></i>
                        
                        数据结构
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="数据结构<--->算法分析">
                                        
                                        算法分析
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="相机">
                        
                        相机
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="异常问题">
                        
                        异常问题
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="音视频">
                        
                        音视频
                        <small>(13)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="整洁代码">
                        
                        整洁代码
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="正则表达式">
                        
                        正则表达式
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Android">
                        <i class="fold iconfont icon-right"></i>
                        
                        Android
                        <small>(17)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Android<--->热更新">
                                        
                                        热更新
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="C/C++">
                        
                        C/C++
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="git">
                        
                        git
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Gradle">
                        
                        Gradle
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="java">
                        
                        java
                        <small>(27)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="JavaScript">
                        <i class="fold iconfont icon-right"></i>
                        
                        JavaScript
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="JavaScript<--->npm">
                                        
                                        npm
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="jvm">
                        
                        jvm
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="nginx">
                        
                        nginx
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="ReactNative">
                        
                        ReactNative
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Redis">
                        
                        Redis
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="rust">
                        <i class="fold iconfont icon-right"></i>
                        
                        rust
                        <small>(46)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="rust<--->p2p">
                                        
                                        p2p
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="spring">
                        <i class="fold iconfont icon-right"></i>
                        
                        spring
                        <small>(9)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="spring<--->java">
                                        
                                        java
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="ssr">
                        
                        ssr
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="202">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>包管理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>贝塞尔曲线</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式事务</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式搜索</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>构建工具</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>后台</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>汇编</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>机器学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>跨域</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>快捷键</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>流程引擎</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>热更新</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>视频格式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据结构与算法分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图片格式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>相机</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>异步</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>异常问题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>音频</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>音视频</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>整洁代码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>正则表达式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>直播</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>camera</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Cpp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>es</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ffmpeg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Gradle</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>javaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libfaac</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libjpeg-turbo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libx264</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>libyuv</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NDK</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nginx</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>react</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>React</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ReactNative</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RTMP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>rust</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>seate</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springboot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>srs</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ssr</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All 数据库 "
           href="/2023/08/18/Mysql%E5%AD%A6%E4%B9%A0/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="Mysql学习">Mysql学习</span>
            <span class="post-date" title="2023-08-18 20:31:00">2023/08/18</span>
        </a>
        
        <a  class="All 算法 "
           href="/2023/08/18/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AD%A6%E4%B9%A0/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法复杂度学习">算法复杂度学习</span>
            <span class="post-date" title="2023-08-18 20:31:00">2023/08/18</span>
        </a>
        
        <a  class="All java "
           href="/2023/08/18/SafeMap/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="带锁的Map">带锁的Map</span>
            <span class="post-date" title="2023-08-18 20:31:00">2023/08/18</span>
        </a>
        
        <a  class="All java "
           href="/2023/08/15/Reference/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="强引用 弱引用 软引用 虚引用">强引用 弱引用 软引用 虚引用</span>
            <span class="post-date" title="2023-08-15 15:11:32">2023/08/15</span>
        </a>
        
        <a  class="All java "
           href="/2023/08/05/UnSafe/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java中Unsafe">Java中Unsafe</span>
            <span class="post-date" title="2023-08-05 08:31:32">2023/08/05</span>
        </a>
        
        <a  class="All 算法 "
           href="/2023/07/31/%E7%BA%A2%E9%BB%91%E6%A0%91/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="红黑树">红黑树</span>
            <span class="post-date" title="2023-07-31 20:11:01">2023/07/31</span>
        </a>
        
        <a  class="All java "
           href="/2023/07/25/HashMap/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="HashMap">HashMap</span>
            <span class="post-date" title="2023-07-25 22:31:46">2023/07/25</span>
        </a>
        
        <a  class="All java "
           href="/2023/07/25/Java_JNI/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java中使用JNI构建环境">Java中使用JNI构建环境</span>
            <span class="post-date" title="2023-07-25 19:22:35">2023/07/25</span>
        </a>
        
        <a  class="All java "
           href="/2023/07/25/JNI_1/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JNI 一">JNI 一</span>
            <span class="post-date" title="2023-07-25 12:00:01">2023/07/25</span>
        </a>
        
        <a  class="All java "
           href="/2023/07/19/%E6%B3%9B%E5%9E%8B/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java 泛型 关于 ? extends super">Java 泛型 关于 ? extends super</span>
            <span class="post-date" title="2023-07-19 20:14:22">2023/07/19</span>
        </a>
        
        <a  class="All java "
           href="/2023/07/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="线程池">线程池</span>
            <span class="post-date" title="2023-07-11 19:22:35">2023/07/11</span>
        </a>
        
        <a  class="All java "
           href="/2023/07/01/gc/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="GC学习">GC学习</span>
            <span class="post-date" title="2023-07-01 23:02:35">2023/07/01</span>
        </a>
        
        <a  class="All java "
           href="/2023/06/19/jvm/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="jvm学习">jvm学习</span>
            <span class="post-date" title="2023-06-19 09:22:35">2023/06/19</span>
        </a>
        
        <a  class="All java "
           href="/2023/06/09/lambada/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="lambda表达式">lambda表达式</span>
            <span class="post-date" title="2023-06-09 09:22:35">2023/06/09</span>
        </a>
        
        <a  class="All java "
           href="/2023/06/09/javaStream/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java Stream管道数据处理操作">Java Stream管道数据处理操作</span>
            <span class="post-date" title="2023-06-09 09:22:35">2023/06/09</span>
        </a>
        
        <a  class="All java "
           href="/2023/06/01/%E5%85%A8%E5%B1%80id/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="全局ID">全局ID</span>
            <span class="post-date" title="2023-06-01 09:02:25">2023/06/01</span>
        </a>
        
        <a  class="All java "
           href="/2023/05/23/JVM%E5%B7%A5%E5%85%B7/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JVM-工具">JVM-工具</span>
            <span class="post-date" title="2023-05-23 08:02:25">2023/05/23</span>
        </a>
        
        <a  class="All 相机 "
           href="/2023/04/24/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A02/"
           data-tag="相机"
           data-author="" >
            <span class="post-title" title="相机学习2-我的富士学习">相机学习2-我的富士学习</span>
            <span class="post-date" title="2023-04-24 18:02:25">2023/04/24</span>
        </a>
        
        <a  class="All 相机 "
           href="/2023/04/09/%E7%9B%B8%E6%9C%BA%E5%AD%A6%E4%B9%A01/"
           data-tag="相机"
           data-author="" >
            <span class="post-title" title="相机学习1-基础部分">相机学习1-基础部分</span>
            <span class="post-date" title="2023-04-09 08:59:25">2023/04/09</span>
        </a>
        
        <a  class="All nginx "
           href="/2023/03/15/NginxProxyManager%E5%A2%9E%E5%8A%A0ssl/"
           data-tag="nginx"
           data-author="" >
            <span class="post-title" title="NginxProxyManager增加ssl">NginxProxyManager增加ssl</span>
            <span class="post-date" title="2023-03-15 23:24:22">2023/03/15</span>
        </a>
        
        <a  class="All jvm "
           href="/2023/03/15/JVM_SafePoint/"
           data-tag="jvm"
           data-author="" >
            <span class="post-title" title="JVM—SafePoint">JVM—SafePoint</span>
            <span class="post-date" title="2023-03-15 23:24:22">2023/03/15</span>
        </a>
        
        <a  class="All java "
           href="/2023/03/15/java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java字节码指令大全">Java字节码指令大全</span>
            <span class="post-date" title="2023-03-15 23:24:22">2023/03/15</span>
        </a>
        
        <a  class="All java "
           href="/2023/03/15/java%E9%94%81/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java锁">Java锁</span>
            <span class="post-date" title="2023-03-15 23:24:22">2023/03/15</span>
        </a>
        
        <a  class="All java "
           href="/2023/03/15/java%E4%B8%AD%E7%9A%84CAS/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java中的CAS操作">java中的CAS操作</span>
            <span class="post-date" title="2023-03-15 22:01:12">2023/03/15</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F26/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-行为型模式的讨论">设计模式-行为型模式的讨论</span>
            <span class="post-date" title="2023-03-13 22:14:00">2023/03/13</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F24/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-结构型模式的讨论">设计模式-结构型模式的讨论</span>
            <span class="post-date" title="2023-02-27 07:43:01">2023/02/27</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F25/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-创建型模式的讨论">设计模式-创建型模式的讨论</span>
            <span class="post-date" title="2023-02-25 17:01:24">2023/02/25</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-目录">设计模式-目录</span>
            <span class="post-date" title="2023-02-18 15:04:05">2023/02/18</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-模版模式">设计模式-模版模式</span>
            <span class="post-date" title="2023-02-17 15:13:59">2023/02/17</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-策略模式">设计模式-策略模式</span>
            <span class="post-date" title="2023-02-17 15:13:59">2023/02/17</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-访问者模式">设计模式-访问者模式</span>
            <span class="post-date" title="2023-02-17 15:13:59">2023/02/17</span>
        </a>
        
        <a  class="All java "
           href="/2023/02/15/spire%E5%8C%85%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="使用Spire包处理文档">使用Spire包处理文档</span>
            <span class="post-date" title="2023-02-15 16:54:16">2023/02/15</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-状态模式">设计模式-状态模式</span>
            <span class="post-date" title="2023-02-15 16:54:16">2023/02/15</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-中介者">设计模式-中介者</span>
            <span class="post-date" title="2023-02-14 10:50:00">2023/02/14</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-观察者">设计模式-观察者</span>
            <span class="post-date" title="2023-02-14 10:50:00">2023/02/14</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-备忘录">设计模式-备忘录</span>
            <span class="post-date" title="2023-02-14 10:50:00">2023/02/14</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-迭代器">设计模式-迭代器</span>
            <span class="post-date" title="2023-02-12 20:34:01">2023/02/12</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-解释器">设计模式-解释器</span>
            <span class="post-date" title="2023-02-12 20:34:01">2023/02/12</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-命令">设计模式-命令</span>
            <span class="post-date" title="2023-02-11 13:12:56">2023/02/11</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-代理">设计模式-代理</span>
            <span class="post-date" title="2023-02-11 07:43:01">2023/02/11</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-职责链">设计模式-职责链</span>
            <span class="post-date" title="2023-02-11 07:43:01">2023/02/11</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-享元">设计模式-享元</span>
            <span class="post-date" title="2023-02-10 23:12:38">2023/02/10</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-外观">设计模式-外观</span>
            <span class="post-date" title="2023-02-08 19:59:30">2023/02/08</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F9/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-装饰">设计模式-装饰</span>
            <span class="post-date" title="2023-02-07 18:47:30">2023/02/07</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F7/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式- 桥接">设计模式- 桥接</span>
            <span class="post-date" title="2023-02-06 19:46:00">2023/02/06</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F8/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式- 组合">设计模式- 组合</span>
            <span class="post-date" title="2023-02-06 19:46:00">2023/02/06</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-原型">设计模式-原型</span>
            <span class="post-date" title="2023-02-02 18:00:35">2023/02/02</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-单例">设计模式-单例</span>
            <span class="post-date" title="2023-02-02 18:00:35">2023/02/02</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-构建者模式">设计模式-构建者模式</span>
            <span class="post-date" title="2023-02-02 15:10:25">2023/02/02</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-抽象工厂">设计模式-抽象工厂</span>
            <span class="post-date" title="2023-01-31 15:55:25">2023/01/31</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-适配器">设计模式-适配器</span>
            <span class="post-date" title="2023-01-28 23:30:00">2023/01/28</span>
        </a>
        
        <a  class="All 快捷键 "
           href="/2023/01/28/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag="快捷键"
           data-author="" >
            <span class="post-title" title="idea快捷键(mac)-持续更新">idea快捷键(mac)-持续更新</span>
            <span class="post-date" title="2023-01-28 08:02:25">2023/01/28</span>
        </a>
        
        <a  class="All 设计模式 "
           href="/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式-工厂方法">设计模式-工厂方法</span>
            <span class="post-date" title="2023-01-28 08:02:25">2023/01/28</span>
        </a>
        
        <a  class="All 整洁代码 "
           href="/2023/01/28/%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%811/"
           data-tag="整洁代码"
           data-author="" >
            <span class="post-title" title="观看Clean Code(整洁代码)记录-1">观看Clean Code(整洁代码)记录-1</span>
            <span class="post-date" title="2023-01-28 08:02:25">2023/01/28</span>
        </a>
        
        <a  class="All 异常问题 "
           href="/2022/09/27/eclipse-mac-err/"
           data-tag="异常问题"
           data-author="" >
            <span class="post-title" title="eclipse-mac-err">eclipse-mac-err</span>
            <span class="post-date" title="2022-09-27 22:24:54">2022/09/27</span>
        </a>
        
        <a  class="All 流程引擎 "
           href="/2022/09/16/activiti7/"
           data-tag="流程引擎"
           data-author="" >
            <span class="post-title" title="流程引擎-activiti7">流程引擎-activiti7</span>
            <span class="post-date" title="2022-09-16 10:01:11">2022/09/16</span>
        </a>
        
        <a  class="All 分布式事务 "
           href="/2022/09/04/seate/"
           data-tag="seate,分布式事务"
           data-author="" >
            <span class="post-title" title="配置seate">配置seate</span>
            <span class="post-date" title="2022-09-04 19:11:24">2022/09/04</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/09/01/es-java/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="es在java环境中使用">es在java环境中使用</span>
            <span class="post-date" title="2022-09-01 22:11:48">2022/09/01</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/09/01/es-ik/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="es配置ik分词器及热更新">es配置ik分词器及热更新</span>
            <span class="post-date" title="2022-09-01 16:38:27">2022/09/01</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/08/06/es-7-change-password/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="es修改密码">es修改密码</span>
            <span class="post-date" title="2022-08-06 23:37:16">2022/08/06</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/08/06/es-linux/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="elk在linux上简单安装">elk在linux上简单安装</span>
            <span class="post-date" title="2022-08-06 21:02:25">2022/08/06</span>
        </a>
        
        <a  class="All 分布式搜索 "
           href="/2022/08/02/ELK/"
           data-tag="es,分布式搜索"
           data-author="" >
            <span class="post-title" title="ELK学习">ELK学习</span>
            <span class="post-date" title="2022-08-02 15:13:44">2022/08/02</span>
        </a>
        
        <a  class="All 包管理 "
           href="/2022/07/29/chocolatey/"
           data-tag="包管理"
           data-author="" >
            <span class="post-title" title="chocolatey">chocolatey</span>
            <span class="post-date" title="2022-07-29 16:56:39">2022/07/29</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/28/Spring-%E5%9F%BA%E7%A1%805/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础5">Spring-基础5</span>
            <span class="post-date" title="2022-07-28 21:11:57">2022/07/28</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/28/Spring-%E5%9F%BA%E7%A1%804/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(四)">Spring-基础(四)</span>
            <span class="post-date" title="2022-07-28 15:50:59">2022/07/28</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/25/Spring-%E5%9F%BA%E7%A1%803/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(三)">Spring-基础(三)</span>
            <span class="post-date" title="2022-07-25 21:51:47">2022/07/25</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/25/Spring-%E5%9F%BA%E7%A1%802/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(二)">Spring-基础(二)</span>
            <span class="post-date" title="2022-07-25 10:26:06">2022/07/25</span>
        </a>
        
        <a  class="All spring "
           href="/2022/07/25/Spring-%E5%9F%BA%E7%A1%801/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring-基础(一)">Spring-基础(一)</span>
            <span class="post-date" title="2022-07-25 09:58:25">2022/07/25</span>
        </a>
        
        <a  class="All rust "
           href="/2022/07/17/P2P/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="P2P">P2P</span>
            <span class="post-date" title="2022-07-17 10:46:24">2022/07/17</span>
        </a>
        
        <a  class="All rust p2p "
           href="/2022/07/16/Rust-libp2p/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-libp2p">Rust-libp2p</span>
            <span class="post-date" title="2022-07-16 14:04:11">2022/07/16</span>
        </a>
        
        <a  class="All "
           href="/2022/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AE%B0%E8%B4%A6%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区块链-记账模式">区块链-记账模式</span>
            <span class="post-date" title="2022-07-06 21:48:04">2022/07/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/06/26/Summer-boot%E4%B8%80%E6%9C%9F%E5%AE%8F%E9%83%A8%E5%88%86%E6%9E%84%E6%80%9D%E5%8F%8A%E5%AE%9E%E7%8E%B0/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Summer-boot一期宏部分构思及实现">Summer-boot一期宏部分构思及实现</span>
            <span class="post-date" title="2022-06-26 10:12:27">2022/06/26</span>
        </a>
        
        <a  class="All git "
           href="/2022/06/16/Git-fork%E9%A1%B9%E7%9B%AE%E6%9B%B4%E6%96%B0/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git-fork项目更新">Git-fork项目更新</span>
            <span class="post-date" title="2022-06-16 15:11:56">2022/06/16</span>
        </a>
        
        <a  class="All rust "
           href="/2022/06/12/Rust-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-编码规范">Rust-编码规范</span>
            <span class="post-date" title="2022-06-12 09:05:33">2022/06/12</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2022/05/29/MySql-Some%E7%AD%89%E6%8C%87%E4%BB%A4/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="MySql_Some、Any、All的用法">MySql_Some、Any、All的用法</span>
            <span class="post-date" title="2022-05-29 10:07:14">2022/05/29</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/12/Redis-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-聚合操作">Redis-聚合操作</span>
            <span class="post-date" title="2022-05-12 14:34:47">2022/05/12</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/11/Redis-%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-切片集群配置">Redis-切片集群配置</span>
            <span class="post-date" title="2022-05-11 15:45:38">2022/05/11</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/10/Redis-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E9%85%8D%E7%BD%AE/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-哨兵机制配置">Redis-哨兵机制配置</span>
            <span class="post-date" title="2022-05-10 17:02:25">2022/05/10</span>
        </a>
        
        <a  class="All Redis "
           href="/2022/05/10/Redis-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%85%B3/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-开启远程访问">Redis-开启远程访问</span>
            <span class="post-date" title="2022-05-10 14:24:32">2022/05/10</span>
        </a>
        
        <a  class="All rust "
           href="/2022/05/06/Rust-%E5%B1%9E%E6%80%A7/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-属性">Rust-属性</span>
            <span class="post-date" title="2022-05-06 10:08:24">2022/05/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/20/Rust-build/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust编译过程图">Rust编译过程图</span>
            <span class="post-date" title="2022-04-20 14:54:46">2022/04/20</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/08/Rust-Atomic/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-Atomic">Rust-Atomic</span>
            <span class="post-date" title="2022-04-08 09:55:50">2022/04/08</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/06/Rust-%E6%AD%BB%E7%81%B5%E6%9C%AF3/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-死灵术3">Rust-死灵术3</span>
            <span class="post-date" title="2022-04-06 20:48:19">2022/04/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/06/Rust-%E6%AD%BB%E7%81%B5%E6%9C%AF2/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-死灵术2">Rust-死灵术2</span>
            <span class="post-date" title="2022-04-06 14:54:22">2022/04/06</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/02/Rust-AnyTrait/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-AnyTrait">Rust-AnyTrait</span>
            <span class="post-date" title="2022-04-02 14:25:05">2022/04/02</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/02/Rust-Cow%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-Cow智能指针">Rust-Cow智能指针</span>
            <span class="post-date" title="2022-04-02 10:16:00">2022/04/02</span>
        </a>
        
        <a  class="All rust "
           href="/2022/04/01/Rust-%E6%AD%BB%E7%81%B5%E6%9C%AF/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-死灵书（一）">Rust-死灵书（一）</span>
            <span class="post-date" title="2022-04-01 16:42:36">2022/04/01</span>
        </a>
        
        <a  class="All rust "
           href="/2022/03/09/Rust-%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-参考手册">Rust-参考手册</span>
            <span class="post-date" title="2022-03-09 10:15:21">2022/03/09</span>
        </a>
        
        <a  class="All rust "
           href="/2022/03/08/Rust-%E5%AE%8F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-小宏书(声明宏)">Rust-高级-小宏书(声明宏)</span>
            <span class="post-date" title="2022-03-08 20:22:51">2022/03/08</span>
        </a>
        
        <a  class="All Android "
           href="/2022/03/03/Android%E9%9B%86%E6%88%90Rust/"
           data-tag="Android,rust"
           data-author="" >
            <span class="post-title" title="Android集成Rust">Android集成Rust</span>
            <span class="post-date" title="2022-03-03 10:56:49">2022/03/03</span>
        </a>
        
        <a  class="All rust "
           href="/2022/02/08/Rust-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-类型转换-From &amp; Into">Rust-类型转换-From &amp; Into</span>
            <span class="post-date" title="2022-02-08 16:53:33">2022/02/08</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/16/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bbitflags/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之bitflags">Rust-高级-Crate之bitflags</span>
            <span class="post-date" title="2022-01-16 22:36:28">2022/01/16</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Brayon/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之rayon">Rust-高级-Crate之rayon</span>
            <span class="post-date" title="2022-01-12 21:55:30">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Blazy-static/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之lazy_static">Rust-高级-Crate之lazy_static</span>
            <span class="post-date" title="2022-01-12 21:50:32">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8BWalkdir/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之Walkdir">Rust-高级-Crate之Walkdir</span>
            <span class="post-date" title="2022-01-12 21:50:15">2022/01/12</span>
        </a>
        
        <a  class="All "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bthreadpool/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之threadpool">Rust-高级-Crate之threadpool</span>
            <span class="post-date" title="2022-01-12 21:49:50">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Berror-chain/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之error_chain">Rust-高级-Crate之error_chain</span>
            <span class="post-date" title="2022-01-12 21:49:39">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bcrossbeam/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之crossbeam">Rust-高级-Crate之crossbeam</span>
            <span class="post-date" title="2022-01-12 21:16:24">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/12/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Btar/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之tar">Rust-高级-Crate之tar</span>
            <span class="post-date" title="2022-01-12 10:29:50">2022/01/12</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/11/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Brand/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之rand">Rust-高级-Crate之rand</span>
            <span class="post-date" title="2022-01-11 14:52:45">2022/01/11</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/09/Rust-%E9%AB%98%E7%BA%A7-Crate%E4%B9%8Bserde/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级-Crate之serde">Rust-高级-Crate之serde</span>
            <span class="post-date" title="2022-01-09 21:10:52">2022/01/09</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/09/Rust%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust中的引用与借用">Rust中的引用与借用</span>
            <span class="post-date" title="2022-01-09 19:03:47">2022/01/09</span>
        </a>
        
        <a  class="All "
           href="/2022/01/09/graphQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="graphQL">graphQL</span>
            <span class="post-date" title="2022-01-09 17:02:35">2022/01/09</span>
        </a>
        
        <a  class="All "
           href="/2022/01/05/Rust-%E9%AB%98%E7%BA%A7-%E6%9C%8D%E5%8A%A1%E4%B9%8BActix/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust-高级-服务之Actix">Rust-高级-服务之Actix</span>
            <span class="post-date" title="2022-01-05 21:13:56">2022/01/05</span>
        </a>
        
        <a  class="All rust "
           href="/2022/01/05/Rust-%E9%AB%98%E7%BA%A7-%E5%BC%82%E6%AD%A5%E4%B9%8Bfutures/"
           data-tag="rust,异步"
           data-author="" >
            <span class="post-title" title="Rust-高级-异步之futures">Rust-高级-异步之futures</span>
            <span class="post-date" title="2022-01-05 21:13:38">2022/01/05</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/30/Rust-%E6%9C%80%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-最后的项目">Rust-最后的项目</span>
            <span class="post-date" title="2021-12-30 14:46:33">2021/12/30</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/21/Rust-%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-高级特征">Rust-高级特征</span>
            <span class="post-date" title="2021-12-21 22:22:15">2021/12/21</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/20/Rust-%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%9D%A5%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E7%BB%93%E6%9E%84/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-模式与模式匹配">Rust-模式与模式匹配</span>
            <span class="post-date" title="2021-12-20 20:53:44">2021/12/20</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/20/Rust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-面向对象">Rust-面向对象</span>
            <span class="post-date" title="2021-12-20 15:15:04">2021/12/20</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/20/Rust-%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-无畏并发">Rust-无畏并发</span>
            <span class="post-date" title="2021-12-20 09:44:35">2021/12/20</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/19/Rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-智能指针">Rust-智能指针</span>
            <span class="post-date" title="2021-12-19 10:23:23">2021/12/19</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/16/Rust-CargoAndCratesIO/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-CargoAndCratesIO">Rust-CargoAndCratesIO</span>
            <span class="post-date" title="2021-12-16 22:52:05">2021/12/16</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/16/Rust-%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-函数式语言功能:迭代器与闭包">Rust-函数式语言功能:迭代器与闭包</span>
            <span class="post-date" title="2021-12-16 16:08:22">2021/12/16</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/15/Rust-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-IO">Rust-IO</span>
            <span class="post-date" title="2021-12-15 17:07:26">2021/12/15</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/15/Rust-%E6%B5%8B%E8%AF%95/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-测试">Rust-测试</span>
            <span class="post-date" title="2021-12-15 14:08:29">2021/12/15</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/14/Rust-%E6%B3%9B%E5%9E%8B%E3%80%81trait%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-泛型、trait和生命周期">Rust-泛型、trait和生命周期</span>
            <span class="post-date" title="2021-12-14 20:57:17">2021/12/14</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/14/Rust-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-错误处理">Rust-错误处理</span>
            <span class="post-date" title="2021-12-14 10:48:51">2021/12/14</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/13/Rust-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-常见集合">Rust-常见集合</span>
            <span class="post-date" title="2021-12-13 20:55:23">2021/12/13</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/13/Rust-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87%E5%92%8C%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-使用模块组织和复用代码">Rust-使用模块组织和复用代码</span>
            <span class="post-date" title="2021-12-13 16:26:05">2021/12/13</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/13/Rust-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-枚举和模式匹配">Rust-枚举和模式匹配</span>
            <span class="post-date" title="2021-12-13 10:44:04">2021/12/13</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/12/Rust-%E7%BB%93%E6%9E%84%E4%BD%93/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-结构体">Rust-结构体</span>
            <span class="post-date" title="2021-12-12 22:42:42">2021/12/12</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/12/Rust-%E6%89%80%E6%9C%89%E6%9D%83/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-所有权">Rust-所有权</span>
            <span class="post-date" title="2021-12-12 11:32:16">2021/12/12</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/11/Rust-%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-基础技术">Rust-基础技术</span>
            <span class="post-date" title="2021-12-11 20:25:09">2021/12/11</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/11/Rust-%E7%BC%96%E7%A8%8B%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-编程猜谜游戏">Rust-编程猜谜游戏</span>
            <span class="post-date" title="2021-12-11 18:58:04">2021/12/11</span>
        </a>
        
        <a  class="All rust "
           href="/2021/12/10/Rust-%E5%85%A5%E9%97%A8/"
           data-tag="rust"
           data-author="" >
            <span class="post-title" title="Rust-入门">Rust-入门</span>
            <span class="post-date" title="2021-12-10 11:18:25">2021/12/10</span>
        </a>
        
        <a  class="All java "
           href="/2021/12/10/Java-%E5%86%85%E9%83%A8%E7%B1%BB/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java-内部类">Java-内部类</span>
            <span class="post-date" title="2021-12-10 08:50:32">2021/12/10</span>
        </a>
        
        <a  class="All java "
           href="/2021/12/09/Java-%E6%8E%A5%E5%8F%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java-接口">Java-接口</span>
            <span class="post-date" title="2021-12-09 14:54:05">2021/12/09</span>
        </a>
        
        <a  class="All java "
           href="/2021/12/09/Java-%E5%A4%9A%E6%80%81/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java-多态">Java-多态</span>
            <span class="post-date" title="2021-12-09 08:42:47">2021/12/09</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/23/JavaNIO/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JavaNIO">JavaNIO</span>
            <span class="post-date" title="2021-11-23 10:47:14">2021/11/23</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/23/JavaIO/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JavaIO">JavaIO</span>
            <span class="post-date" title="2021-11-23 10:47:07">2021/11/23</span>
        </a>
        
        <a  class="All spring java "
           href="/2021/11/22/Spring%E5%B7%A5%E4%BD%9C%E5%AF%B9%E8%B1%A1/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring中的VO、BO、DTO、PO、DO">Spring中的VO、BO、DTO、PO、DO</span>
            <span class="post-date" title="2021-11-22 09:44:06">2021/11/22</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/18/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java函数式接口">Java函数式接口</span>
            <span class="post-date" title="2021-11-18 10:50:22">2021/11/18</span>
        </a>
        
        <a  class="All "
           href="/2021/11/17/SpringBoot%E5%90%AF%E5%8A%A8-%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot启动-基础">SpringBoot启动-基础</span>
            <span class="post-date" title="2021-11-17 17:01:58">2021/11/17</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/16/JRebel/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JRebel">JRebel</span>
            <span class="post-date" title="2021-11-16 08:58:18">2021/11/16</span>
        </a>
        
        <a  class="All spring "
           href="/2021/11/11/Spring%E5%90%AF%E5%8A%A8-%E5%9F%BA%E7%A1%80/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring启动-基础">Spring启动-基础</span>
            <span class="post-date" title="2021-11-11 15:25:33">2021/11/11</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/10/%E5%8F%8D%E5%B0%84/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="反射">反射</span>
            <span class="post-date" title="2021-11-10 20:57:08">2021/11/10</span>
        </a>
        
        <a  class="All java "
           href="/2021/11/10/%E6%B3%A8%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="注解">注解</span>
            <span class="post-date" title="2021-11-10 20:50:55">2021/11/10</span>
        </a>
        
        <a  class="All spring "
           href="/2021/11/09/SpringAOP-%E5%9F%BA%E7%A1%80/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="SpringAOP-基础">SpringAOP-基础</span>
            <span class="post-date" title="2021-11-09 10:31:31">2021/11/09</span>
        </a>
        
        <a  class="All spring "
           href="/2021/11/08/SpringIOC-%E5%9F%BA%E7%A1%80/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="SpringIOC-基础">SpringIOC-基础</span>
            <span class="post-date" title="2021-11-08 10:27:28">2021/11/08</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2021/11/02/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"
           data-tag="音视频"
           data-author="" >
            <span class="post-title" title="音视频编解码技术基础">音视频编解码技术基础</span>
            <span class="post-date" title="2021-11-02 12:06:49">2021/11/02</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2021/11/02/MysqlErrHosts/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="mysql安装时，Unable to connect to any of the specified MySQL hosts">mysql安装时，Unable to connect to any of the specified MySQL hosts</span>
            <span class="post-date" title="2021-11-02 10:58:50">2021/11/02</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2021/10/08/H264%E7%BC%96%E7%A0%81-SPSPPS/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="H264编码 SPS &amp; PPS">H264编码 SPS &amp; PPS</span>
            <span class="post-date" title="2021-10-08 21:20:12">2021/10/08</span>
        </a>
        
        <a  class="All ssr "
           href="/2021/01/18/centos%E7%BB%88%E7%AB%AFssr%E9%85%8D%E7%BD%AE/"
           data-tag="ssr"
           data-author="" >
            <span class="post-title" title="centos终端ssr配置">centos终端ssr配置</span>
            <span class="post-date" title="2021-01-18 08:21:35">2021/01/18</span>
        </a>
        
        <a  class="All 数据结构 算法分析 "
           href="/2020/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E5%85%B6%E4%BA%8C/"
           data-tag="数据结构与算法分析"
           data-author="" >
            <span class="post-title" title="数据结构与算法分析阅读笔记其二">数据结构与算法分析阅读笔记其二</span>
            <span class="post-date" title="2020-12-14 22:34:39">2020/12/14</span>
        </a>
        
        <a  class="All 数据结构 算法分析 "
           href="/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
           data-tag="数据结构与算法分析"
           data-author="" >
            <span class="post-title" title="数据结构与算法分析阅读笔记">数据结构与算法分析阅读笔记</span>
            <span class="post-date" title="2020-12-09 21:52:40">2020/12/09</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/10/27/FLV%E6%A0%BC%E5%BC%8F/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="FLV格式">FLV格式</span>
            <span class="post-date" title="2020-10-27 15:33:56">2020/10/27</span>
        </a>
        
        <a  class="All 机器学习 "
           href="/2020/09/20/Mac%E4%B8%ADPython3-x%E7%BC%96%E8%AF%91Caffe/"
           data-tag="机器学习"
           data-author="" >
            <span class="post-title" title="Mac中Python3.x编译Caffe">Mac中Python3.x编译Caffe</span>
            <span class="post-date" title="2020-09-20 01:08:09">2020/09/20</span>
        </a>
        
        <a  class="All JavaScript npm "
           href="/2020/07/17/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"
           data-tag="直播"
           data-author="" >
            <span class="post-title" title="npm常用命令操作">npm常用命令操作</span>
            <span class="post-date" title="2020-07-17 10:14:01">2020/07/17</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/16/MediaExtractorANDMediaMuxer/"
           data-tag="android,音频"
           data-author="" >
            <span class="post-title" title="android端的音频处理工具MediaExtractor和MediaMuxer">android端的音频处理工具MediaExtractor和MediaMuxer</span>
            <span class="post-date" title="2020-07-16 11:55:28">2020/07/16</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/15/AAC%E9%9F%B3%E9%A2%91%E7%A0%81%E6%B5%81/"
           data-tag="android,音频"
           data-author="" >
            <span class="post-title" title="AAC音频码流">AAC音频码流</span>
            <span class="post-date" title="2020-07-15 17:45:10">2020/07/15</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/15/Android-PCM%E5%A4%84%E7%90%86/"
           data-tag="android,音频"
           data-author="" >
            <span class="post-title" title="Android-PCM">Android-PCM</span>
            <span class="post-date" title="2020-07-15 13:29:49">2020/07/15</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/07/13/yuv-tool%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag="android,libyuv"
           data-author="" >
            <span class="post-title" title="yuv-tool工具类">yuv-tool工具类</span>
            <span class="post-date" title="2020-07-13 22:58:21">2020/07/13</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2020/06/18/ffmpegforandroid%E7%BC%96%E8%AF%91/"
           data-tag="ffmpeg"
           data-author="" >
            <span class="post-title" title="ffmpegforandroid编译">ffmpegforandroid编译</span>
            <span class="post-date" title="2020-06-18 13:38:35">2020/06/18</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2020/06/11/libfaac%E7%BC%96%E8%AF%91/"
           data-tag="libfaac"
           data-author="" >
            <span class="post-title" title="libfaac编译">libfaac编译</span>
            <span class="post-date" title="2020-06-11 14:00:57">2020/06/11</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2020/06/11/libx264%E7%BC%96%E8%AF%91/"
           data-tag="libx264"
           data-author="" >
            <span class="post-title" title="libx264编译">libx264编译</span>
            <span class="post-date" title="2020-06-11 13:51:36">2020/06/11</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2020/06/10/RTMP%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"
           data-tag="RTMP,直播"
           data-author="" >
            <span class="post-title" title="RTMP规范学习">RTMP规范学习</span>
            <span class="post-date" title="2020-06-10 11:35:52">2020/06/10</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/06/01/React-Native%E7%83%AD%E6%9B%B4%E6%96%B0/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native热更新">React-Native热更新</span>
            <span class="post-date" title="2020-06-01 16:03:28">2020/06/01</span>
        </a>
        
        <a  class="All 后台 "
           href="/2020/06/01/JavaWeb/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JavaWeb">JavaWeb</span>
            <span class="post-date" title="2020-06-01 11:09:17">2020/06/01</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2020/05/26/JDBC/"
           data-tag="java,数据库"
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2020-05-26 16:23:01">2020/05/26</span>
        </a>
        
        <a  class="All 后台 "
           href="/2020/03/29/%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F/"
           data-tag="后台,跨域"
           data-author="" >
            <span class="post-title" title="了解跨域">了解跨域</span>
            <span class="post-date" title="2020-03-29 21:31:15">2020/03/29</span>
        </a>
        
        <a  class="All JavaScript "
           href="/2020/03/08/JavaScript%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="javaScript"
           data-author="" >
            <span class="post-title" title="JavaScript语法（一）">JavaScript语法（一）</span>
            <span class="post-date" title="2020-03-08 10:29:30">2020/03/08</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/03/06/React-native-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-native 高德地图">React-native 高德地图</span>
            <span class="post-date" title="2020-03-06 10:07:45">2020/03/06</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/03/03/React-16-8-Hooks/"
           data-tag="React"
           data-author="" >
            <span class="post-title" title="React 16.8 Hooks">React 16.8 Hooks</span>
            <span class="post-date" title="2020-03-03 10:07:02">2020/03/03</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2020/01/06/React-Native%E5%8E%9F%E7%94%9F%E9%80%9A%E4%BF%A1/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native原生通信">React-Native原生通信</span>
            <span class="post-date" title="2020-01-06 16:34:00">2020/01/06</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/27/React-Native%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native原理浅析">React-Native原理浅析</span>
            <span class="post-date" title="2019-12-27 15:32:08">2019/12/27</span>
        </a>
        
        <a  class="All 正则表达式 "
           href="/2019/12/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag="正则表达式"
           data-author="" >
            <span class="post-title" title="正则表达式">正则表达式</span>
            <span class="post-date" title="2019-12-18 21:45:36">2019/12/18</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/05/React-Native-%E5%8A%A8%E7%94%BB/"
           data-tag="ReactNative"
           data-author="" >
            <span class="post-title" title="React-Native-动画">React-Native-动画</span>
            <span class="post-date" title="2019-12-05 16:20:25">2019/12/05</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/03/React-%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="React-自学之路（二）">React-自学之路（二）</span>
            <span class="post-date" title="2019-12-03 13:06:53">2019/12/03</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/12/03/React-%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="React"
           data-author="" >
            <span class="post-title" title="React-自学之路（一）">React-自学之路（一）</span>
            <span class="post-date" title="2019-12-03 09:40:28">2019/12/03</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2019/10/12/React%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
           data-tag="react"
           data-author="" >
            <span class="post-title" title="React新的生命周期">React新的生命周期</span>
            <span class="post-date" title="2019-10-12 15:41:02">2019/10/12</span>
        </a>
        
        <a  class="All 后台 "
           href="/2019/09/18/%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E6%97%B6%EF%BC%8C%E5%87%BA%E7%8E%B0Could-not-calculate-build-plan%E9%94%99%E8%AF%AF/"
           data-tag="springboot"
           data-author="" >
            <span class="post-title" title="创建maven项目时，出现Could not calculate build plan错误">创建maven项目时，出现Could not calculate build plan错误</span>
            <span class="post-date" title="2019-09-18 09:25:06">2019/09/18</span>
        </a>
        
        <a  class="All 数据库 "
           href="/2019/09/07/MySQL%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="MySQL常用指令">MySQL常用指令</span>
            <span class="post-date" title="2019-09-07 21:10:03">2019/09/07</span>
        </a>
        
        <a  class="All Android "
           href="/2019/07/05/RecycleView%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="RecycleView（一）">RecycleView（一）</span>
            <span class="post-date" title="2019-07-05 14:03:06">2019/07/05</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/25/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%89%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android动画（三）">Android动画（三）</span>
            <span class="post-date" title="2019-06-25 14:15:26">2019/06/25</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/20/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android动画（二）">Android动画（二）</span>
            <span class="post-date" title="2019-06-20 15:10:00">2019/06/20</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/19/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android动画（一）">Android动画（一）</span>
            <span class="post-date" title="2019-06-19 15:15:56">2019/06/19</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/18/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android自定义控件（二）">Android自定义控件（二）</span>
            <span class="post-date" title="2019-06-18 13:43:11">2019/06/18</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/13/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"
           data-tag="Android,贝塞尔曲线"
           data-author="" >
            <span class="post-title" title="贝塞尔曲线">贝塞尔曲线</span>
            <span class="post-date" title="2019-06-13 10:14:25">2019/06/13</span>
        </a>
        
        <a  class="All Android "
           href="/2019/06/04/Java-Binder%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%90%86%E8%A7%A3/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Java Binder进程通信理解">Java Binder进程通信理解</span>
            <span class="post-date" title="2019-06-04 14:01:43">2019/06/04</span>
        </a>
        
        <a  class="All Android "
           href="/2019/05/30/arm-neon-h%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD/"
           data-tag="汇编"
           data-author="" >
            <span class="post-title" title="arm-neon.h文件功能">arm-neon.h文件功能</span>
            <span class="post-date" title="2019-05-30 08:45:08">2019/05/30</span>
        </a>
        
        <a  class="All Android "
           href="/2019/05/06/Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"
           data-tag="android"
           data-author="" >
            <span class="post-title" title="Handler消息机制">Handler消息机制</span>
            <span class="post-date" title="2019-05-06 14:09:45">2019/05/06</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/05/06/H264%E7%BC%96%E7%A0%81-%E7%86%B5%E7%BC%96%E7%A0%81/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="H264编码-熵编码">H264编码-熵编码</span>
            <span class="post-date" title="2019-05-06 13:42:57">2019/05/06</span>
        </a>
        
        <a  class="All Android "
           href="/2019/04/08/NDK%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"
           data-tag="NDK"
           data-author="" >
            <span class="post-title" title="NDK开发问题合集">NDK开发问题合集</span>
            <span class="post-date" title="2019-04-08 10:53:30">2019/04/08</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/04/01/H264%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/"
           data-tag="视频格式"
           data-author="" >
            <span class="post-title" title="H264编码基础">H264编码基础</span>
            <span class="post-date" title="2019-04-01 09:26:11">2019/04/01</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/03/31/srs%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"
           data-tag="直播,srs"
           data-author="" >
            <span class="post-title" title="srs直播平台搭建">srs直播平台搭建</span>
            <span class="post-date" title="2019-03-31 10:37:42">2019/03/31</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/03/27/%E5%9B%BE%E7%89%87RGB%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"
           data-tag="图片格式"
           data-author="" >
            <span class="post-title" title="图片RGB数据格式">图片RGB数据格式</span>
            <span class="post-date" title="2019-03-27 22:24:49">2019/03/27</span>
        </a>
        
        <a  class="All 音视频 "
           href="/2019/03/14/%E5%9B%BE%E7%89%87YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"
           data-tag="图片格式"
           data-author="" >
            <span class="post-title" title="图片YUV数据格式">图片YUV数据格式</span>
            <span class="post-date" title="2019-03-14 11:10:16">2019/03/14</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2019/03/08/libjpeg-turbo%E7%BC%96%E8%AF%91/"
           data-tag="libjpeg-turbo"
           data-author="" >
            <span class="post-title" title="libjpeg-turbo编译">libjpeg-turbo编译</span>
            <span class="post-date" title="2019-03-08 13:41:20">2019/03/08</span>
        </a>
        
        <a  class="All 编译的库 "
           href="/2019/03/07/libYUV%E7%BC%96%E8%AF%91/"
           data-tag="libyuv"
           data-author="" >
            <span class="post-title" title="libYUV编译">libYUV编译</span>
            <span class="post-date" title="2019-03-07 15:05:11">2019/03/07</span>
        </a>
        
        <a  class="All Android "
           href="/2019/02/18/Android-camera%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="camera"
           data-author="" >
            <span class="post-title" title="Android camera（一）">Android camera（一）</span>
            <span class="post-date" title="2019-02-18 15:03:27">2019/02/18</span>
        </a>
        
        <a  class="All C/C++ "
           href="/2019/01/23/Cpp%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Cpp"
           data-author="" >
            <span class="post-title" title="Cpp基础（一）">Cpp基础（一）</span>
            <span class="post-date" title="2019-01-23 10:52:13">2019/01/23</span>
        </a>
        
        <a  class="All C/C++ "
           href="/2019/01/18/C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="C"
           data-author="" >
            <span class="post-title" title="C基础（一）">C基础（一）</span>
            <span class="post-date" title="2019-01-18 14:08:23">2019/01/18</span>
        </a>
        
        <a  class="All Android "
           href="/2018/12/18/EasyPermission/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="EasyPermission">EasyPermission</span>
            <span class="post-date" title="2018-12-18 13:20:30">2018/12/18</span>
        </a>
        
        <a  class="All Android "
           href="/2018/12/15/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android自定义控件（一）">Android自定义控件（一）</span>
            <span class="post-date" title="2018-12-15 21:44:34">2018/12/15</span>
        </a>
        
        <a  class="All ssr "
           href="/2018/12/10/Linux%E9%85%8D%E7%BD%AEShadowSocks-R/"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux配置ShadowSocks-R">Linux配置ShadowSocks-R</span>
            <span class="post-date" title="2018-12-10 15:58:52">2018/12/10</span>
        </a>
        
        <a  class="All Android 热更新 "
           href="/2018/10/29/Sophix%E7%83%AD%E6%9B%B4%E6%96%B0/"
           data-tag="android,热更新"
           data-author="" >
            <span class="post-title" title="Sophix热更新">Sophix热更新</span>
            <span class="post-date" title="2018-10-29 16:50:36">2018/10/29</span>
        </a>
        
        <a  class="All Android 热更新 "
           href="/2018/10/18/TinkerPatch%E7%83%AD%E6%9B%B4%E6%96%B0/"
           data-tag="android,热更新"
           data-author="" >
            <span class="post-title" title="TinkerPatch热更新">TinkerPatch热更新</span>
            <span class="post-date" title="2018-10-18 20:11:30">2018/10/18</span>
        </a>
        
        <a  class="All ReactNative "
           href="/2018/06/21/React-native-flex%E5%B8%83%E5%B1%80/"
           data-tag="react"
           data-author="" >
            <span class="post-title" title="React-native flex布局">React-native flex布局</span>
            <span class="post-date" title="2018-06-21 16:22:47">2018/06/21</span>
        </a>
        
        <a  class="All Android "
           href="/2018/01/25/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android事件分发">Android事件分发</span>
            <span class="post-date" title="2018-01-25 16:36:52">2018/01/25</span>
        </a>
        
        <a  class="All Gradle "
           href="/2018/01/25/Gradle%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="构建工具,Gradle"
           data-author="" >
            <span class="post-title" title="Gradle（一）">Gradle（一）</span>
            <span class="post-date" title="2018-01-25 16:36:52">2018/01/25</span>
        </a>
        
        <a  class="All git "
           href="/2017/11/24/firstBlod2/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git详细讲解(远程)">Git详细讲解(远程)</span>
            <span class="post-date" title="2017-11-24 10:18:05">2017/11/24</span>
        </a>
        
        <a  class="All git "
           href="/2017/10/19/firstBlod/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git详细讲解(本地)">Git详细讲解(本地)</span>
            <span class="post-date" title="2017-10-19 21:49:28">2017/10/19</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Rust-死灵术" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Rust-死灵书（一）</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="rust">rust</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">rust</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-06-10 01:10:24'>2022-04-01 16:42</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9D%9E%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">一、初识安全与非安全代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9D%9E%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1 安全与非安全代码的交互方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%9D%9E%E5%AE%89%E5%85%A8Rust%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">1.2 非安全Rust能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BC%96%E5%86%99%E9%9D%9E%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3 编写非安全代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="toc-text">二、数据布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-repr%EF%BC%88Rust%EF%BC%89"><span class="toc-text">2.1 repr（Rust）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%A5%87%E8%A1%8C%E7%A7%8D"><span class="toc-text">2.2 类型中的奇行种</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-1-%E5%8A%A8%E6%80%81%E5%B0%BA%E5%AF%B8%E7%B1%BB%E5%9E%8B-DST-Dynamically-Sized-Type"><span class="toc-text">2.2.1 动态尺寸类型(DST, Dynamically Sized Type)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-2-%E9%9B%B6%E5%B0%BA%E5%AF%B8%E7%B1%BB%E5%9E%8B-ZST-Zero-Sized-Type"><span class="toc-text">2.2.2 零尺寸类型(ZST, Zero Sized Type)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-3-%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2.3 空类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%B6%E4%BB%96repr"><span class="toc-text">2.3 其他repr</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-1-repr-C"><span class="toc-text">2.3.1 repr(C)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-2-repr-u-repr-i"><span class="toc-text">2.3.2 repr(u), repr(i)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-3-repr-packed"><span class="toc-text">2.3.3 repr(packed)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">三、所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BC%95%E7%94%A8"><span class="toc-text">3.1 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%AB%E5%90%8D"><span class="toc-text">3.2 别名</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%AB%E5%90%8D%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-text">3.2.1 为什么别名很重要</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.3 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BC%95%E7%94%A8%E8%B6%85%E5%87%BA%E8%A2%AB%E5%BC%95%E7%94%A8%E5%86%85%E5%AE%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.3.1 示例：引用超出被引用内容生命周期</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-2-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AD%98%E5%9C%A8%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-text">3.3.2 示例：存在可变引用的别名</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-text">3.4 生命周期的局限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%9C%81%E7%95%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.5 省略生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%97%A0%E7%95%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.6 无界生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E9%AB%98%E9%98%B6trait%E8%BE%B9%E7%95%8C-HRTB"><span class="toc-text">3.7 高阶trait边界(HRTB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E6%80%A7"><span class="toc-text">3.8 子类型和变性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-1-%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.8.1 子类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-2-%E5%8F%98%E6%80%A7"><span class="toc-text">3.8.2 变性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E6%80%A7-more"><span class="toc-text">3.8 子类型和变性-more</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-1-%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3.8.1 子类型解决的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9C%A8%E8%BF%99%E9%87%8C%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3.8.2 生命周期在这里的作用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-3-%E5%8F%98%E5%9E%8B"><span class="toc-text">3.8.3 变型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8D%8F%E5%8F%98"><span class="toc-text">3.8.4 生命周期的协变</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-8-5-%E6%8B%A5%E6%9C%89%E6%89%80%E6%9C%89%E6%9D%83%E6%97%B6%E7%9A%84%E5%8D%8F%E5%8F%98"><span class="toc-text">3.8.5 拥有所有权时的协变</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-Drop%E6%A3%80%E6%9F%A5"><span class="toc-text">3.9 Drop检查</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-9-1-%E7%95%99%E4%B8%80%E4%B8%AA%E5%90%8E%E9%97%A8"><span class="toc-text">3.9.1 留一个后门</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-PhantomData-%E5%B9%BD%E7%81%B5%E6%95%B0%E6%8D%AE"><span class="toc-text">3.10 PhantomData-幽灵数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-10-1-PhantomData%E6%A8%A1%E5%BC%8F%E8%A1%A8"><span class="toc-text">3.10.1 PhantomData模式表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E5%88%86%E8%A7%A3%E5%80%9F%E7%94%A8"><span class="toc-text">3.11 分解借用</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、初识安全与非安全代码"><a href="#一、初识安全与非安全代码" class="headerlink" title="一、初识安全与非安全代码"></a>一、初识安全与非安全代码</h2><p>当使用某种安全编程语言的过程中遇到了处理底层实现的需求时，程序员通常有三种选择：</p>
<ul>
<li>修改代码让编译器或者运行时环境做相关优化</li>
<li>采取某些古怪、繁琐的奇技淫巧以实现功能需求</li>
<li>使用另一种可以处理底层细节的语言重写代码</li>
</ul>
<p>对于最后一个选项，程序员通常会选择C语言。某些系统也只对外暴漏了C的接口。</p>
<p>然而，C在使用中往往过于不安全（虽然有时是出于合理的原因）。尤其是在与其他语言交互的过程中，这种不安全性还会被放大。C和与其交互的语言必须时刻小心地确认对方的行为，以防踩到舞伴的脚趾头。</p>
<p>那么这和Rust有什么关系呢？</p>
<p>嗯……不同于C，Rust是一种安全的编程语言。</p>
<p>但是，和C相同的是，Rust是一种非安全的编程语言。</p>
<p>更准确地说，Rust是一种同时包含安全和非安全特性的编程语言。</p>
<p>非安全Rust和安全Rust的语法规则完全相同，只不过它允许你做一些另外的不安全的行为。</p>
<h3 id="1-1-安全与非安全代码的交互方式"><a href="#1-1-安全与非安全代码的交互方式" class="headerlink" title="1.1 安全与非安全代码的交互方式"></a>1.1 安全与非安全代码的交互方式</h3><p>安全与非安全代码是靠<code>unsafe</code>关键字分离的，它扮演着两种语言之间接口的角色。也可以在代码根部添加<code>#![forbid(unsafe_code)]</code>以保证你只会写安全的代码。</p>
<p><code>unsafe</code>关键字有两层含义：声明代码中存在编译器无法检查的安全规范，同时声明开发者会自觉遵守相关规范而不会主动破坏它。</p>
<p><code>unsafe</code>可以给函数、trait、代码块添加。</p>
<p>标准库也有一些非安全函数，包括：</p>
<ul>
<li><code>slice::get_unchecked</code>，可接受不受检查的索引值，也就是存在内存安全机制被破坏的可能</li>
<li><code>mem::transmute</code>，将值重新解析成另一种类型，即允许随意绕过类型安全机制的限制（详情参考类型转换）</li>
<li>所有指向确定大小类型(sized type)的裸指针都有<code>offset</code>方法，当传入的偏移量越界时将导致未定义行为(Undefined Behavior)。</li>
<li>所有FFI（Foreign Function Interface）函数都是<code>unsafe</code>的，因为其他的语言可以做各种的操作而Rust编译器无法检查它。</li>
</ul>
<p>另外有两个需要注意的非安全的trait：</p>
<ul>
<li><code>Send</code>是一个标志trait（即没有任何方法的trait），承诺所有的实现都可以安全地发送（move）到另一个线程。</li>
<li><code>Sync</code>也是一个标志trait，承诺线程可以通过共享的引用共享它的实现。</li>
</ul>
<p>一个trait是否应该标志为<code>unsafe</code>是API设计上的选择。Rust通常会尽量避免这么做，因为它会导致非安全Rust的滥用，这并不是设计者们希望看到的。</p>
<p><code>Send</code>和<code>Sync</code>是会被各种类型自动实现的，只要这种实现可以被证明是安全的。如果一种类型其所有的值的类型都实现了<code>Send</code>，它本身就会自动实现<code>Send</code>；如果一种类型其所有的值的类型都实现了<code>Sync</code>，它本身就会自动实现<code>Sync</code>。将它们设为<code>unsafe</code>实际减少了非安全代码的滥用。</p>
<h3 id="1-2-非安全Rust能做什么"><a href="#1-2-非安全Rust能做什么" class="headerlink" title="1.2 非安全Rust能做什么"></a>1.2 非安全Rust能做什么</h3><p>非安全Rust比安全Rust可以多做的事情只有以下几个：</p>
<ul>
<li>解引用裸指针</li>
<li>调用非安全函数（包括C语言函数，编译器内联函数，还有直接内存分配等）</li>
<li>实现非安全trait</li>
<li>访问或修改可变静态变量</li>
</ul>
<p>这些操作被归为非安全的，是因为使用得不正确就会导致可怕的未定义行为。一旦触发了未定义行为，编译器就可以放飞自我，肆意破坏你的程序。</p>
<p>Rust充分限制了可能出现的未定义行为的种类。语言核心只需要防止这几种行为：</p>
<ul>
<li>解引用null指针，悬垂指针，或者未赋值的指针</li>
<li>读取未初始化的内存</li>
<li>破坏指针混淆规则</li>
<li>创建非法的基本类型：<ul>
<li>悬垂引用与null引用</li>
<li>空的fn指针</li>
<li>0和1以外的bool类型值</li>
<li>未定义的枚举类型的项</li>
<li>在[0x0,0xD&amp;FF]和[0xE000, 0x10FFFF]以外的char类型值</li>
<li>非utf-8编码的str</li>
</ul>
</li>
<li>不谨慎地调用其他语言</li>
<li>数据竞争</li>
</ul>
<p>Rust语言自身可以导致未定义行为的操作就只有这些。当然，非安全函数和trait可以声明自己专有的安全规范，要求开发者必须遵守以避免未定义行为。</p>
<p>违背这些专有的规范通常也只是间接地触发上面列出的行为。另外，编译器内联函数也可能引入一些规则，一般是针对代码优化的假设条件。比如，Vec和Box使用的内联函数要求传入的指针永远不能为null。</p>
<p>Rust对于一些模糊的操作则通常比较宽容。Rust会认为下列操作是安全的：</p>
<ul>
<li>死锁</li>
<li>竞争条件</li>
<li>内存泄漏</li>
<li>调用析构函数失败</li>
<li>整型值溢出</li>
<li>终止程序</li>
<li>删除产品数据库</li>
</ul>
<p>当然，有以上行为的程序极有可能就是错误的。Rust提供了一系列的工具减少这种事情的发生，但是完全地杜绝它们其实是不现实的。</p>
<h3 id="1-3-编写非安全代码"><a href="#1-3-编写非安全代码" class="headerlink" title="1.3 编写非安全代码"></a>1.3 编写非安全代码</h3><p>Rust通常要求我们明确限制非安全Rust代码的作用域。可是，现实情况其实要更复杂一些。举个例子，看一下下面的代码：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(idx: <span class="hljs-built_in">usize</span>, arr: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> idx &lt; arr.len() &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-literal">Some</span>(*arr.get_unchecked(idx))<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这个函数是安全和正确的。我们检查了索引值有没有越界。如果没有，就从数组中用不安全的方式取出对应的值。然而，哪怕是这么简单的一个函数，unsafe代码块的范围也不是绝对明确的。想象一下，如果把 <code>&lt;</code>改成 <code>&lt;=</code>：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(idx: <span class="hljs-built_in">usize</span>, arr: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> idx &lt;= arr.len() &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-literal">Some</span>(*arr.get_unchecked(idx))<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这段程序就有潜在的问题了，但我们其实只修改了安全代码的部分。这是安全机制的一个根本性问题：非本地性。意思是，非安全代码的稳定性其实依赖于另一些“安全”代码的状态。</p>
<p>是否进入非安全代码块，并不受其他部分代码正确性的影响，从这个角度看安全机制是模块化的。比如，是否对一个slice进行不安全索引，不受slice是不是null或者是不是包含未初始化的内存这些事情的影响。但是，由于程序本身是有状态的，非安全操作的结果实际依赖于其他部分的状态，从这个角度看安全机制又是非模块化的。</p>
<p>处理持久化状态时，非本地性带来的问题就更加明显了。看一下<code>Vec</code>的一个简单实现：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ptr;<br><span class="hljs-comment">// 注意：这个定义十分简单。参考实现Vec的章节</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span></span>&lt;T&gt; &#123;<br>    ptr: *<span class="hljs-keyword">mut</span> T,<br>    len: <span class="hljs-built_in">usize</span>,<br>    cap: <span class="hljs-built_in">usize</span>,<br>&#125;<br><span class="hljs-comment">// 注意：这个实现未考虑大小为0的类型。参考实现Vec的章节</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">push</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: T) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.len == <span class="hljs-keyword">self</span>.cap &#123;<br>            <span class="hljs-comment">// 与例子本身无关</span><br>            <span class="hljs-keyword">self</span>.reallocate();<br>        &#125;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ptr::write(<span class="hljs-keyword">self</span>.ptr.offset(<span class="hljs-keyword">self</span>.len <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>), elem);<br>            <span class="hljs-keyword">self</span>.len += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这段代码很简单，便于审查和修改。现在考虑给它添加一个新的方法：<br><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_room</span>(<span class="hljs-params">&amp;mut <span class="hljs-built_in">self</span></span>) </span>&#123;<br>    <span class="hljs-comment">// 增加容量</span><br>    <span class="hljs-built_in">self</span>.cap += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>这段代码是100%的安全Rust但是彻底的不稳定。改变容量违反了Vec的不变性（<code>cap</code>表示分配给Vec的空间大小）。Vec的其他部分并不会保护它，我们只能信任它的值是正确的，因为本来没有修改它的方法。</p>
<p>因为代码逻辑依赖于struct的某个成员的不变性，那段<code>unsafe</code>的代码不仅仅污染了它所在的函数，它还污染了整个module。一般来说，只有在一个私有的module里非安全代码才可能是真正安全的。</p>
<p>这允许我们基于一些复杂的不变性写一些绝对安全的抽象。在考虑安全Rust和非安全Rust的关系时，这一点非常重要。</p>
<h2 id="二、数据布局"><a href="#二、数据布局" class="headerlink" title="二、数据布局"></a>二、数据布局</h2><h3 id="2-1-repr（Rust）"><a href="#2-1-repr（Rust）" class="headerlink" title="2.1 repr（Rust）"></a>2.1 repr（Rust）</h3><p>首先，每种类型都有一个数据<code>对齐属性(alignment)</code>。<strong>一种类型的对齐属性决定了哪些内存地址可以合法地存储该类型的值。</strong>如果对齐属性是n，那么它的值的存储地址必须是n的倍数。所以，对齐属性2表示值只能存储在偶数地址里，1表示值可以存储在任何的地方。对齐属性最小为1，并且永远是2的整数次幂。虽然不同平台的行为可能会不同，但大部分情况下基础类型都是按照它的类型大小对齐的。特别的是，在x86平台上<code>u64</code>和<code>f64</code>都是按照32位对齐的。</p>
<p>一种类型的大小都是它对齐属性的整数倍，这保证了这种类型的值在数组中的偏移量都是其类型尺寸的整数倍，可以按照偏移量进行索引。需要注意的是，<strong>动态尺寸类型的大小和对齐可能无法静态获取。</strong></p>
<p>Rust有如下几种复合类型：</p>
<ul>
<li>结构体（带命名的复合类型 named product types）</li>
<li>元组（匿名的复合类型 anonymous product types）</li>
<li>数组（同类型数据集合 homogeneous product types）</li>
<li>枚举（带命名的标签联合体 named sum types — tagged unions）</li>
</ul>
<p>如果枚举类型的变量没有关联数据，它就被称之为无成员枚举。</p>
<p>结构体的对齐属性等于它所有成员的对齐属性中最大的那个。Rust会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时整个类型的尺寸是对齐属性的整数倍。例如：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">struct <span class="hljs-class">A </span>&#123;<br><span class="hljs-symbol">    a:</span> u8,<br><span class="hljs-symbol">    b:</span> u32,<br><span class="hljs-symbol">    c:</span>u16,<br>&#125;<br></code></pre></td></tr></table></figure><br>在对齐属性与类型尺寸相同的平台上，这个结构体会按照32位对齐。整个结构体的类型尺寸是32位的整数倍。它实际会转变成这样：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">struct <span class="hljs-class">A </span>&#123;<br><span class="hljs-symbol">    a:</span> u8,<br><span class="hljs-symbol">    _pad1:</span> [u8; <span class="hljs-number">3</span>], <span class="hljs-comment">// 为了对齐b</span><br><span class="hljs-symbol">    b:</span> u32,<br><span class="hljs-symbol">    c:</span> u16,<br><span class="hljs-symbol">    _pad2:</span> [u8; <span class="hljs-number">2</span>], <span class="hljs-comment">// 保证整体类型尺寸是4的倍数</span><br>                    <span class="hljs-comment">// （译注：原文就是“4的倍数”，但似乎“32的倍数”才对）</span><br>&#125;<br></code></pre></td></tr></table></figure><br>这里所有的类型都是直接存储在结构体中的，成员类型和结构体之间没有其他的中介。这一点和C是一样的。但是除了数组以外（数组的子类型总是按顺序紧密排列），其他的复合类型的数据分布规则并不一定是固定不变的。对于下面两个结构体定义：<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">struct <span class="hljs-selector-tag">A</span> &#123;<br>    <span class="hljs-selector-tag">a</span>: i32,<br>    b: u64,<br>&#125;<br>struct <span class="hljs-selector-tag">B</span> &#123;<br>    <span class="hljs-selector-tag">a</span>: i32,<br>    b: u64,<br>&#125;<br></code></pre></td></tr></table></figure><br>Rust可以保证A的两个实例的数据布局是完全相同的。但是Rust目前不保证A的实例和B的实例有着一样的数据填充和成员顺序，虽然看起来他们似乎就应该是一样的才对。</p>
<p>对于上面的A和B来说，这一点大概显得莫名其妙。可是当Rust要处理更复杂的数据布局问题时，它就变得很有必要了。</p>
<p>例如，对于这个结构体：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">struct Foo<span class="hljs-params">&lt;T, U&gt;</span> &#123;<br><span class="hljs-symbol">    count:</span> u16,<br><span class="hljs-symbol">    data1:</span> T,<br><span class="hljs-symbol">    data2:</span> U,<br>&#125;<br></code></pre></td></tr></table></figure><br>现在考虑范型<code>Foo&lt;u32, u16&gt;</code>和<code>Foo&lt;u16, u32&gt;</code>。如果Rust按照代码中指定的顺序布局结构体成员，那么它就必须填充数据以符合对齐规则。所以，如果Rust不改变成员顺序的话，他们实际上会变成这样：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>&lt;<span class="hljs-built_in">u16</span>, <span class="hljs-built_in">u32</span>&gt; &#123;<br>    count: <span class="hljs-built_in">u16</span>,<br>    data1: <span class="hljs-built_in">u16</span>,<br>    data2: <span class="hljs-built_in">u32</span>,<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>&lt;<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u16</span>&gt; &#123;<br>    count: <span class="hljs-built_in">u16</span>,<br>    _pad1: <span class="hljs-built_in">u16</span>,<br>    data1: <span class="hljs-built_in">u32</span>,<br>    data2: <span class="hljs-built_in">u16</span>,<br>    _pad2: <span class="hljs-built_in">u16</span>,<br>&#125;<br></code></pre></td></tr></table></figure><br>后者显然太浪费内存了。所以，内存优化原则要求不同的范型可以有不同的成员顺序。</p>
<p>枚举把这件事搞得更复杂了。举一个简单的枚举类型为例：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">enum Foo &#123;<br>    <span class="hljs-constructor">A(<span class="hljs-params">u32</span>)</span>,<br>    <span class="hljs-constructor">B(<span class="hljs-params">u64</span>)</span>,<br>    <span class="hljs-constructor">C(<span class="hljs-params">u8</span>)</span>,<br>&#125;<br></code></pre></td></tr></table></figure><br>它的布局会是这样：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">struct <span class="hljs-class">FooRepr </span>&#123;<br><span class="hljs-symbol">    data:</span> u64, <span class="hljs-comment">// 根据tag的不同，这一项可以为u64，u32，或者u8</span><br><span class="hljs-symbol">    tag:</span> u8, <span class="hljs-comment">// 0 = A, 1 = B, 2 = C</span><br>&#125;<br></code></pre></td></tr></table></figure><br>这也确实就是一般情况下枚举的布局方式。</p>
<p>但是，在很多情况下这种表达方式并不是效率最高的。一个典型场景就是Rust的“null指针优化”：如果一个枚举类型只包含一个单值变量（比如None）和一个（级联的）非null指针变量（比如&amp;T），那么tag其实是不需要的，因为那个单值变量完全可以用null指针来表示。所以，<code>size_of::&lt;Option&lt;&amp;T&gt;&gt;() == size_of::&lt;&amp;T&gt;()</code>，这个比较的结果是正确的。</p>
<p>Rust中的许多类型都包含或者本身就是非null指针，比如<code>Box&lt;T&gt;</code>，<code>Vec&lt;T&gt;</code>，<code>String</code>，<code>&amp;T</code>以及<code>&amp;mut T</code>。同样的，你或许也能想到，对于级联的枚举类型，Rust会把多个tag变量合并为一个，因为它们本来就只有几个有限的可能取值。大体说来，枚举类型会运用复杂的算法确定各种级联类型的二进制表达方法。因为这件事很重要，我们把枚举的问题留到后面讨论。</p>
<h3 id="2-2-类型中的奇行种"><a href="#2-2-类型中的奇行种" class="headerlink" title="2.2 类型中的奇行种"></a>2.2 类型中的奇行种</h3><p>大部分情况下，我们考虑的都是拥有固定的正数尺寸的类型。但是，并非所有类型都是这样。</p>
<h6 id="2-2-1-动态尺寸类型-DST-Dynamically-Sized-Type"><a href="#2-2-1-动态尺寸类型-DST-Dynamically-Sized-Type" class="headerlink" title="2.2.1 动态尺寸类型(DST, Dynamically Sized Type)"></a>2.2.1 动态尺寸类型(DST, Dynamically Sized Type)</h6><p>Rust支持动态尺寸类型，即不能静态获取尺寸或对齐属性的类型。乍一看，这事有点荒谬——Rust必须知道一种类型的大小和对齐方式才能正确地使用它啊！从这一点来看，DST不是一个普通的类型。由于类型大小是未知的，只能通过某种指针来访问它。所以，一个指向DST的指针是一个“胖”指针，它包含指针本身和一些额外的信息（具体请往下看）。</p>
<p>语言提供了两种主要的DST：trait对象和slice。</p>
<p>trait对象表示实现了某种指定trait的类型。具体的类型被擦除了，取而代之的是<code>运行期的一个虚函数表</code>，表中包含了使用这种类型所有必要的信息。这就是trai对象的额外信息：<code>一个指向虚函数表的指针。</code></p>
<p>slice简单来说是一个连续存储结构的视图——最典型的连续存储结构是数组或<code>Vec</code>。slice对应的额外信息就是它所指向元素的数量。</p>
<p>结构体可以在最后的位置上保存一个DST，但是这样结构体本身也就变成了一个DST。<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 不能直接存储在栈上</span><br>struct <span class="hljs-class">Foo </span>&#123;<br><span class="hljs-symbol">    info:</span> u32,<br><span class="hljs-symbol">    data:</span> [u8],<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h6 id="2-2-2-零尺寸类型-ZST-Zero-Sized-Type"><a href="#2-2-2-零尺寸类型-ZST-Zero-Sized-Type" class="headerlink" title="2.2.2 零尺寸类型(ZST, Zero Sized Type)"></a>2.2.2 零尺寸类型(ZST, Zero Sized Type)</h6><p>Rust实际允许一种类型不占用内存空间：<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">struct Foo; <span class="hljs-regexp">//</span> 没有成员 = 没有尺寸<br><span class="hljs-regexp">//</span> 所有成员都没有尺寸 = 没有尺寸<br>struct Baz &#123;<br>    foo: Foo,<br>    qux: (),      <span class="hljs-regexp">//</span> 空元组没有尺寸<br>    baz: [u8; <span class="hljs-number">0</span>], <span class="hljs-regexp">//</span> 空数组没有尺寸<br>&#125;<br></code></pre></td></tr></table></figure><br>对于其自身来说，ZST显然没有任何用处。但是，和Rust中许多奇怪的布局选项一样，它的作用只在特定的上下文中才能体现：Rust认为所有产生或存储ZST的操作都可以被视为无操作(no-op)。首先，存储它没有什么意义——它又不占用空间。而且这种类型实际上只有一个值，所以加载它的操作可以凭空变一个值出来——而这种操作依然是no-op，因为产生的值不占用空间。</p>
<p>ZST的一个最极端的例子是<code>Set和Map</code>。已经有了类型<code>Map&lt;Key, Value&gt;</code>，那么要实现<code>Set&lt;Key, Value&gt;</code>的通常做法是简单封装一个<code>Map&lt;Key, UselessJunk&gt;</code>。很多语言不得不给<code>UselessJunk</code>分配空间，还要存储、加载它，然后再什么都不做直接丢弃它。编译器很难判断出这些行为实际是不必要的。</p>
<p>但是在Rust里，我们可以直接认为<code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>。Rust静态地知道所有加载和存储操作都毫无用处，也不会真的分配空间。结果就是，这段范型代码直接就是<code>HashSet</code>的一种实现，不需要<code>HashMap</code>对值做什么多余的处理。</p>
<p>安全代码不用关注ZST，但是非安全代码必须考虑零尺寸类型带来的影响。特别注意，计算指针的偏移量是no-op，标准的内存分配器（Rust默认使用jemalloc）在需要分配空间大小为0时可能返回nullptr，很难区分究竟是这种情况还是内存不足。</p>
<h6 id="2-2-3-空类型"><a href="#2-2-3-空类型" class="headerlink" title="2.2.3 空类型"></a>2.2.3 空类型</h6><p>Rust甚至也支持不能被实例化的类型。这种类型只有类型，而没有对应的值。空类型可以通过指定没有变量的枚举来声明它：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Void</span> </span>&#123;&#125; <span class="hljs-comment">// 没有变量 = 空类型</span><br></code></pre></td></tr></table></figure><br>空类型比ZST更加少见。一个主要的应用场景是在<code>类型层面声明不可到达性(unreachability)</code>。比如，假设一个API一般需要返回一个Result，但是在某个特殊场景下它是绝对不会出错的。这种情况在类型层面的处理方法是将返回值设为<code>Result&lt;T, Void&gt;</code>。因为不可能产生一个Void类型的值，所以返回值不可能是一个<code>Err</code>。知道了这一点，API的调用者就可以信心十足地使用<code>unwrap</code>。</p>
<p>原则上来说，Rust可以基于这一点做一些很有意思的分析和优化。比如，<code>Result&lt;T, Void&gt;</code>可以表示成 <code>T</code>，因为实际上不存在返回<code>Err</code>的情况。下面的代码曾经也可以成功编译：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Void</span></span> &#123;&#125;<br><span class="hljs-keyword">let</span> res: <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">u32</span>, Void&gt; = <span class="hljs-literal">Ok</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 不存在Err的情况，所以Ok实际上永远都能匹配成功</span><br><span class="hljs-keyword">let</span> <span class="hljs-literal">Ok</span>(num) = res;<br></code></pre></td></tr></table></figure><br>但是现在这些把戏已经不让玩了。所以Void唯一的用处就是明确地告诉你某些情况永远不会发生。</p>
<p>关于空类型的最后一个坑，创建指向空类型的裸指针实际上是合法的，但是对它解引用是一个未定义行为，因为这么做没有任何意义。也就是说，你可以使用<code>*const Void</code>模拟C语言的<code>void *</code>类型，但是使用<code>*const ()</code>却不会得到任何东西，因为这个函数对于随机解引用是安全的。</p>
<h3 id="2-3-其他repr"><a href="#2-3-其他repr" class="headerlink" title="2.3 其他repr"></a>2.3 其他repr</h3><h6 id="2-3-1-repr-C"><a href="#2-3-1-repr-C" class="headerlink" title="2.3.1 repr(C)"></a>2.3.1 repr(C)</h6><p>这是最重要的一种<code>repr</code>。它的目的很简单，就是和C保持一致。数据的顺序、大小、对齐方式都和你在 C 或 C++ 中见到的一摸一样。所有你需要通过 FFI 交互的类型都应该有<code>repr(C)</code>，因为C是程序设计领域的世界语。而且如果我们要在数据布局方面玩一些花活的话，比如把数据重新解析成另一种类型，<code>repr(C)</code>也是很有必要的。</p>
<p>但是，一定不要忘了Rust的那几个奇行种。<code>repr(C)</code>的存在有双重作用，既为了FFI同时也为了常规的布局控制，所以它可以被应用于那些在FFI中没有意义甚至会产生错误的类型。</p>
<ul>
<li>尽管标准的C语言不支持大小为0的类型，但ZST的尺寸仍然是0。而且它也与C++中的空类型有着明显的不同，C++的空类型还是要占用一个字节的空间的。</li>
<li>DST的指针（胖指针），元组，和带有成员变量的枚举都是C中没有的，因此也不是FFI安全的。</li>
<li>如果<code>T</code>是一个<code>FFI安全的非空指针</code>,那么<code>Option&lt;T&gt;</code>可以保证和<code>T</code>拥有相同的布局和ABI，当然它也会是FFI安全的。这一规则适用于<code>&amp;</code>, <code>&amp;mut</code>和<code>函数指针</code>等所有非空的指针。</li>
<li>在<code>repr(C)</code>中元组结构体与结构体基本相同，唯一的不同是其成员都是未命名的。</li>
<li>对于枚举的处理和<code>repr(u*)</code>是相同的。选择的类型尺寸等于目标平台上C的应用二进制接口(ABI)的默认枚举尺寸。注意C中枚举的数据布局是确定的，所以这确实是一种“最合理的假设”。不过，当目标C代码编译时加了一些特殊的编译器参数时，这一点可能就不正确了。</li>
<li><code>repr(C)</code>和<code>repr(u*)</code>中无成员的枚举不能被赋值为一个没有对应变量的整数，尽管在C\C++中这是一种合法的行为。构建一个没有对应变量的枚举类型实例属于未定义行为。（对于存在准确匹配的值是允许正常编写和编译的）</li>
</ul>
<h6 id="2-3-2-repr-u-repr-i"><a href="#2-3-2-repr-u-repr-i" class="headerlink" title="2.3.2 repr(u), repr(i)"></a>2.3.2 repr(u), repr(i)</h6><p>这两个可以指定无成员枚举的大小。如果枚举变量对应的整数值对于设定的大小越界了，将产生一个编译期错误。你可以手工设置越界的元素为0以避免编译错误，不过要注意Rust是不允许一个枚举中的两个变量拥有相同的值的。</p>
<p>“无成员枚举”的意思是枚举的每一个变量里都不关联数据。不指定<code>repr(u*)</code>或<code>repr(i*)</code>的无成员枚举依然是一个Rust的合法原生类型，它们都没有固定的ABI表示方法。给它们指定<code>repr</code>使其有了固定的类型大小，方便在ABI中使用。</p>
<p>Rust中所有有成员的枚举都没有确定的ABI表示方式（即使关联的数据只是<code>PhantomData</code>或者零尺寸类型的数据）。</p>
<p>为枚举显式指定<code>repr</code>后空指针优化将不再起作用。</p>
<p>这些<code>repr</code>对于结构体无效。</p>
<h6 id="2-3-3-repr-packed"><a href="#2-3-3-repr-packed" class="headerlink" title="2.3.3 repr(packed)"></a>2.3.3 repr(packed)</h6><p><code>repr(packed)</code>强制Rust不填充空数据，各个类型的数据紧密排列。这样有助于提升内存的使用效率，但很可能会导致其他的副作用。</p>
<p>尤其是大部分平台都强烈建议数据对齐。这意味着加载未对齐的数据会很低效（x86)，甚至是错误的(一些ARM芯片)。像直接加载或存储打包的(packed)成员变量这种简单的场景，编译器可能可以用shift和mask等方式隐藏对齐问题。但是如果是使用一个打包的变量的引用，编译器很可能没办法避免未对齐加载问题。</p>
<p><code>repr(packed)</code>不应该随便使用。只有在你有一些极端的需求的情况下才该用它。</p>
<p>这个<code>repr</code>是<code>repr(C)</code>和<code>repr(Rust)</code>的修饰器。</p>
<h2 id="三、所有权"><a href="#三、所有权" class="headerlink" title="三、所有权"></a>三、所有权</h2><p>它让Rust可以彻底告别垃圾回收，同时做到内存安全和高效率。在涉及到所有权系统的细节之前，我们先看一下这种设计的目的。</p>
<p>看一下这个曾纠缠过每一个使用过非GC语言的人的简单错误：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_str</span></span>(data: &amp;<span class="hljs-built_in">u32</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-comment">// 计算字符串</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, data);<br>    <span class="hljs-comment">// 哎呀！我们返回了一个只在函数内部存在的东西的引用</span><br>    <span class="hljs-comment">// 悬垂指针！释放后引用！指针别名！</span><br>    <span class="hljs-comment">// （当然这段代码在Rust中不能编译）</span><br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><br>这正是Rust的所有权系统要解决的问题。Rust知道<code>&amp;s</code>生效的作用域，所以可以避免出现逃逸。</p>
<h3 id="3-1-引用"><a href="#3-1-引用" class="headerlink" title="3.1 引用"></a>3.1 引用</h3><p>有两种引用的类型：</p>
<ul>
<li>共享指针：<code>&amp;</code></li>
<li>可变指针：<code>&amp;mut</code></li>
</ul>
<p>它们遵守以下的规则：</p>
<ul>
<li>引用的生命周期不能超过被引用内容</li>
<li>可变引用不能存在别名(alias)</li>
</ul>
<p>就这些。这就是全部的引用模型。</p>
<p>当然，我们可能需要定义一下别名(alias)是什么意思。<br><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">error[E0425]: cannot find value `aliased` in this scope<br> --&gt; &lt;rust.rs&gt;:2:20<br>  |<br>2 |     println!(&quot;&#123;&#125;&quot;, aliased);<br>  |                    ^^^^^^^ not found in this scope<br><span class="hljs-keyword">error: </span>aborting due to previous error<br></code></pre></td></tr></table></figure><br>很不幸，Rust实际上没有定义别名模型。</p>
<p>在Rust的开发者从语义层面确定别名的意义之前，我们先在下一章讨论一般意义上的别名指什么，还有它为什么很重要。</p>
<h3 id="3-2-别名"><a href="#3-2-别名" class="headerlink" title="3.2 别名"></a>3.2 别名</h3><p>首先，有几点重要声明：</p>
<ul>
<li>以下的讨论将采用最广泛意义上的别名的定义。而Rust的定义可能会更加严格,需要考虑到可变性和生命周期。</li>
<li>我们假设程序都是单线程且不会中断的，同时也不会去考虑存储器映射之类的问题。除非特别指定，否则Rust默认这些事情不存在。</li>
</ul>
<p>基于这些，我们给出定义：<code>当变量和指针表示的内存区域有重叠时，它们互为对方的别名。</code></p>
<h6 id="3-2-1-为什么别名很重要"><a href="#3-2-1-为什么别名很重要" class="headerlink" title="3.2.1 为什么别名很重要"></a>3.2.1 为什么别名很重要</h6><p>看下面这个简单的函数。<br><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">fn compute(<span class="hljs-built_in">input</span>: &amp;u32, <span class="hljs-built_in">output</span>: &amp;mut u32) &#123;<br>    <span class="hljs-keyword">if</span> *<span class="hljs-built_in">input</span> &gt; <span class="hljs-number">10</span> &#123;<br>        *<span class="hljs-built_in">output</span> = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> *<span class="hljs-built_in">input</span> &gt; <span class="hljs-number">5</span> &#123;<br>        *<span class="hljs-built_in">output</span> *= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>我们可能会这样优化它：<br><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">fn compute(<span class="hljs-meta">input</span>: <span class="hljs-variable">&amp;u32</span>, <span class="hljs-meta">output</span>: <span class="hljs-variable">&amp;mut</span> u32) &#123;<br>    let cached_input = <span class="hljs-comment">*input;</span> // 将<span class="hljs-comment">*input放入缓存</span><br><span class="hljs-comment">    if cached_input &gt; 10 &#123;</span><br><span class="hljs-comment">        *output = 2;</span> // <span class="hljs-meta">x</span> &gt; 10 则必然 <span class="hljs-meta">x</span> &gt; 5，所以直接加倍并立即退出<br>    &#125; <span class="hljs-meta">else</span> <span class="hljs-meta">if</span> cached_input &gt; 5 &#123;<br>        <span class="hljs-comment">*output *= 2;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>在Rust中，这种优化是正确的。但对于其他几乎所有的语言，都是有错误的（除非编译器进行全局分析）。这是因为优化方案成立的前提是不存在别名，而绝大多数语言并不会限制这一点。例子中我们需要特别担心的是传递给<code>input</code>和<code>output</code>的参数可能会重合，比如<code>comput(&amp;x, &amp;mut x)</code>。</p>
<p>对于上面的参数，程序流程会是这样：<br><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">                  //  <span class="hljs-built_in">input</span> ==  <span class="hljs-built_in">output</span> == <span class="hljs-number">0xabad1dea</span><br>                  // *<span class="hljs-built_in">input</span> == *<span class="hljs-built_in">output</span> == <span class="hljs-number">20</span><br><span class="hljs-keyword">if</span> *<span class="hljs-built_in">input</span> &gt; <span class="hljs-number">10</span> &#123;  // <span class="hljs-literal">true</span> (*<span class="hljs-built_in">input</span> == <span class="hljs-number">20</span>)<br>    *<span class="hljs-built_in">output</span> = <span class="hljs-number">1</span>;  // 同时覆盖了 *<span class="hljs-built_in">input</span>，以为他们是一样的<br>&#125; <br>*<span class="hljs-built_in">input</span> &gt; <span class="hljs-number">5</span> &#123;      // <span class="hljs-literal">false</span> (*<span class="hljs-built_in">input</span> == <span class="hljs-number">1</span>)<br>    *<span class="hljs-built_in">output</span> *= <span class="hljs-number">2</span>;<br>&#125;<br>                  // *<span class="hljs-built_in">input</span> == *<span class="hljs-built_in">output</span> == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>我们优化过的函数的结果是<code>*output == 2</code>，所以对于这样的输入参数，优化函数是不正确的。</p>
<p>在Rust中我们知道不会出现上面那样的输入参数，因为<code>&amp;mut</code>不允许存在别名。所以我们可以安全的忽略这种可能性而使用优化方案。对于大多数其他语言，这种输入的可能性是存在的，必须特别的考虑到。</p>
<p>这就是别名分析的重要性：它允许编译器做出一些有用的优化。举几个例子：</p>
<ul>
<li>将值放入缓存变量中，因为可以确定没有指针可以访问变量的内存。</li>
<li>省略一些读操作，因为可以确定在上一次读内存之后，内存没有发生变化</li>
<li>省略一些写操作，因为可以确定下一次写内存之前，内存不会被读取</li>
<li>移动或重排读写操作的顺序，因为可以确定它们并不互相依赖</li>
</ul>
<p>这些优化也可以进一步证明更大程度的优化的可行性，比如循环向量化、常量替换和不可达代码消除等。</p>
<p>在前面的例子中，我们根据<code>&amp;mut u32</code>不存在别名的原则证明了<code>*output</code>不可能影响<code>*input</code>。这使得我们缓存了<code>*input</code>，并且省略了一次读操作。</p>
<p>通过缓存读操作的结果，我们知道在<code>&gt;10</code>的分支中的写操作不会影响执行<code>&gt;5</code>分支的判断条件，这样我们在<code>*input &gt; 10</code>的情况下省略了一次读-改-写操作(<code>*output</code>加倍)。</p>
<p>关于别名分析需要记住的一个关键点是，写操作是优化的主要障碍。我们不能随意移动读操作的唯一原因，就是可能存在向相同位置写数据的操作，这种移动会破坏他们之间的顺序关系。</p>
<p>比如，下面这个版本的函数中，我们不需要担心别名问题，因为我们把唯一的一次写<code>*output</code>的操作放到了函数的最后。这让我们可以随意地改变之前的读<code>*input</code>操作的顺序：<br><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">fn compute(<span class="hljs-meta">input</span>: <span class="hljs-variable">&amp;u32</span>, <span class="hljs-meta">output</span>: <span class="hljs-variable">&amp;mut</span> u32) &#123;<br>    let mut temp = <span class="hljs-comment">*output;</span><br>    <span class="hljs-meta">if</span> <span class="hljs-comment">*input &gt; 10 &#123;</span><br><span class="hljs-comment">        temp = 1;</span><br>    &#125;<br>    <span class="hljs-meta">if</span> <span class="hljs-comment">*input &gt; 5 &#123;</span><br><span class="hljs-comment">        temp *= 2;</span><br>    &#125;<br>    <span class="hljs-comment">*output = temp;</span><br>&#125;<br></code></pre></td></tr></table></figure><br>我们仍然需要别名分析来证明<code>temp</code>不是<code>input</code>的别名，但是这时的证明过程要简单得多：一个本地别量不可能是在它的声明之前就存在的变量的别名。这是所有编程语言共有的一个前提，所以这一版本的函数可以按照与其他语言相同的方式去优化它。</p>
<p>这也就是Rust可能采用的“别名”定义与生命周期和可变性有关的原因：在没有写内存操作存在的情况下，我们实际上不需要关注是否存在别名。</p>
<p>当然，一个完整的别名模型也要考虑到诸如函数调用（可能改变我们不可见的内容）、裸指针（不存在限制别名的需求），以及UnsafeCell（允许被<code>&amp;</code>引用的内容可变）。</p>
<h3 id="3-3-生命周期"><a href="#3-3-生命周期" class="headerlink" title="3.3 生命周期"></a>3.3 生命周期</h3><p>Rust在整个生命周期里强制执行生命周期的规则。生命周期说白了就是作用域的名字。每一个引用以及包含引用的数据结构，都要有一个生命周期来指定它保持有效的作用域。</p>
<p>在函数体内，Rust通常不需要你显式地给生命周期起名字。这是因为在本地上下文里，一般没有必要关注生命周期。Rust知道程序的全部信息，从而可以完美地执行各种操作。它可能会引入许多匿名或者临时的作用域让程序顺利执行。</p>
<p>但是如果你要跨出函数的边界，就需要关心生命周期了。生命周期用这样的符号表示：<code>&#39;a</code>,<code>&#39;static</code>。为了更清晰地了解生命周期，我们假设我们可以为生命周期打标签，去掉本章所有例子的语法糖。</p>
<p>最开始，我们的示例代码对作用域和生命周期使用了很激进的语法糖特性——甜得像玉米糖浆一样，因为把所有的东西都显式地写出来实在很讨厌。所有的Rust代码都采用比较激进的理论以省略“显而易见”的东西。</p>
<p>一个特别有意思的语法糖是，每一个<code>let表达式</code>都隐式引入了一个作用域。大多数情况下，这一点并不重要。但是当变量之间互相引用的时候，这就很重要了。举个简单的例子，我们彻底去掉下面这段代码的语法糖：<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let x</span> = 0;<br><span class="hljs-attribute">let y</span> = &amp;x;<br><span class="hljs-attribute">let z</span>= &amp;y;<br></code></pre></td></tr></table></figure><br>借用检查器通常会尽可能减少生命周期的范围，所以去掉语法糖后的代码大概像这样：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 注意：&#x27;a: &#123; 和 &amp;&#x27;b x 不是合法的语法</span><br><span class="hljs-symbol">&#x27;a</span>: &#123;<br>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-symbol">&#x27;b</span>: &#123;<br>        <span class="hljs-comment">// 生命周期是&#x27;b，因为这就足够了</span><br>        <span class="hljs-keyword">let</span> y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span> = &amp;<span class="hljs-symbol">&#x27;b</span> x;<br>        <span class="hljs-symbol">&#x27;c</span>: &#123;<br>            <span class="hljs-comment">// &#x27;c也一样</span><br>            <span class="hljs-keyword">let</span> z: &amp;<span class="hljs-symbol">&#x27;c</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span> = &amp;<span class="hljs-symbol">&#x27;c</span> y;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样的写法……太可怕了。我们先停下来感谢Rust把这一切都简化掉了。</p>
<p>将引用传递到作用域以外会导致生命周期扩大：<br><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> z;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span> = &amp;x;<br><span class="hljs-attr">z</span> = y;<br></code></pre></td></tr></table></figure><br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-symbol">&#x27;a</span>: &#123;<br>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-symbol">&#x27;b</span>: &#123;<br>        <span class="hljs-keyword">let</span> z: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span>;<br>        <span class="hljs-symbol">&#x27;c</span>: &#123;<br>            <span class="hljs-comment">// 必须使用&#x27;b，因为引用被传递到了&#x27;b的作用域</span><br>            <span class="hljs-keyword">let</span> y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span> = &amp;<span class="hljs-symbol">&#x27;b</span> x;<br>            z = y;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h6 id="3-3-1-示例：引用超出被引用内容生命周期"><a href="#3-3-1-示例：引用超出被引用内容生命周期" class="headerlink" title="3.3.1 示例：引用超出被引用内容生命周期"></a>3.3.1 示例：引用超出被引用内容生命周期</h6><p>好了，让我们再看一遍曾经举过的一个例子：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_str</span></span>(data: &amp;<span class="hljs-built_in">u32</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, data);<br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><br>去掉语法糖：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(data: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u32</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-symbol">&#x27;b</span>: &#123;<br>        <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, data);<br>        <span class="hljs-keyword">return</span> &amp;<span class="hljs-symbol">&#x27;a</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>函数<code>as_str</code>的签名里接受了一个带有生命周期的u32类型的引用，并且保证会返回一个生命周期一样长的str类型的引用。从这个签名我们就已经可以看出问题了。它表示我们必须到那个u32引用的作用域，或者比它还要早的作用域里去找一个str。这就有点不合理了。</p>
<p>接下来我们生成一个<code>字符串s</code>，然后返回它的引用。我们的函数要求这个引用的有效期<code>不能小于&#39;a</code>，那是我们给引用指定的生命周期。不幸的是，<code>s是在作用域’b里面定义的</code>。<code>除非’b包含’a</code>这个函数才可能是正确的——而这显然不可能，因为<code>’a必须包含它所调用的函数</code>。这样我们创建了一个生命周期超出被引用内容的引用，这明显违背了之前提到的引用的第一条规则。编译器十分感动然后拒绝了我们。</p>
<p>我们扩展一下这个例子，以便看得更清楚：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(data: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u32</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-symbol">&#x27;b</span>: &#123;<br>        <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, data);<br>        <span class="hljs-keyword">return</span> &amp;<span class="hljs-symbol">&#x27;a</span> s;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-symbol">&#x27;c</span>: &#123;<br>        <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-symbol">&#x27;d</span>: &#123;<br>            <span class="hljs-comment">// 这里引入了一个匿名作用域，因为借用不需要在整个x的作用域内生效</span><br>            <span class="hljs-comment">// as_str的返回值必须引用一个在函数调用前就存在的str</span><br>            <span class="hljs-comment">// 显然事实不是这样的。</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, as_str::&lt;<span class="hljs-symbol">&#x27;d</span>&gt;(&amp;<span class="hljs-symbol">&#x27;d</span> x));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>完蛋了！</p>
<p>当然，这个函数的正确写法应该是这样的。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_string</span></span>(data: &amp;<span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, data)<br>&#125;<br></code></pre></td></tr></table></figure><br>我们必须创建一个值然后连同它的所有权一起返回。除非一个字符串是<code>&amp;&#39;a u32</code>的成员，我们才能返回<code>&amp;&#39;a str</code>，显然事情并不是这样的。</p>
<p>（其实我们也可以返回一个字符串的字面量，它是一个全局的变量，可以认为是处于栈的底部。尽管这样极大限制了函数的使用场合。）</p>
<h6 id="3-3-2-示例：存在可变引用的别名"><a href="#3-3-2-示例：存在可变引用的别名" class="headerlink" title="3.3.2 示例：存在可变引用的别名"></a>3.3.2 示例：存在可变引用的别名</h6><p>在看另一个老的例子：<br><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">let</span> mut <span class="hljs-class"><span class="hljs-keyword">data</span> = vec![1, 2,3];</span><br><span class="hljs-title">let</span> x = &amp;<span class="hljs-class"><span class="hljs-keyword">data</span>[0];</span><br><span class="hljs-class"><span class="hljs-keyword">data</span>.push(4);</span><br><span class="hljs-title">println</span>!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure><br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-symbol">&#x27;a</span>: &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-symbol">&#x27;b</span>: &#123;<br>        <span class="hljs-comment">// 对于这个借用来说，&#x27;b已经足够大了</span><br>        <span class="hljs-comment">// （借用只需要在println!中生效即可）</span><br>        <span class="hljs-keyword">let</span> x: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span> = Index::index::&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;b</span> data, <span class="hljs-number">0</span>);<br>        <span class="hljs-symbol">&#x27;c</span>: &#123;<br>            <span class="hljs-comment">// 引入一个临时作用域，因为&amp;mut不需要存在更长时间</span><br>            <span class="hljs-built_in">Vec</span>::push(&amp;<span class="hljs-symbol">&#x27;c</span> <span class="hljs-keyword">mut</span> data, e);<br>        &#125;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里的问题更加微妙也更有趣。<strong>我们希望Rust出于如下的原因拒绝编译这段代码</strong>：我们有一个有效的指向<code>data</code>的内部数据的引用<code>x</code>，而同时又创建了一个<code>data</code>的可变引用用于执行<code>push</code>。也就是说出现了可变引用的别名，这违背了引用的第二条规则。</p>
<p>但是Rust其实并非因为这个原因判断这段代码有问题。Rust不知道<code>x</code>是<code>data</code>的子内容的引用，它其实完全不知道<code>Vec</code>的内部是什么样子的。它只知道<code>x</code>必须在<code>&#39;b</code>范围内有效，这样才能打印其中的内容。函数Index::index的签名因此要求传递的<code>data</code>的引用也必须在<code>&#39;b</code>的范围内有效。当我们调用<code>push</code>的时候，Rust发现我们要创建一个<code>&amp;&#39;c mut data</code>。它知道<code>&#39;c</code>是包含在<code>&#39;b</code>以内的，因为<code>&amp;&#39;b data</code>还存活着，所以它拒绝了这段程序。</p>
<p>我们看到了生命周期系统要比引用的保护措施更加简单粗暴。大多数情况下这也没什么，它让我们不用没完没了地向编译器解释我们的程序。但是这也意味着许多语义上正确的程序会被编译器拒绝，因为生命周期的规则太死板了。</p>
<h3 id="3-4-生命周期的局限"><a href="#3-4-生命周期的局限" class="headerlink" title="3.4 生命周期的局限"></a>3.4 生命周期的局限</h3><p>考虑下面的代码：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>;<br><span class="hljs-keyword">impl</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mutate_and_share</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">Self</span> &#123;&amp;*<span class="hljs-keyword">self</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">share</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> foo = Foo;<br>    <span class="hljs-keyword">let</span> loan = foo.mutate_and_share();<br>    foo.share();<br>&#125;<br></code></pre></td></tr></table></figure><br>你可能觉得它能成功编译。我们调用<code>mutate_and_share</code>，临时可变地借用<code>foo</code>，但接下来返回一个共享引用。因为调用<code>foo.share()</code>时没有可变的引用了，所以我们认为可以正常调用。</p>
<p>但是当我们尝试编译它：<br><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&lt;anon&gt;:<span class="hljs-number">11</span>:<span class="hljs-number">5</span>: <span class="hljs-number">11</span>:<span class="hljs-number">8</span> error: cannot borrow `foo` as immutable because it is also borrowed as mutable<br>&lt;anon&gt;:<span class="hljs-number">11</span>     foo.<span class="hljs-built_in">share</span>();<br>              ^~~<br>&lt;anon&gt;:<span class="hljs-number">10</span>:<span class="hljs-number">16</span>: <span class="hljs-number">10</span>:<span class="hljs-number">19</span> note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends<br>&lt;anon&gt;:<span class="hljs-number">10</span>     let loan = foo.<span class="hljs-built_in">mutate_and_share</span>();<br>                         ^~~<br>&lt;anon&gt;:<span class="hljs-number">12</span>:<span class="hljs-number">2</span>: <span class="hljs-number">12</span>:<span class="hljs-number">2</span> note: previous borrow ends here<br>&lt;anon&gt;:<span class="hljs-number">8</span> fn <span class="hljs-built_in">main</span>() &#123;<br>&lt;anon&gt;:<span class="hljs-number">9</span>     let mut foo = Foo;<br>&lt;anon&gt;:<span class="hljs-number">10</span>     let loan = foo.<span class="hljs-built_in">mutate_and_share</span>();<br>&lt;anon&gt;:<span class="hljs-number">11</span>     foo.<span class="hljs-built_in">share</span>();<br>&lt;anon&gt;:<span class="hljs-number">12</span> &#125;<br></code></pre></td></tr></table></figure><br>发生了什么呢？嗯……我们遇到了和上一章的示例2相同的错误。我们去掉语法糖，会得到这样的代码:<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>;<br><span class="hljs-keyword">impl</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mutate_and_share</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">Self</span> &#123; &amp;<span class="hljs-symbol">&#x27;a</span> *<span class="hljs-keyword">self</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">share</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-symbol">&#x27;b</span>: &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> foo: Foo = Foo;<br>        <span class="hljs-symbol">&#x27;c</span>: &#123;<br>            <span class="hljs-keyword">let</span> loan: &amp;<span class="hljs-symbol">&#x27;c</span> Foo = Foo::mutate_and_share::&lt;<span class="hljs-symbol">&#x27;c</span>&gt;(&amp;<span class="hljs-symbol">&#x27;c</span> <span class="hljs-keyword">mut</span> foo);<br>            <span class="hljs-symbol">&#x27;d</span>: &#123;<br>                Foo::share::&lt;<span class="hljs-symbol">&#x27;d</span>&gt;(&amp;<span class="hljs-symbol">&#x27;d</span> foo);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>生命周期系统强行把<code>&amp;mut foo</code>的生命周期扩展到<code>’c</code>，以和<code>loan</code>的生命周期以及<code>mutate_and_share</code>的签名匹配。接下来我们调用<code>share</code>，Rust认为我们在给<code>&amp;&#39;c mut foo</code>创建别名，于是拒绝了我们。</p>
<p>这段程序显然完全符合引用的语义，但是我们的生命周期系统过于粗糙，无法对它进行正确的分析。</p>
<p><strong><em>注：这里依旧没有看明白问题的所在。</em></strong></p>
<h3 id="3-5-省略生命周期"><a href="#3-5-省略生命周期" class="headerlink" title="3.5 省略生命周期"></a>3.5 省略生命周期</h3><p>为了让语言的表达方式更人性化，Rust允许函数的签名中省略生命周期。</p>
<p>“生命周期位置”指的是你在类型中可以写生命周期的地方。<br><figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet">&amp;<span class="hljs-comment">&#x27;a T</span><br>&amp;<span class="hljs-comment">&#x27;a mut T</span><br>T&lt;<span class="hljs-comment">&#x27;a&gt;</span><br></code></pre></td></tr></table></figure><br>生命周期的位置可以在“输入”也可以在“输出”：</p>
<ul>
<li>对于<code>fn</code>定义的函数，“输入”指的是函数签名中的参数的类型，而“输出”是结果的类型。所以<code>fn foo(s: &amp;str) -&gt; (&amp;str, &amp;str)</code>省略了一个在输入位置处的生命周期和两个结果位置的生命周期。注意，<code>fn</code>方法定义中的输入位置不包括impl头处的生命周期（自然地，对于trait的默认方法，也不包括trait的头的位置）。</li>
<li>在未来，应该也可能会省略impl头位置处的生命周期。</li>
</ul>
<p>省略的规则如下：</p>
<ul>
<li>每一个在输入位置省略的生命周期都对应一个唯一的生命周期参数。</li>
<li>如果只有一个输入的生命周期位置（无论省略还是没省略），那个生命周期会赋给所有省略了的输出生命周期。</li>
<li>如果有多个输入生命周期位置，而其中一个是&amp;self或者&amp;mut self，那么self的生命周期会赋给所有省略了的输出生命周期。</li>
<li>除了上述两种情况，其他省略生命周期的情况都是错误的。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print</span></span>(s: &amp;<span class="hljs-built_in">str</span>);                                      <span class="hljs-comment">// 省略的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>);                               <span class="hljs-comment">// 完整的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">debug</span></span>(lvl: <span class="hljs-built_in">usize</span>, s: &amp;<span class="hljs-built_in">str</span>);                          <span class="hljs-comment">// 省略的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">debug</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(lvl: <span class="hljs-built_in">usize</span>, s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>);                   <span class="hljs-comment">// 完整的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">substr</span></span>(s: &amp;<span class="hljs-built_in">str</span>, until: <span class="hljs-built_in">usize</span>) -&gt; &amp;<span class="hljs-built_in">str</span>;               <span class="hljs-comment">// 省略的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">substr</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, until: <span class="hljs-built_in">usize</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;     <span class="hljs-comment">// 完整的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>() -&gt; &amp;<span class="hljs-built_in">str</span>;                                   <span class="hljs-comment">// 错误</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">frob</span></span>(s: &amp;<span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span>;                      <span class="hljs-comment">// 错误</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> T;                        <span class="hljs-comment">// 省略的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_mut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T;              <span class="hljs-comment">// 完整的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">args</span></span>&lt;T: ToCStr&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, args: &amp;[T]) -&gt; &amp;<span class="hljs-keyword">mut</span> Command                  <span class="hljs-comment">// 省略的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">args</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, T: ToCStr&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, args: &amp;<span class="hljs-symbol">&#x27;b</span> [T]) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Command <span class="hljs-comment">// 完整的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt; BufWriter;                    <span class="hljs-comment">// 省略的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(buf: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt; BufWriter&lt;<span class="hljs-symbol">&#x27;a</span>&gt;          <span class="hljs-comment">// 完整的</span><br></code></pre></td></tr></table></figure>
<h3 id="3-6-无界生命周期"><a href="#3-6-无界生命周期" class="headerlink" title="3.6 无界生命周期"></a>3.6 无界生命周期</h3><p>非安全代码经常会凭空变出来一些引用和生命周期。这些生命周期都是无界的。最常见的场景是解引用一个裸指针，然后产生一个拥有无界生命周期的引用。这些生命周期根据上下文的要求，想要多大就可以有多大。这其实比简单的设为<code>&#39;static</code>更加强大。比如<code>&amp;&#39;static &amp;&#39;a T</code>是无法通过类型检查的，但是无界生命周期可以完美适配<code>&amp;&#39;a &amp;&#39;a T</code>。不过大多数情况下，这种的无界生命周期会被视为<code>&#39;static</code>。</p>
<p>几乎没有哪个引用是<code>&#39;static</code>，所以这样很可能是错误的。<code>transmute</code>和<code>transmute_copy</code>是两种很主要的例外情况。我们应该尽量早的确定无界生命周期的边界，特别是在涉及到函数调用的情况下。</p>
<p>对于一个函数，任何不是从输入那里来的输出生命周期都是无界的。比如：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;<br></code></pre></td></tr></table></figure><br>这个函数会产生一个拥有无界生命周期的<code>&amp;str</code>。最简单的避免无界生命周期的方式就是在函数声明中运用生命周期省略。如果一个输出生命周期被省略了，它必须受限于一个输入生命周期。当然它有可能被赋予了一个错误的生命周期，但是这样通常只会产生一个编译错误，总比允许它破坏内存安全要好。</p>
<p>在函数的内部，限制生命周期范围是极容易出错的。最安全且简单的限制生命周期的方法是将它作为一个有有界生命周期的函数的返回值。但是，如果这个不被接受，引用可以被设置成一个特别的生命周期。不幸的是，我们不可能为函数所有的生命周期命名。</p>
<p><strong><em>注：这里依旧没有看明白问题的所在。</em></strong></p>
<h3 id="3-7-高阶trait边界-HRTB"><a href="#3-7-高阶trait边界-HRTB" class="headerlink" title="3.7 高阶trait边界(HRTB)"></a>3.7 高阶trait边界(HRTB)</h3><p>Rust的<code>Fn</code> trait是个神奇的存在。比如，我们可以写出这样的代码：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span></span>&lt;F&gt; &#123;<br>    data: (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>),<br>    func: F<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;F&gt; Closure&lt;F&gt;<br>    <span class="hljs-keyword">where</span> F: <span class="hljs-built_in">Fn</span>(&amp;(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-built_in">u8</span>,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">u8</span> &#123;<br>        (<span class="hljs-keyword">self</span>.func)(&amp;<span class="hljs-keyword">self</span>.data)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_it</span></span>(data: &amp;(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-built_in">u8</span> &#123; &amp;data.<span class="hljs-number">0</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> clo = Closure&#123; data: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), func: do_it &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, clo.call());<br>&#125;<br></code></pre></td></tr></table></figure><br>如果我们像在生命周期那一章里一样地去掉这段代码的语法糖，我们会发现一些问题：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span></span>&lt;F&gt; &#123;<br>    data: (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>),<br>    func: F,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;F&gt; Closure&lt;F&gt;<br>    <span class="hljs-comment">// where F: Fn(&amp;&#x27;??? (u8, u16)) -&gt; &amp;&#x27;??? u8,</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span> &#123;<br>        (<span class="hljs-keyword">self</span>.func)(&amp;<span class="hljs-keyword">self</span>.data)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_it</span></span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(data: &amp;<span class="hljs-symbol">&#x27;b</span> (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">u8</span> &#123; &amp;<span class="hljs-symbol">&#x27;b</span> data.<span class="hljs-number">0</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-symbol">&#x27;x</span>: &#123;<br>        <span class="hljs-keyword">let</span> clo = Closure &#123; data: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), func: do_it &#125;;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, clo.call());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>我们究竟应该怎么表示<code>F</code>的trait边界里的生命周期呢？这里需要一个生命周期，但是在我们进入<code>call</code>函数之前我们都不知道生命周期的名字！而且，那里的生命周期也是不固定的，<code>&amp;self</code>在那一时间点上是什么生命周期，<code>call</code>就也要是什么生命周期。</p>
<p>这里我们需要借助高阶trait边界（HRTB, Higher-Rank Trait Bounds）的神奇力量了。我们去掉语法糖之后的代码应该是这样的：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">where</span> <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; F: <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-symbol">&#x27;a</span> (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>,<br></code></pre></td></tr></table></figure><br>（其中<code>Fn(a, b, c） -&gt; d</code>本身就是不确定的<code>Fn</code> trait的语法糖）</p>
<p><code>for&lt;&#39;a&gt;</code>可以读作“对于<code>&#39;a</code>的所有可能选择”，基本上表示一个无限的列表，包含所有F需要满足的trait边界。不过别紧张，除了<code>Fn</code> trait之外我们很少会遇到需要HRTB的场景，而且即使遇到了我们还有一个神奇的语法糖相助。</p>
<h3 id="3-8-子类型和变性"><a href="#3-8-子类型和变性" class="headerlink" title="3.8 子类型和变性"></a>3.8 子类型和变性</h3><h6 id="3-8-1-子类型"><a href="#3-8-1-子类型" class="headerlink" title="3.8.1 子类型"></a>3.8.1 子类型</h6><p>子类型是类型之间的一种关系，可以让静态类型语言更加地灵活自由。</p>
<p>理解这一概念最简单的方法就是参考一些支持<strong>继承特性的语言</strong>。比如说一个Animal类型有一个<code>eat()</code>方法，Cat类型继承了Animal并且添加了一个<code>meow()</code>方法。如果没有子类型机制，那么要写一个<code>feed(Animal)</code>函数，我们就不能给它传递<code>Cat</code>类型的参数，因为<code>Cat</code>并不是一个<code>Animal</code>。但是把<code>Cat</code>传递给需要<code>Animal</code>类型的地方似乎非常的合理。毕竟，<code>Cat</code>就是一个<code>Animal</code>外加一些自己的特性。这些特性完全可以被忽略，不应该妨碍我们在这里使用它！</p>
<p>这就是子类型机制允许我们做的事情。因为<code>Cat</code>是一个<code>Animal</code>外加一些特性，我们就可以说<code>Cat</code>是<code>Animal</code>的子类型。任何需要某种类型的地方，我们都可以传递一个那种类型的子类型。很好!虽然实际情况会稍微复杂和微妙一点，但这种基本的理解足够你应对99%的应用场景了。我们在本章的后面会说明剩下的1%是什么。</p>
<p>尽管Rust没有结构体继承的概念，它却有子类型机制。在Rust中，子类型是针对生命周期存在的。生命周期是代码的作用域，所以我们可以根据它们相互包含的关系判断他们的继承关系。</p>
<p>生命周期的子类型指的是：如果<code>&#39;big: &#39;small</code>（big包含small，或者big比small长寿），那么<code>&#39;big</code>就是<code>&#39;small</code>的子类型。这一点很容易弄错，因为它和我们的直觉是相反的：<strong><em>大的范围是小的范围的子类型。（生命周期的范围与类型泛型相反！）</em></strong>不过如果你对比一下我们举的Animal的例子就清楚了：Cat是一个Animal外加一些独有的东西，而<code>&#39;big</code>是<code>&#39;small</code>外加一些独有的东西。</p>
<p>考虑下图：<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">&#x27;static  &#x27;big    <br>   |<br><span class="hljs-string">   </span>|<span class="hljs-string">       </span>|<span class="hljs-string">    &#x27;small_1</span><br><span class="hljs-string">   </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       </span>|<br>   |<span class="hljs-string">       </span>|<span class="hljs-string">       </span><br><span class="hljs-string">   </span>|<span class="hljs-string">       </span>|<span class="hljs-string">    &#x27;small_2</span><br><span class="hljs-string">   </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       </span>|<br>   |<span class="hljs-string">       </span>|<span class="hljs-string">       </span>|<br>   |<span class="hljs-string">       </span>|<span class="hljs-string">       </span>|<br>   |<span class="hljs-string">       </span>|<br>   |<br></code></pre></td></tr></table></figure><br>这张图的子类型关系应当是 <code>&#39;static: &#39;big: &#39;small_1</code>，<code>&#39;static: &#39;big: &#39;small_2</code>。而 <code>&#39;static</code> 则是所有lifetime的子类型。</p>
<p>换一个角度想，如果需要一个在<code>&#39;small</code>内有效的引用，实际指的是至少在<code>&#39;small</code>中有效的引用。我们并不在乎生命周期是不是完全的一致。从这点上来说，永久生命周期<code>&#39;static</code>是所有生命周期的子类型。</p>
<p>高阶生命周期也是所有具体生命周期的子类型。这是因为一个随意变化的生命周期比特定的一个生命周期更通用。</p>
<p>(将生命周期类型化是一个过于自由的设计，以至于一些人并不赞同它。但是，把生命周期看做一种类型，这确实简化了我们的分析。)</p>
<p>当然你不能写一个接收<code>&#39;a</code>类型的值的函数！生命周期只是别的类型的一部分，所以我们需要一些办法来处理它。这里，就要涉及到变性。</p>
<h6 id="3-8-2-变性"><a href="#3-8-2-变性" class="headerlink" title="3.8.2 变性"></a>3.8.2 变性</h6><p>变性显得有一点复杂。</p>
<blockquote>
<p>协变和逆变都是术语，<br>前者指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型，<br>后者指能够使用比原始指定的派生类型的派生程度更小（不太具体的）的类型 。<br>泛型类型参数支持协变和逆变，可在分配和使用泛型类型方面提供更大的灵活性。</p>
</blockquote>
<p><strong><em>变性是类型构造函数与它的参数相关的一个属性。</em></strong>Rust中的类型构造函数是一个带有无界参数的通用类型。比如，<code>Vec</code>是一个构造函数，它的参数是<code>T</code>，返回值是<code>vec&lt;T&gt;</code>。<code>&amp;</code>和<code>&amp;mut</code>也是构造函数，它们有两个类型：<code>一个生命周期</code>，和<code>一个引用指向的类型</code>。</p>
<p>构造函数F的变性表示了它的输入的子类型如何影响它输出的子类型。Rust中有三种变性：</p>
<ul>
<li>如果当<code>T</code>是<code>U</code>的子类型时，<code>F&lt;T&gt;</code>也是<code>F&lt;U&gt;</code>的子类型，则<code>F</code>对于<code>T</code>是协变的</li>
<li>如果当<code>T</code>是<code>U</code>的子类型时，<code>F&lt;U&gt;</code>是<code>F&lt;T&gt;</code>的子类型，则<code>F</code>对于<code>T</code>是逆变的</li>
<li>其他情况（即子类型之间没有关系），则<code>F</code>对于<code>T</code>是不变的</li>
</ul>
<p>注意，在Rust中协变性远比逆变性要普遍和重要。逆变性的存在几乎可以忽略。</p>
<p>一些重要的变性（下文会详细描述）：</p>
<ul>
<li><code>&amp;&#39;a T</code>对于<code>&#39;a</code>和<code>T</code>是协变的</li>
<li><code>&amp;&#39;a mut T</code>对于<code>&#39;a</code>是协变的，对于<code>T</code>是不变的</li>
<li><code>fn(T) -&gt; U</code>对于<code>T</code>是逆变的，对于<code>U</code>是协变的</li>
<li><code>Box</code>，<code>Vec</code>以及所有的集合类对于它们保存的类型都是协变的</li>
<li><code>UnsafeCell&lt;T&gt;</code>, <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>Mutex&lt;T&gt;</code>和其他的内部可变类型对于<code>T</code>都是不变的</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>在 ‘a 上的型变</th>
<th>在 T 上的型变</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&#39;a T</code></td>
<td>协变的</td>
<td>协变的</td>
</tr>
<tr>
<td><code>&amp;&#39;a mut T</code></td>
<td>协变的</td>
<td>不变的</td>
</tr>
<tr>
<td><code>*const T</code></td>
<td></td>
<td>协变的</td>
</tr>
<tr>
<td><code>*mut T</code></td>
<td></td>
<td>不变的</td>
</tr>
<tr>
<td><code>[T] 和 [T; n]</code></td>
<td></td>
<td>协变的</td>
</tr>
<tr>
<td><code>fn() -&gt; T</code></td>
<td></td>
<td>协变的</td>
</tr>
<tr>
<td><code>fn(T) -&gt; ()</code></td>
<td></td>
<td>逆变的</td>
</tr>
<tr>
<td><code>fn(T) -&gt; T</code></td>
<td></td>
<td>不变的</td>
</tr>
<tr>
<td><code>std::cell::UnsafeCell&lt;T&gt;</code></td>
<td></td>
<td>不变的</td>
</tr>
<tr>
<td><code>std::marker::PhantomData&lt;T&gt;</code></td>
<td></td>
<td>协变的</td>
</tr>
<tr>
<td><code>dyn Trait&lt;T&gt; + &#39;a</code></td>
<td>协变的</td>
<td>不变的</td>
</tr>
</tbody>
</table>
</div>
<p>我们举几个例子说明这些变性为什么是正确且必要的。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() &#123;<br>    <span class="hljs-keyword">let</span> s: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hi&quot;</span>;<br>    <span class="hljs-keyword">let</span> t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> = s;<br>&#125;<br></code></pre></td></tr></table></figure><br>因为 <code>&#39;static</code> 比生存期参数 <code>&#39;a</code> 的寿命长，所以 <code>&amp;&#39;static str</code> 是 <code>&amp;&#39;a str</code> 的子类型。</p>
<p>在介绍子类型的时候，其实已经包括了为什么<code>&amp;&#39;a T</code>对<code>&#39;a</code>是协变的。当需要一个较短的生命周期时，我们需要能够传递一个更长的生命周期。</p>
<p>类似的理由也可以解释为什么它对于<code>T</code>是协变的：给一个要求<code>&amp;&amp;&#39;a str</code>的地方传递<code>&amp;&amp;&#39;static T</code>是很合理的。这种间接的引用并不影响对生命周期长度的要求。</p>
<p>但是同样的逻辑并不适用于<code>&amp;mut</code>。下面的代码演示了为什么<code>&amp;mut</code>对于<code>T</code>是不变的：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overwrite</span></span>&lt;T: <span class="hljs-built_in">Copy</span>&gt;(intput: &amp;<span class="hljs-keyword">mut</span> T, new: &amp;<span class="hljs-keyword">mut</span> T) &#123;<br>    *input = *new;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> forever_str: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;world&quot;</span>);<br>        overwrite(&amp;<span class="hljs-keyword">mut</span> forever_str, &amp;<span class="hljs-keyword">mut</span> &amp;*string);<br>    &#125;<br>    <span class="hljs-comment">// 不好！在打印被释放的内存数据</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, forever_str);<br>&#125;<br></code></pre></td></tr></table></figure><br><code>overwrite</code>的签名显然是合法的，它接受两个相同类型的可变引用，然后用一个覆盖另外一个。</p>
<p>但是，如果<code>&amp;mut T</code>对于<code>T</code>是协变的，<code>&amp;mut &amp;&#39;static str</code>将会是<code>&amp;mut &amp;&#39;a str</code>的子类型，这是因为<code>&amp;&#39;static str</code>是<code>&amp;&#39;a str</code>的子类型。这时<code>forever_str</code>的生命周期就缩减到和<code>string</code>一样短，<code>overwrite</code>也可以被正常调用。接下来<code>string</code>被释放，等到打印的时候<code>forever_str</code>实际指向了一块释放后的内存空间！所以<code>&amp;mut</code>必须是不变的。</p>
<p>这是变性的一个基本原则：<code>如果生命周期较短的内容有可能存储在生命周期更长的变量里，这时必须要求变性是不变的。</code></p>
<p>更一般的解释是，子类型和变性可用的前提是我们可以安全地忘掉类型的细节。但对于可变引用，总有一些地方（被引用的原始值）记着类型的信息并且假设它们不会改变。如果我们改变了这些信息，原始值的位置就可能出现异常。</p>
<p>但是，<code>&amp;&#39;a mut T</code>对于<code>&#39;a</code>却是协变的。<code>&#39;a</code>和<code>T</code>最关键的区别是<code>&#39;a</code>是引用自身的属性，而<code>T</code>则是引用借用的。如果改变了<code>T</code>的类型，<code>T</code>的原始值依然记着它的类型。可如果改变的是生命周期的类型，只有引用自己知道这一变化，因此这是安全的。换句话说，<code>&amp;&#39;a mut T</code>拥有<code>&#39;a</code>，但是仅仅借用<code>T</code>。</p>
<p><code>Box</code>和<code>Vex</code>的情况就很有趣了，他们是协变的，可是你可以在里面存储值。Rust的类型系统允许它们比其他的类型更聪明。为了理解为什么拥有数据所有权的容器类型对于它们的内容是协变的，我们需要考虑两种可能发生子类型变化的方式：通过值和通过引用。</p>
<p>如果子类型通过值发生变化，原有的记录类型信息的位置会被移除，也意味着容器再也不能使用原有的值了。所以我们也就不用担心有其他的地方记录着类型的信息。换言之，通过值使用子类型的特性会彻底销毁原有类型的信息。例如，这段代码可以编译并正常运行：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_box</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(<span class="hljs-built_in">str</span>: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Box</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>&gt; &#123;<br>    <span class="hljs-comment">// 字符串字面量是&amp;&#x27;static str类型，但是我们完全可以“忘掉”这一点，</span><br>    <span class="hljs-comment">// 就让调用者认为这个字符串的生命周期只有这么短</span><br>    <span class="hljs-built_in">Box</span>::new(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br>如果子类型通过引用发生变化，那么容器类会以<code>&amp;mut Vec&lt;T&gt;</code>类型传递。可是<code>&amp;mut</code>对于它引用的值是不变的，所以<code>&amp;mut Vec&lt;T&gt;</code>对于T实际也是不变的。那么<code>Vec&lt;T&gt;</code>对于<code>T</code>协变这件事在引用的情况下就完全不重要了。</p>
<p>不过，<code>Box</code>和<code>Vec</code>的协变性在不可变引用的情况下依然有用。所以你可以将<code>&amp;Vec&lt;&amp;&#39;static str&gt;</code>传递给需要<code>&amp;Vec&lt;&amp;&#39;a str&gt;</code>的地方。</p>
<p><code>cell</code>类型的不变性可以这样理解：对于<code>cell</code>来说<code>&amp;</code>就是<code>&amp;mut</code>，因为你可以通过<code>&amp;</code>储存值。所以<code>cell</code>必须是不变的，以避免生命周期缩短的问题。</p>
<p><code>fn</code>是最怪异的，因为它具有混合变性，而且它也是唯一用到了逆变性的地方。下面的函数签名展示了为什么<code>fn(T) -&gt; U</code>对于<code>T</code>是逆变的：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// &#x27;a来自父作用域</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">usize</span>;<br></code></pre></td></tr></table></figure><br>这个签名表明函数可以接受任何生命周期不小于<code>&#39;a</code>的<code>&amp;str</code>。如果函数对于<code>&amp;&#39;a str</code>是协变的，那么这个函数<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">usize</span>;<br></code></pre></td></tr></table></figure><br>就是它的子类型并且可以使用。但是，这个函数的要求其实更严格，它只能接受<code>&amp;&#39;static str</code>，不能接受其他类型。给它传递一个<code>&amp;&#39;a str</code>是错误的，因为我们不能假设传递给它的值会永远存在。所以，函数对于它的参数类型肯定不能使协变的。</p>
<p>如果我们反过来应用逆变性，就万事大吉了！需要一个函数来处理永远存在的字符串，而我们提供了一个处理有限生命周期字符串的函数，这也是完全合理的。所以，<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">usize</span>;<br></code></pre></td></tr></table></figure><br>可以被传递给需要<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">usize</span>;<br></code></pre></td></tr></table></figure><br>的地方。</p>
<p>那<code>fn(T) -&gt; U</code>对于<code>U</code>怎么又是协变的了呢？看看下面这个函数签名：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// &#x27;a来自父作用域</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(<span class="hljs-built_in">usize</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;<br></code></pre></td></tr></table></figure><br>这个函数声明它将返回一个生命周期长于<code>&#39;a</code>的引用。那么下面这个函数<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foot</span></span>(<span class="hljs-built_in">usize</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>;<br></code></pre></td></tr></table></figure><br>用在这里是完全可以的，因为它的的确确返回了一个生命周期长于<code>&#39;a</code>的引用。所以函数对于它的返回值是协变的。</p>
<p><code>*const</code>和<code>&amp;</code>有着完全一样的语义，所以变性也是一样的。<code>*mut</code>正相反，它可以解引用出一个<code>&amp;mut</code>，所以和<code>cell</code>一样，它也是不变的。</p>
<p>以上规则都是针对标准库提供的类型，那么自己定义的类型又如何确定变性呢？简单点说，结构体会继承它的成员的变性。如果结构体<code>Foo</code>有一个成员<code>a</code>，它使用了结构体的泛型参数<code>A</code>，那么<code>Foo</code>对于<code>A</code>的变性就等于<code>a</code>对于<code>A</code>的变性。可如果<code>A</code>被用在了多个成员中：</p>
<ul>
<li>如果所有用到A的成员都是协变的，那么Foo对于A就是协变的</li>
<li>如果所有用到A的成员都是逆变的，那么Foo对于A也是逆变的</li>
<li>其他的情况，Foo对于A是不变的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::Cell;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, A: <span class="hljs-symbol">&#x27;a</span>, B: <span class="hljs-symbol">&#x27;b</span>, C, D, E, F, G, H, In, Out, Mixed&gt; &#123;<br>    a: &amp;<span class="hljs-symbol">&#x27;a</span> A,     <span class="hljs-comment">// 对于&#x27;a和A协变</span><br>    b: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> B, <span class="hljs-comment">// 对于&#x27;b协变，对于B不变</span><br>    c: *<span class="hljs-keyword">const</span> C,  <span class="hljs-comment">// 对于C协变</span><br>    d: *<span class="hljs-keyword">mut</span> D,    <span class="hljs-comment">// 对于D不变</span><br>    e: E,         <span class="hljs-comment">// 对于E协变</span><br>    f: <span class="hljs-built_in">Vec</span>&lt;F&gt;,    <span class="hljs-comment">// 对于F协变</span><br>    g: Cell&lt;G&gt;,   <span class="hljs-comment">// 对于G不变</span><br>    h1: H,        <span class="hljs-comment">// 对于H本该是可变的，但是……</span><br>    h2: Cell&lt;H&gt;,  <span class="hljs-comment">// 其实对H是不变的，发生变性冲突的都是不变的</span><br>    i: <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(In) -&gt; Out,       <span class="hljs-comment">// 对于In逆变，对于Out协变</span><br>    k1: <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(Mixed) -&gt; <span class="hljs-built_in">usize</span>, <span class="hljs-comment">// 对于Mix本该是逆变的，但是……</span><br>    k2: Mixed,              <span class="hljs-comment">// 其实对Mixed是不变的，发生变性冲突的都是不变的</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-8-子类型和变性-more"><a href="#3-8-子类型和变性-more" class="headerlink" title="3.8 子类型和变性-more"></a>3.8 子类型和变性-more</h3><p>看看下面的三个trait<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Animal</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snuggle</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eat</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Cat</span></span>: Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">meow</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Dog</span></span>: Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bark</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>但是无法实现<br><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">fn love(pet: Animal) &#123;<br>    pet<span class="hljs-selector-class">.snuggle</span>();<br>&#125;<br><br>let mr_snuggles: Cat = ...;<br>love(mr_snuggles);         <span class="hljs-comment">// ERROR: expected Animal, found Cat</span><br></code></pre></td></tr></table></figure><br>上面简单的例子。</p>
<h6 id="3-8-1-子类型解决的问题"><a href="#3-8-1-子类型解决的问题" class="headerlink" title="3.8.1 子类型解决的问题"></a>3.8.1 子类型解决的问题</h6><p>这就是子类型希望解决的问题。因为 Cat 是 Animal+其他，所以我们描述：Cat 是 Animal 的子类型（subtype）——因为猫是所有动物中的一种；同样地，我们描述：Animal 是 Cat 的超类型（supertype）。</p>
<p>有了子类型，我没就可以给上述的严格静态类型系统增加一条简单的规则了：当某处希望接收类型 T 时，除 T 外还接收类型 T 的子类型。</p>
<p>或者更具体一点：希望接收 Animal 的地方也可以接收 Cat 或 Dog。<br>但是简单的应用则会发生无法确认的问题：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">fn evil<span class="hljs-constructor">_feeder(<span class="hljs-params">pet</span>: &amp;<span class="hljs-params">mut</span> Animal)</span> &#123;<br>    <span class="hljs-keyword">let</span> spike: Dog = ...;<br><br>    <span class="hljs-comment">// `pet` 是 Animal, Dog 是 Animal 的子类型</span><br>    <span class="hljs-comment">// 所以没问题……吧？</span><br>    *pet = spike;<br>&#125;<br><br>fn main<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">let</span> mut mr_snuggles: Cat = ...;<br>    evil<span class="hljs-constructor">_feeder(&amp;<span class="hljs-params">mut</span> <span class="hljs-params">mr_snuggles</span>)</span>;  <span class="hljs-comment">// 把 mr_snuggles 替换成 Dog</span><br>    mr_snuggles.meow<span class="hljs-literal">()</span>;             <span class="hljs-comment">// OH NO, MEOWING DOG!</span><br>&#125;<br></code></pre></td></tr></table></figure><br>变型（variance），一套管理子类型组成方式的规则。最重要的是，变型定义了禁止套用子类型的情形。</p>
<h6 id="3-8-2-生命周期在这里的作用"><a href="#3-8-2-生命周期在这里的作用" class="headerlink" title="3.8.2 生命周期在这里的作用"></a>3.8.2 生命周期在这里的作用</h6><p>这里的描述和3.8类似，<code>&#39;bit: &#39;small</code>描述了生命周期的范围关系，<code>&#39;bit</code>继承了<code>&#39;small</code>。这看上去有点反直觉：大区域是小区域的子类型。但仔细想想 Animal 的例子就能明白了：Cat 是 Animal+其他，而 big 则是 small+其他。</p>
<h6 id="3-8-3-变型"><a href="#3-8-3-变型" class="headerlink" title="3.8.3 变型"></a>3.8.3 变型</h6><p>类型构造器 F 的变型指输入子类型如何影响输出子类型。Rust 中有三种变型。给定两个类型 Sub 和 Super，其中 Sub 是 Super 的子类型，则有：</p>
<ul>
<li>如果 <code>F&lt;Sub&gt;</code> 是 <code>F&lt;Super&gt;</code> 的子类型，则 F 是协变（covariant）的</li>
<li>如果 <code>F&lt;Super&gt;</code> 是 <code>F&lt;Sub&gt;</code> 的子类型，则 F 是逆变（contravariant）的</li>
<li>否则，F 是不变（invariant）的</li>
</ul>
<p>接下来来看一些例子。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">fn evil<span class="hljs-constructor">_feeder(<span class="hljs-params">pet</span>: &amp;<span class="hljs-params">mut</span> Animal)</span> &#123;<br>    <span class="hljs-keyword">let</span> spike: Dog = ...;<br><br>    <span class="hljs-comment">// `pet` 是 Animal, Dog 是 Animal 的子类型</span><br>    <span class="hljs-comment">// 所以没问题……吧？</span><br>    *pet = spike;<br>&#125;<br><br>fn main<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">let</span> mut mr_snuggles: Cat = ...;<br>    evil<span class="hljs-constructor">_feeder(&amp;<span class="hljs-params">mut</span> <span class="hljs-params">mr_snuggles</span>)</span>;  <span class="hljs-comment">// 把 mr_snuggles 替换成 Dog</span><br>    mr_snuggles.meow<span class="hljs-literal">()</span>;             <span class="hljs-comment">// OH NO, MEOWING DOG!</span><br>&#125;<br></code></pre></td></tr></table></figure><br>查阅上面的变型表，发现 <code>&amp;mut T</code> 对 <code>T</code> 是<strong>不变的</strong>。也就是说，问题已经解决了：尽管 <code>Cat</code> 是 <code>Animal</code> 的子类型，但 <code>&amp;mut Cat</code> 不再是 <code>&amp;mut Animal</code> 的子类型了。由此，静态类型检查器就能够阻止我们将 <code>Cat</code> 类型传给 <code>evil_feeder</code>。</p>
<p>子类型化的合理性是基于部分细节可以忽略的前提的。<code>&amp;mut T</code> 对于 <code>T</code> 协变的问题在于在不知道细节的前提下，我们被赋予了修改原始值的权力</p>
<h6 id="3-8-4-生命周期的协变"><a href="#3-8-4-生命周期的协变" class="headerlink" title="3.8.4 生命周期的协变"></a>3.8.4 生命周期的协变</h6><p>为什么引用的生命周期是协变的呢？<br>生命周期引用化是 Rust 类型的根本所在。拥有类型系统的根本目的在于我们能够将长生命周期的参数传递给接收短生命周期的函数。</p>
<p>生命周期只是引用的一部分。引用者的类型是共享的，这就是为什么在一个地方调整这个类型会出问题的原因。但如果你在把生命周期移交给他人时削减生命周期（从 <code>&#39;long</code> 到 <code>&#39;short</code>），生命周期信息就不再共享了。现在有了两个独立的、不相关的生命周期，二者也就不会互相扰乱了。</p>
<p>对于生命周期，我们希望将长生命周期（longest）转换为短生命周期（shortest），然后以不够长的生命周期（longer）覆盖。如下所示：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">evil_feeder</span></span>&lt;T&gt;(input: &amp;<span class="hljs-keyword">mut</span> T, val: T) &#123;<br>    *input = val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> mr_snuggles: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;meow! :3&quot;</span>;  <span class="hljs-comment">// mr. snuggles forever!!</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> spike = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;bark! &gt;:V&quot;</span>);<br>        <span class="hljs-keyword">let</span> spike_str: &amp;<span class="hljs-built_in">str</span> = &amp;spike;                <span class="hljs-comment">// 只能活过这个 block</span><br>        evil_feeder(&amp;<span class="hljs-keyword">mut</span> mr_snuggles, spike_str);    <span class="hljs-comment">// EVIL!</span><br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, mr_snuggles);                     <span class="hljs-comment">// UAF?</span><br>&#125;<br></code></pre></td></tr></table></figure><br>如果我们尝试运行，会得到什么结果呢？<br><figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">error[E0597]: `spike` does not live long <span class="hljs-built_in">enough</span><br>  --&gt; src/main.rs:<span class="hljs-number">9</span>:<span class="hljs-number">32</span><br>   |<span class="hljs-type"></span><br><span class="hljs-type">9</span>  |         <span class="hljs-type">let</span> spike_str: &amp;str = &amp;spike;<br>   |                                <span class="hljs-type">^^^^^ borrowed</span> value does not live long <span class="hljs-built_in">enough</span><br><span class="hljs-number">10</span> |         <span class="hljs-type">evil_feeder</span>(&amp;mut mr_snuggles, spike_str);<br><span class="hljs-number">11</span> |     <span class="hljs-type">&#125;</span><br><span class="hljs-type">   |     - borrowed</span> value only lives <span class="hljs-built_in">until</span> here<br>   |<span class="hljs-type"></span><br><span class="hljs-type">   = note</span>: borrowed value must be valid <span class="hljs-keyword">for</span> the static lifetime...<br></code></pre></td></tr></table></figure><br>让我们看看这一切到底是如何发生的。首先是新的 <code>evil_feeder</code> 函数：<br><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">fn evil_feeder&lt;<span class="hljs-built_in">T</span>&gt;(inp<span class="hljs-symbol">ut:</span> &amp;mut <span class="hljs-built_in">T</span>, v<span class="hljs-symbol">al:</span> <span class="hljs-built_in">T</span>) &#123;<br>    *input = val;<br>&#125;<br></code></pre></td></tr></table></figure><br>它接收了一个可变引用和一个值，然后用值覆盖了引用。</p>
<p>同时，调用者这边，我们传入了 <code>&amp;mut &#39;static str</code> 和 <code>&amp;&#39;spike_str str</code>。</p>
<ul>
<li>由于 <code>&amp;mut T</code> 对于 <code>T</code> 是不变的，因此编译器得出结论：第一个参数不能接收子类型。因此 <code>T</code> 的类型就必须是 <code>&amp;&#39;static str</code>。</li>
<li>另一个参数的类型是 <code>&amp;&#39;a str</code>，对 <code>&#39;a</code> 是协变的，因此编译器约束：<code>&amp;&#39;spike_str str</code> 必须是 <code>&amp;&#39;static str</code> 的子类型，也就是说 <code>&#39;spike_str</code> 必须是 <code>&#39;static</code> 的子类型，也就是说 <code>&#39;spike_str</code> 必须包含 <code>&#39;static</code>——但只有 <code>&#39;static</code> 自身能包含 <code>&#39;static</code>！</li>
</ul>
<p>这就是为什么当我们试图将 <code>&amp;spike</code> 赋值给 <code>spike_str</code> 时会出错。编译器工作的结论是 <code>spike_str</code> 必须永远存在，而 <code>&amp;spike</code> 根本不可能活那么久。</p>
<p>因此，尽管在引用它们的生命周期中是协变的，但只要放到一个有问题的上下文中，它们就会继承这种不变性。在上文例子中，我们就是从 <code>&amp;mut T</code> 中继承了不变性。</p>
<p>因此 Box（Vec、HashMap、……）之所以是协变的原因也和生命周期协变的原因相同：一旦你试图使用诸如可变引用，它们就会继承不变性，以防止坏事发生。</p>
<h6 id="3-8-5-拥有所有权时的协变"><a href="#3-8-5-拥有所有权时的协变" class="headerlink" title="3.8.5 拥有所有权时的协变"></a>3.8.5 拥有所有权时的协变</h6><p>Box 允许我们从值的层面关注被我们忽视的部分。和那些允许任意别名的语言不同，Rust 有着非常严格的规则：如果你能够修改或移动所有权，则你是唯一能够访问该变量的存在。<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> mr_snuggles: <span class="hljs-built_in">Box</span>&lt;Cat&gt; = ..;<br><span class="hljs-keyword">let</span> spike: <span class="hljs-built_in">Box</span>&lt;Dog&gt; = ..;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> pet: <span class="hljs-built_in">Box</span>&lt;Animal&gt;;<br>pet = mr_snuggles;<br>pet = spike;<br></code></pre></td></tr></table></figure><br>这段代码没有任何问题，因为当我们移动后，我们就完全忘记了 Cat 或 Dog 存在的事实——它们只剩下了 Animal。</p>
<p>和不可变引用协变的原因相反，拥有所有权的值之所以协变是因为你能够改变一切。旧地与新地之间不存在任何关系，而进行子类型转换所破坏的内容也就没人知道，因此就不会因为这部分信息产生矛盾了。</p>
<h3 id="3-9-Drop检查"><a href="#3-9-Drop检查" class="headerlink" title="3.9 Drop检查"></a>3.9 Drop检查</h3><p>我们已经知道生命周期给我们提供了一些很简单的规则，以保证我们永远不会读取悬垂引用。但是，到目前为止我们提到生命周期的长短时，指的都是非严格的关系。也就是说，当我们写<code>&#39;a: &#39;b</code>的时候，<code>&#39;a</code>其实也可以和<code>&#39;b</code>一样长。乍一看，这一点没什么意义。本来也不会有两个东西被同时销毁的，不是吗？我们去掉下面的<code>let</code>表达式的语法糖看看：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">let x<span class="hljs-comment">;</span><br>let y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&#123;<br>    let x<span class="hljs-comment">;</span><br>    &#123;<br>        let y<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>每一个都创建了自己的作用域，可以很清楚地看出来一个在另一个之前被销毁。但是，如果是下面这样的呢？<br><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> (x, y) = (<span class="hljs-built_in">vec</span>![], <span class="hljs-built_in">vec</span>![]);<br></code></pre></td></tr></table></figure><br>有哪一个比另一个存活更长吗？答案是，没有，没有哪个严格地比另一个长。当然，x和y中肯定有一个比另一个先销毁，但是销毁的顺序是不确定的。并非只有元组是这样，复合结构体从Rust 1.0开始就不会保证它们的销毁顺序。</p>
<p>我们已经清楚了元组和结构体这种内置复合类型的行为了。那么Vec这样的类型又是什么样的呢？Vec必须通过标准库代码手动销毁它的元素。通常来说，所有实现了Drop的类型在临死前都有一次回光返照的机会。所以，对于实现了Drop的类型，编译器没有充分的理由判断它们的内容的实际销毁顺序。</p>
<p>可是我们为什么要关心这个？因为如果系统不够小心，就可能搞出来悬垂指针。考虑下面这个简单的程序：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>);<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> (inspector, days);<br>    days = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">1</span>);<br>    inspector = Inspector(&amp;days);<br>&#125;<br></code></pre></td></tr></table></figure><br>这段程序是正确且可以正常编译的。<code>days</code>并不严格地比<code>inspector</code>存活得更长，但这没什么关系。只要<code>inspector</code>还存活着，<code>days</code>就一定也活着。</p>
<p>可如果我们添加一个析构函数，程序就不能编译了！<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>);<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;再过&#123;&#125;天我就退休了！&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> (inspector, days);<br>    days = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">1</span>);<br>    inspector = Inspector(&amp;days);<br>    <span class="hljs-comment">// 如果days碰巧先被销毁了</span><br>    <span class="hljs-comment">// 那么当销毁Inspector的时候，它会读取被释放的内存</span><br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>`days` does not live long enough<br>  --&gt; &lt;anon&gt;:15:1<br>   |<br>12 |     inspector = Inspector(&amp;days);<br>   |                            ---- borrow occurs here<br>...<br>15 | &#125;<br>   | ^ `days` dropped here while still borrowed<br>   |<br>   = note: values in a scope are dropped in the opposite order they are created<br><span class="hljs-keyword">error: </span>aborting due to previous error<br></code></pre></td></tr></table></figure><br>实现<code>Drop</code>使得<code>Inspector</code>可以在销毁前执行任意的代码。一些通常认为和它生命周期一样长的类型可能实际上比它先销毁，而这会有潜在的问题。</p>
<p>有意思的是，只有泛型需要考虑这个问题。如果不是泛型的话，那么唯一可用的生命周期就是<code>&#39;static</code>，而它确确实实会永远存在。这也就是这一问题被称之为“安全泛型销毁”的原因。安全泛型销毁是通过<code>drop</code>检查器执行的。我们还未涉及到<code>drop检查器</code>判断类型是否可用的细节，但其实我们之前已经讨论了这个问题的最主要规则：<br><strong><em>一个安全地实现Drop的类型，它的泛型参数生命周期必须严格地长于它本身</em></strong></p>
<p>遵守这一规则（大部分情况下）是满足借用检查器要求的必要条件，同时是满足安全要求的充分非必要条件。也就是说，如果类型遵守上述规则，它就一定可以安全地drop。</p>
<p>之所以并不总是满足借用检查器要求的必要条件，是因为有时类型借用了数据但是在Drop的实现里没有访问这些数据。</p>
<p>例如，上面的<code>Inspector</code>的这一变体就不会访问借用的数据：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>);<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inspector(_, &#123;&#125;) knows when *not* to inspect.&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> (inspector, days);<br>    days = <span class="hljs-built_in">Box</span>::nex(<span class="hljs-number">1</span>);<br>    inspector = Inspector(&amp;days, <span class="hljs-string">&quot;gadget&quot;</span>);<br>    <span class="hljs-comment">// 假设days碰巧先被销毁。</span><br>    <span class="hljs-comment">// 可当Inspector被销毁时，它的析构函数也不会访问借用的days。</span><br>&#125;<br></code></pre></td></tr></table></figure><br>同样，这个变体也不会访问借用的数据：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;T: fmt::Display&gt;(T, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>);<br><span class="hljs-keyword">impl</span>&lt;T: fmt::Display&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inspector(_, &#123;&#125;) knows when *not* to inspect.&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> (inspector, days): (Inspector&lt;&amp;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-built_in">Box</span>&lt;<span class="hljs-built_in">u8</span>&gt;);<br>    days = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">1</span>);<br>    inspector = Inspector(&amp;days, <span class="hljs-string">&quot;gadget&quot;</span>);<br>    <span class="hljs-comment">// 假设days碰巧先被销毁。</span><br>    <span class="hljs-comment">// 可当Inspector被销毁时，它的析构函数也不会访问借用的days。</span><br>&#125;<br></code></pre></td></tr></table></figure><br>但是，借用检查器在分析<code>main</code>函数的时候会拒绝上面两段代码，并指出<code>days</code>存活得不够长。</p>
<p>这是因为，当借用检查分析<code>main</code>函数的时候，它并不知道每个<code>Inspector</code>的<code>Drop</code>实现的内部细节。它只知道<code>inspector</code>的析构函数有访问借用数据的可能。</p>
<p>因此，<code>drop</code>检查器强制要求一个值借用的所有数据的生命周期必须严格长于值本身。</p>
<h6 id="3-9-1-留一个后门"><a href="#3-9-1-留一个后门" class="headerlink" title="3.9.1 留一个后门"></a>3.9.1 留一个后门</h6><p>上面的类型检查的规则在未来有可能会松动。</p>
<p>当前的分析方法是很保守甚至苛刻的，它强制要求一个值借用的数据必须比值本身长寿，以保证绝对的安全。</p>
<p>未来的版本中，分析过程会更加精细，以减少安全的代码被拒绝的情况。比如上面的两个<code>Inspector</code>，它们知道在销毁过程中不应该被检查。</p>
<p>同时，有一个还未稳定的属性可以用来（非安全地）声明类型的析构函数保证不会访问过期的数据，即使类型的签名显示有这种可能存在。</p>
<p>这个属性是<code>my_dangle</code>，在<strong>RFC 1327</strong>中被引入。我们可以这样将其放在上面的<code>Inspector</code>例子里：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>);<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> <span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inspector(_, &#123;&#125;) knows when *not* to inspect.&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>使用这个属性要求<code>Drop</code>的实现被标为<code>unsafe</code>，因为编译器将不会检查有没有过期的数据（比如self.0）被访问。</p>
<p>这个属性可以赋给任意数量的生命周期和类型参数。下面这个例子里，我们声明我们不会访问有生命周期<code>&#39;b</code>的引用背后的数据，而类型<code>T</code>也只会被用来转移或销毁。但是我们没有为<code>&#39;a</code>和<code>U</code>添加属性，因为我们确实会用到这个生命周期和类型：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, T, U: Display&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>, &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">u8</span>, T, U);<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-meta">#[may_dangle]</span> <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-meta">#[may_dangle]</span> T, U: Display&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, T, U&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inspector(&#123;&#125;, _, _, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面的例子中，哪些数据不会被用到是一目了然的。但是，有时候这些泛型参数会被间接地访问。间接访问的形式包括：</p>
<ul>
<li>使用回调函数</li>
<li>通过调用trait方法<br>（在日后的版本里可能增加其他间接访问的途径。）</li>
</ul>
<p>以下是使用回调的例子：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;T&gt;(T, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>, <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">for</span> &lt;<span class="hljs-symbol">&#x27;r</span>&gt; <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(&amp;<span class="hljs-symbol">&#x27;r</span> T) -&gt; <span class="hljs-built_in">String</span>&gt;);<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 如果T的类型是&amp;&#x27;a _，self.2的调用可能访问借用的数据</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inspector(&#123;&#125;, &#123;&#125;) unwittingly inspects expired data.&quot;</span>,<br>                 (<span class="hljs-keyword">self</span>.<span class="hljs-number">2</span>)(&amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>), <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这是trait方法调用的例子：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inspector</span></span>&lt;T: fmt::Display&gt;(T, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>);<br><span class="hljs-keyword">impl</span>&lt;T: fmt::Display&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Inspector&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">drop</span>) &#123;<br>        <span class="hljs-comment">// 下面有一个对&lt;T as Display&gt;::fmt的隐藏调用，</span><br>        <span class="hljs-comment">// 当T的类型是&amp;&#x27;a _时，可能访问借用数据</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inspector(&#123;&#125;, &#123;&#125;) unwittingly inspects expired data.&quot;</span>,<br>                 <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>当然，这些访问可以进一步地被隐藏在其他的析构函数调用的方法里，而不仅是直接写在函数中。</p>
<p>上面的几个例子里，<code>&amp;&#39;a u8</code>都在析构函数里被访问了。如果给它添加<code>#[may_dangle]</code>属性，这些类型很可能会产生借用检查器无法捕捉的错误，引发不可预料的灾难。所以最好能避免使用这个属性。</p>
<h3 id="3-10-PhantomData-幽灵数据"><a href="#3-10-PhantomData-幽灵数据" class="headerlink" title="3.10 PhantomData-幽灵数据"></a>3.10 PhantomData-幽灵数据</h3><p>在编写非安全代码时，我们常常遇见这种情况：类型或生命周期逻辑上与一个结构体关联起来了，但是却不属于结构体的任何一个成员。这种情况对于生命周期尤为常见。比如，<code>&amp;&#39;a [T]</code>的<code>Iter</code>大概是这么定义的：<br><figure class="highlight monkey"><table><tr><td class="code"><pre><code class="hljs monkey">struct Iter&lt;<span class="hljs-comment">&#x27;a, T: &#x27;a&gt; &#123;</span><br>    ptr: *<span class="hljs-keyword">const</span> T,<br>    <span class="hljs-keyword">end</span>: *<span class="hljs-keyword">const</span> T,<br>&#125;<br></code></pre></td></tr></table></figure><br>但是，因为<code>&#39;a</code>没有在结构体内被使用，它是无界的。由于一些历史原因，无界生命周期和类型禁止出现在结构体定义中。所以我们必须想办法在结构体内用到这些类型，这也是正确的变性检查和<code>drop</code>检查的必要条件。</p>
<p>我们使用一个特殊的标志类型<code>PhantomData</code>做到这一点。<code>PhantomData</code>不消耗存储空间，它只是模拟了某种类型的数据，以方便静态分析。这么做比显式地告诉类型系统你需要的变性更不容易出错，而且还能提供<code>drop</code>检查需要的信息。</p>
<p><code>Iter</code>逻辑上包含一系列<code>&amp;&#39;a T</code>，所以我们用<code>PhantomData</code>这样去模拟它：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::marker;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Iter</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    ptr: *<span class="hljs-keyword">const</span> T,<br>    end: *<span class="hljs-keyword">const</span> T,<br>    _marker: marker::PhantomData&lt;&amp;<span class="hljs-symbol">&#x27;a</span> T&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><br>就是这样，生命周期变得有界了，你的迭代器对于’a和T也可变了。一切尽如人意。</p>
<p>另一个重要的例子是<code>Vec</code>，它差不多是这么定义的：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">struct Vec<span class="hljs-params">&lt;T&gt;</span> &#123;<br><span class="hljs-symbol">    data:</span> *const T, <span class="hljs-comment">// *const是可变的！</span><br><span class="hljs-symbol">    len:</span> usize,<br><span class="hljs-symbol">    cap:</span> usize,<br>&#125;<br></code></pre></td></tr></table></figure><br>和之前的例子不同，这个定义已经满足我们的各种要求了。<code>Vec</code>的每一个泛型参数都被至少一个成员使用过了。非常完美！</p>
<p>你高兴的太早了。</p>
<p>Drop检查器会判断<code>Vec&lt;T&gt;</code>并不拥有<code>T</code>类型的值，然后它认为无需担心<code>Vec</code>在析构函数里能不能安全地销毁<code>T</code>，再然后它会允许人们创建不安全的Vec析构函数。</p>
<p>为了让drop检查器知道我们确实拥有T类型的值，也就是需要在销毁Vec的时候同时销毁T，我们需要添加一个额外的PhantomData：<br><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">use std::marker:<br>struct Vec<span class="hljs-params">&lt;T&gt;</span> &#123;<br><span class="hljs-symbol">    data:</span> *const T, <span class="hljs-comment">// *const是可变的！</span><br><span class="hljs-symbol">    len:</span> usize,<br><span class="hljs-symbol">    cap:</span> usize,<br><span class="hljs-symbol">    _marker:</span> marker::PhantomData<span class="hljs-params">&lt;T&gt;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><br>让裸指针拥有数据是一个很普遍的设计，以至于标准库为它自己创造了一个叫<code>Unique&lt;T&gt;</code>的组件，它可以：</p>
<ul>
<li>封装一个<code>*const T</code>处理变性</li>
<li>包含一个 PhantomData</li>
<li>自动实现<code>Send/Sync</code>，模拟和包含<code>T</code>时一样的行为</li>
<li>将指针标记为<code>NonZero</code>以便空指针优化</li>
</ul>
<h6 id="3-10-1-PhantomData模式表"><a href="#3-10-1-PhantomData模式表" class="headerlink" title="3.10.1 PhantomData模式表"></a>3.10.1 PhantomData模式表</h6><p>下表展示了各种牛X闪闪的<code>PhantomData</code>用法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Phantom 类型</th>
<th>‘a</th>
<th>‘T</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PhantomData&lt;T&gt;</code></td>
<td>-</td>
<td>协变（可触发drop检查）</td>
</tr>
<tr>
<td><code>PhantomData&lt;&amp;&#39;a T&gt;</code></td>
<td>协变</td>
<td>协变</td>
</tr>
<tr>
<td><code>PhantomData&lt;&amp;&#39;a mut T&gt;</code></td>
<td>协变</td>
<td>不变</td>
</tr>
<tr>
<td><code>PhantomData&lt;*const T&gt;</code></td>
<td>-</td>
<td>协变</td>
</tr>
<tr>
<td><code>PhantomData&lt;*mut T&gt;</code></td>
<td>-</td>
<td>不变</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn(T)&gt;</code></td>
<td>-</td>
<td>逆变(*)</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn() -&gt; T</code></td>
<td>-</td>
<td>协变</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn(T) -&gt; T&gt;</code></td>
<td>-</td>
<td>不变</td>
</tr>
<tr>
<td><code>PhantomData&lt;Cell&lt;&amp;&#39;a ()&gt;&gt;</code></td>
<td>不变</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>(*)如果发生变性的冲突，这个是不变的</p>
<h3 id="3-11-分解借用"><a href="#3-11-分解借用" class="headerlink" title="3.11 分解借用"></a>3.11 分解借用</h3><p>可变引用的Mutex属性在处理复合类型时能力非常有限。借用检查器只能理解一些简单的东西，而且极易失败。他对结构体还算是充分了解，知道结构体的成员可能被分别借用。所以这段代码现在可以正常工作：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">struct Foo &#123;<br><span class="hljs-symbol">    a:</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">,</span><br><span class="hljs-symbol">    b:</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">,</span><br><span class="hljs-symbol">    c:</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">,</span><br>&#125;<br>let mut <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> Foo &#123;a: <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> b: <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span>: <span class="hljs-number">0</span>&#125;<span class="hljs-comment">;</span><br>let a <span class="hljs-operator">=</span> &amp;mut <span class="hljs-keyword">x</span>.a<span class="hljs-comment">;</span><br>let b <span class="hljs-operator">=</span> &amp;mut <span class="hljs-keyword">x</span>.b<span class="hljs-comment">;</span><br>let <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> &amp;<span class="hljs-keyword">x</span>.<span class="hljs-keyword">c</span><span class="hljs-comment">;</span><br>*b +<span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>let <span class="hljs-keyword">c</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> &amp;<span class="hljs-keyword">x</span>.<span class="hljs-keyword">c</span><span class="hljs-comment">;</span><br>*a +<span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>println!(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span><span class="hljs-punctuation">,</span> a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span><span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>但是，借用检查器对于数组和slice的理解却是一团浆糊，所以这段代码无法通过检查：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> a = &amp;<span class="hljs-keyword">mut</span> x[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> b = &amp;<span class="hljs-keyword">mut</span> x[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);<br></code></pre></td></tr></table></figure><br><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">&lt;anon&gt;:4:14: 4:18 <span class="hljs-meta">error</span>: cannot borrow `<span class="hljs-meta">x</span>[..]` <span class="hljs-meta">as</span> mutable more than once at a time<br>&lt;anon&gt;:4 let b = <span class="hljs-variable">&amp;mut</span> <span class="hljs-meta">x</span>[1];<br>                      ^~~~<br>&lt;anon&gt;:3:14: 3:18 note: previous borrow of `<span class="hljs-meta">x</span>[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, <span class="hljs-meta">or</span> modification of `<span class="hljs-meta">x</span>[..]` <span class="hljs-meta">until</span> the borrow ends<br>&lt;anon&gt;:3 let a = <span class="hljs-variable">&amp;mut</span> <span class="hljs-meta">x</span>[0];<br>                      ^~~~<br>&lt;anon&gt;:6:2: 6:2 note: previous borrow ends here<br>&lt;anon&gt;:1 fn ma<span class="hljs-meta">in(</span>) &#123;<br>&lt;anon&gt;:2 let mut <span class="hljs-meta">x</span> = [1, 2, 3];<br>&lt;anon&gt;:3 let a = <span class="hljs-variable">&amp;mut</span> <span class="hljs-meta">x</span>[0];<br>&lt;anon&gt;:4 let b = <span class="hljs-variable">&amp;mut</span> <span class="hljs-meta">x</span>[1];<br>&lt;anon&gt;:5 println!(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);<br>&lt;anon&gt;:6 &#125;<br>         ^<br><span class="hljs-meta">error</span>: aborting due to 2 previous errors<br></code></pre></td></tr></table></figure><br>借用检查器连这个简单的场景都理解不了，那它更不可能理解一些通用容器类型了，比如说树，尤其是出现不同的键对应相同的值的时候。</p>
<p>为了能“教育”借用检查器我们的所作所为是正确的，我们还是要使用非安全代码。比如，可变slice暴露了一个<code>split_at_mut</code>的方法，它接收一个slice然后返回两个可变slice。一个包括索引值左边所有的值，另一个包含右边所有的值。我们知道这个方法是安全的，因为两个slice没有重叠部分，也就不会出现别名问题。但是它的实现还是要涉及到非安全的内容：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">fn split<span class="hljs-constructor">_at_mut(&amp;<span class="hljs-params">mut</span> <span class="hljs-params">self</span>, <span class="hljs-params">mid</span>: <span class="hljs-params">usize</span>)</span> -&gt; (&amp;mut <span class="hljs-literal">[T]</span>, &amp;mut <span class="hljs-literal">[T]</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = self.len<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">let</span> ptr = self.<span class="hljs-keyword">as</span><span class="hljs-constructor">_mut_ptr()</span>;<br>    <span class="hljs-keyword">assert</span>!(mid &lt;= len);<br>    unsafe &#123;<br>        (from<span class="hljs-constructor">_raw_parts_mut(<span class="hljs-params">ptr</span>, <span class="hljs-params">mid</span>)</span>),<br>         from<span class="hljs-constructor">_raw_parts_mut(<span class="hljs-params">ptr</span>.<span class="hljs-params">offset</span>(<span class="hljs-params">mid</span> <span class="hljs-params">as</span> <span class="hljs-params">isize</span>)</span>, len - mid))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这有一点难懂。为了避免两个<code>&amp;mut</code>指向相同的值，我们通过裸指针显式创建了两个全新的slice。</p>
<p>不过迭代器产生可变引用的方法更加难懂。迭代器trait的定义如下：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Iterator</span></span> &#123;<br>    typr Item;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><br>这份定义里，<code>Self::Item</code>与<code>slef</code>没有直接关系。也就是说我们可以连续调用<code>next</code>很多次，并且同时保存着所有的结果。对于值的迭代器这么做完全可以，完全符合语义。对于共享引用这么做也没什么问题，因为允许任意过个共享引用指向同一个值（当然迭代器本身需要是独立于被共享内容的对象）。</p>
<p>但是可变引用就麻烦了。乍一看，可变引用完全不适用这个API，因为那会产生多个指向相同对象的可变引用。</p>
<p>可实际上它能够正常工作，这是因为迭代器是一个一次性对象。IterMut生成的东西最多只会生成一次，所以实际上我们没有生成多个指向相同数据的可变指针。</p>
<p>更不可思议的是，可变迭代器对于许多类型的实现甚至不需要非安全代码！</p>
<p>例如，下面是单向列表的代码：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Link</span></span>&lt;T&gt; = <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Box</span>&lt;Node&lt;T&gt;&gt;&gt;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span>&lt;T&gt; &#123;<br>    elem: T,<br>    next: Link&lt;T&gt;,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedList</span></span>&lt;T&gt; &#123;<br>    head: Link&lt;T&gt;,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IterMut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(<span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Node&lt;T&gt;&gt;);<br><span class="hljs-keyword">impl</span>&lt;T&gt; LinkedList&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">iter_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; IterMut&lt;T&gt; &#123;<br>        IterMut(<span class="hljs-keyword">self</span>.head.as_mut().map(|node| &amp;<span class="hljs-keyword">mut</span> **node))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> IterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.take().map(|node| &#123;<br>            <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> = node.next.as_mut().map(|node| &amp;<span class="hljs-keyword">mut</span> **node);<br>            &amp;<span class="hljs-keyword">mut</span> node.elem<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这是可变slice：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IterMut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span>[T]);<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> IterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">let</span> slice = mem::replace(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, &amp;<span class="hljs-keyword">mut</span> []);<br>        <span class="hljs-keyword">if</span> slice.is_empty() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>; &#125;<br>        <span class="hljs-keyword">let</span> (l, r) = slice.split_at_mut(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> = r;<br>        l.get_mut(<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> IterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">let</span> slice = mem::replace(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, &amp;<span class="hljs-keyword">mut</span> []);<br>        <span class="hljs-keyword">if</span> slice.is_empty() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>; &#125;<br>        <span class="hljs-keyword">let</span> new_len = slice.len() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> (l, r) = slice.split_at_mut(new_len);<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> = l;<br>        r.get_mut(<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>还有二叉树：<br><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::VecDeque;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Link</span></span>&lt;T&gt; = <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Box</span>&lt;Node&lt;T&gt;&gt;&gt;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span>&lt;T&gt; &#123;<br>    elem: T,<br>    left: Link&lt;T&gt;,<br>    right: Link&lt;T&gt;,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span></span>&lt;T&gt; &#123;<br>    root: Link&lt;T&gt;,<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NodeIterMut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    elem: <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T&gt;,<br>    left: <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Node&lt;T&gt;&gt;,<br>    right: <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Node&lt;T&gt;&gt;,<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    Elem(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T),<br>    Node(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Node&lt;T&gt;),<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IterMut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(VecDeque&lt;NodeIterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;&gt;);<br><span class="hljs-keyword">impl</span>&lt;T&gt; Tree&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">iter_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; IterMut&lt;T&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> deque = VecDeque::new();<br>        <span class="hljs-keyword">self</span>.root.as_mut().map(|root| deque.push_front(root.iter_mut()));<br>        IterMut(deque)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Node&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">iter_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; NodeIterMut&lt;T&gt; &#123;<br>        NodeIterMut &#123;<br>            elem: <span class="hljs-literal">Some</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.elem),<br>            left: <span class="hljs-keyword">self</span>.left.as_mut().map(|node| &amp;<span class="hljs-keyword">mut</span> **node),<br>            right: <span class="hljs-keyword">self</span>.right.as_mut().map(|node| &amp;<span class="hljs-keyword">mut</span> **node),<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> NodeIterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = State&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.left.take() &#123;<br>            <span class="hljs-literal">Some</span>(node) =&gt; <span class="hljs-literal">Some</span>(State::Node(node)),<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.elem.take() &#123;<br>                <span class="hljs-literal">Some</span>(elem) =&gt; <span class="hljs-literal">Some</span>(State::Elem(elem)),<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.right.take() &#123;<br>                    <span class="hljs-literal">Some</span>(node) =&gt; <span class="hljs-literal">Some</span>(State::Node(node)),<br>                    <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> NodeIterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.right.take() &#123;<br>            <span class="hljs-literal">Some</span>(node) =&gt; <span class="hljs-literal">Some</span>(State::Node(node)),<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.elem.take() &#123;<br>                <span class="hljs-literal">Some</span>(elem) =&gt; <span class="hljs-literal">Some</span>(State::Elem(elem)),<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.left.take() &#123;<br>                    <span class="hljs-literal">Some</span>(node) =&gt; <span class="hljs-literal">Some</span>(State::Node(node)),<br>                    <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> IterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.front_mut().and_then(|node_it| node_it.next()) &#123;<br>                <span class="hljs-literal">Some</span>(State::Elem(elem)) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Some</span>(elem),<br>                <span class="hljs-literal">Some</span>(State::Node(node)) =&gt; <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.push_front(node.iter_mut()),<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">None</span> = <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.pop_front() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> &#125;,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> IterMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.back_mut().and_then(|node_it| node_it.next_back()) &#123;<br>                <span class="hljs-literal">Some</span>(State::Elem(elem)) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Some</span>(elem),<br>                <span class="hljs-literal">Some</span>(State::Node(node)) =&gt; <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.push_back(node.iter_mut()),<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">None</span> = <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.pop_back() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> &#125;,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>所有这些都是完全安全而且能稳定运行的！这已经超出了我们之前看过的简单结构体的例子：Rust能够理解你把一个可变引用安全地分解为多个部分。接下来我们可以通过Option永久地访问这个引用（或者像对于slice那样，替换为一个空的slice）。</p>

      
       
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '07584e1e38d09c739a16',
            clientSecret: '6a466750b46c76ed9cc8ee0fe0d78e0c33898937',
            repo: 'yangandmore.github.io',
            owner: 'Yangandmore',
            admin: ['Yangandmore'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yangandmore
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
